<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="801"></a>801. <tt>tuple</tt> and <tt>pair</tt> trivial members</h3>
<p><b>Section:</b> 20.4 [tuple] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-02-18 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple">issues</a> in [tuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Classes with trivial special member functions are inherently more
efficient than classes without such functions.  This efficiency is
particularly pronounced on modern ABIs that can pass small classes
in registers.  Examples include value classes such as complex numbers
and floating-point intervals.  Perhaps more important, though, are
classes that are simple collections, like <tt>pair</tt> and <tt>tuple</tt>.  When the
parameter types of these classes are trivial, the <tt>pair</tt>s and <tt>tuple</tt>s
themselves can be trivial, leading to substantial performance wins.
</p>
<p>
The current working draft make specification of trivial functions
(where possible) much easer through <tt>default</tt>ed and <tt>delete</tt>d functions.
As long as the semantics of defaulted and deleted functions match
the intended semantics, specification of defaulted and deleted
functions will yield more efficient programs.
</p>
<p>
There are at least two cases where specification of an explicitly
defaulted function may be desirable.
</p>
<p>
First, the <tt>std::pair</tt> template has a non-trivial default constructor,
which prevents static initialization of the pair even when the
types are statically initializable.  Changing the definition to
</p>

<blockquote><pre>
pair() = default;
</pre></blockquote>

<p>
would enable such initialization.  Unfortunately, the change is
not semantically neutral in that the current definition effectively
forces value initialization whereas the change would not value
initialize in some contexts.
</p>

<p>
** Does the committee confirm that forced value initialization
was the intent?  If not, does the committee wish to change the
behavior of <tt>std::pair</tt> in C++0x?
</p>
<p>
Second, the same default constructor issue applies to <tt>std::tuple</tt>.
Furthermore, the <tt>tuple</tt> copy constructor is current non-trivial,
which effectively prevents passing it in registers.  To enable
passing <tt>tuples</tt> in registers, the copy constructor should be
make explicitly <tt>default</tt>ed.  The new declarations are:
</p>

<blockquote><pre>
tuple() = default;
tuple(const tuple&amp;) = default;
</pre></blockquote>

<p>
This changes is not implementation neutral.  In particular, it
prevents implementations based on pointers to the parameter
types.  It does however, permit implementations using the
parameter types as bases.
</p>
<p>
** How does the committee wish to trade implementation
efficiency versus implementation flexibility?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
General agreement; the first half of the issue is NAD.
</p>
<p>
Before voting on the second half, it was agreed that a "Strongly Favor"
vote meant support for trivial tuples (assuming usual requirements met),
even at the expense of other desired qualities. A "Weakly Favor" vote
meant support only if not at the expense of other desired qualities.
</p>
<p>
Concensus: Go forward, but not at expense of other desired qualities.
</p>
<p>
It was agreed to Alisdair should fold this work in with his other
pair/tuple action items, above, and that issue 801 should be "open", but
tabled until Alisdair's proposals are disposed of.
</p>
</blockquote>

<p><i>[
2009-05-27 Daniel adds:
]</i></p>


<blockquote>
This is partly solved by 1117<a href="lwg-closed.html#1117">1117</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Wait for dust to settle from fixing exception safety problem
with rvalue refs.
</blockquote>

<p><i>[
2009-07-20 Alisdair adds:
]</i></p>


<blockquote>
<p>
Basically, this issue is what should we do with the default constructor
for pairs and tuples of trivial types.  The motivation of the issue was
to force static initialization rather than dynamic initialization, and
was rejected in the case of pair as it would change the meaning of
existing programs.  The advice was "do the best we can" for tuple
without changing existing meaning.
</p>

<p>
Frankfurt seems to simply wait and see the resolution on no-throw move
constructors, which (I believe) is only tangentially related to this
issue, but as good as any to defer until Santa Cruz.
</p>

<p>
Looking again now, I think constant (static) initialization for pair can
be salvaged by making the default construct constexpr.  I have a
clarification from Core that this is intended to work, even if the
constructor is not trivial/constexpr, so long as no temporaries are
implied in the process (even if elided).
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as open. Alisdair to provide wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We believe this may be NAD Editorial since both pair and tuple now have
constexpr default constructors, but we're not sure.
</p>
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Daniel believes his pair/tuple paper will resolve this issue. <tt>constexpr</tt> will allow static initialization, and he is already changing the move and copy constructors to be defaulted.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> should resolve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>





<hr>
<h3><a name="964"></a>964. Various threading bugs #14</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the constructor for <tt>condition_variable</tt> has several
error conditions, but the requirements for the constructor for
<tt>condition_variable_any</tt> has none. Is this difference intentional?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open, pass to Howard. If this is intentional, a note may be
helpful. If the error conditions are to be copied from
<tt>condition_variable</tt>, this depends on LWG 965<a href="lwg-defects.html#965">965</a>.
</blockquote>

<p><i>[
Post Summit Howard adds:
]</i></p>


<blockquote>
The original intention 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2447.htm#ConditionVariablesWording">N2447</a>)
was to let the OS return whatever errors it was going to return, and for
those to be translated into exceptions, for both
<tt>condition_variable</tt> and <tt>condition_variable_any</tt>.  I have not
received any complaints about specific error conditions from vendors on
non-POSIX platforms, but such complaints would not surprise me if they surfaced.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open. Benjamin to provide wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We don't have throw clauses for condition variables.
</p>
<p>
This issue may be dependent on LWG 1268<a href="lwg-active.html#1268">1268</a>.
</p>
<p>
Leave open. Detlef will coordinate with Benjamin.
</p>
<p>
Consider merging LWG 964, 966<a href="lwg-active.html#966">966</a>, and 1268<a href="lwg-active.html#1268">1268</a> into a
single paper.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="966"></a>966. Various threading bugs #16</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]:
<tt>condition_variable::wait</tt> and
<tt>condition_variable::wait_until</tt> both have a postcondition that
<tt>lock</tt> is locked by the calling thread, and a throws clause that
requires throwing an exception if this postcondition cannot be achieved.
How can the implementation detect that this <tt>lock</tt> can never be
obtained?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Requires wording. Agreed this is an issue, and the
specification should not require detecting deadlocks.
</blockquote>

<p><i>[
2009-08-01 Howard provides wording.
]</i></p>


<blockquote>
<p>
The proposed wording is inspired by the POSIX spec which says:
</p>

<blockquote>
<dl>
<dt>[EINVAL]</dt>
<dd>The value specified by cond or mutex is invalid.</dd>
<dt>[EPERM]</dt>
<dd>The mutex was not owned by the current thread at the time of the call.</dd>
</dl>
</blockquote>

<p>
I do not believe [EINVAL] is possible without memory corruption (which we don't
specify).  [EPERM] is possible if this thread doesn't own the mutex, which is
listed as a precondition.  "May" is used instead of "Shall" because not all
OS's are POSIX.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>

<p><i>[
2009-10-23 Detlef Provided wording.
]</i></p>


<blockquote>
<p>
Detlef's wording put in Proposed resolution.  Original wording here:
</p>
<blockquote>
<p>
Change 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<i>Throws:</i> <ins>May throw</ins> <tt>std::system_error</tt> 
<ins>
if a precondition is not met.
</ins>
<del>when the effects or postcondition
cannot be achieved.</del>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>

<p><i>[
2009-11-18 Anthony adds:
]</i></p>


<blockquote>
<p>
<tt>condition_variable::wait</tt> takes a <tt>unique_lock&lt;mutex&gt;</tt>. We
know whether or not a <tt>unique_lock</tt> owns a lock, through use of its
<tt>owns_lock()</tt> member.
</p>

<p>
I would like to propose the following resolution:
</p>

<blockquote>
<p>
Modify the first sentence of 30.5.1 [thread.condition.condvar] p9:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
9 <i>Precondition:</i> <del><tt>lock</tt> is locked by the calling thread</del>
<ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>, and either
<p>...</p>
</blockquote>
</blockquote>

<p>
Replace 30.5.1 [thread.condition.condvar] p11-13 with:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
11 <i>Postcondition:</i> <del><tt>lock</tt> is locked by the calling
thread</del> <ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>.
</p>

<p>
12 <i>Throws:</i> <tt>std::system_error</tt> <del>when the effects or
postcondition cannot be achieved</del> <ins>if the implementation detects that
the preconditions are not met or the effects cannot be achieved. Any exception
thrown by <tt>lock.lock()</tt> or <tt>lock.unlock()</tt></ins>.
</p>

<p>
13 <i>Error Conditions:</i> <ins>The error conditions are implementation
defined.</ins>
</p>

<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There are heavy conflicts with adopted papers.
</p>
<p>
This issue is dependent on LWG 1268<a href="lwg-active.html#1268">1268</a>.
</p>
<p>
Leave open pending outstanding edits to the working draft. Detlef will provide
wording.
</p>
<p>
Possibly related to 964<a href="lwg-active.html#964">964</a>.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<p><del>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or
postcondition cannot be achieved.
</del></p>
<p><del>
Error conditions:
</del></p>
<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

<p><ins>
<i>Throws:</i> It is implementation-defined whether a <tt>std::system_error</tt>
with implementation-defined error condition is thrown if the
precondition is not met.
</ins></p>
</blockquote>






<hr>
<h3><a name="985"></a>985. Allowing throwing move</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2009-02-12 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Introduction</b>
</p>

<p>This proposal is meant to resolve potential regression of the
<a href ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
draft, see
next section, and to relax the requirements for containers of types with
throwing move constructors.</p>

<p>The basic problem is that some containers operations, like <tt>push_back</tt>,
have a strong exception safety
guarantee (i.e. no side effects upon exception) that are not achievable when
throwing move constructors are used since there is no way to guarantee revert
after partial move. For such operations the implementation can at most provide
the basic guarantee (i.e. valid but unpredictable) as it does with multi
copying operations (e.g. range insert).</p>

<p>For example, <tt>vector&lt;T&gt;::push_back()</tt> (where <tt>T</tt> has a move
constructor) might resize the <tt>vector</tt> and move the objects to the new underlying
buffer. If move constructor throws it might
not be possible to recover the throwing object or to move the old objects back to
the original buffer.</p>

<p>The current draft is explicit by disallowing throwing move
for some operations (e.g. <tt>vector&lt;&gt;::reserve</tt>) and not clear about other
operations mentioned in 23.2.1 [container.requirements.general]/10
(e.g. single element <tt>insert</tt>): it guarantees strong exception
safety without explicitly disallowing a throwing move constructor.
</p>

<p>
<b>Regression</b>
</p>

<p>This section only refers to cases in which the contained object
is by itself a standard container.</p>

<p>Move constructors of standard containers are allowed to throw and therefore
existing operations are broken, compared with C++03, due to move optimization.
(In fact existing implementations like Dinkumware are actually throwing).</p>

<p>For example, <tt>vector&lt; list&lt;int&gt; &gt;::reserve</tt> yields
undefined behavior since <tt>list&lt;int&gt;</tt>'s move constructor is allowed to throw.
On the other hand, the same operation has strong exception safety guarantee in
C++03.</p>

<p>There are few options to solve this regression:</p>

<ol>
<li>
Disallow throwing move and throwing default constructor
</li>

<li>
Disallow throwing move but disallowing usage after move
</li>

<li>
Special casing
</li>

<li>
Disallow throwing move and making it optional
</li>

</ol>

<p>Option 1 is suggested by proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
but it might not be applicable for existing implementations for which
containers default constructors are throwing.</p>

<p>Option 2 limits the usage significantly and it's error prone
by allowing zombie objects that are nothing but destructible (e.g. no <tt>clear()</tt>
is allowed after move). It also potentially complicates the implementation by
introducing special state.</p>

<p>Option 3 is possible, for example, using default
construction and <tt>swap</tt> instead of move for standard containers case. The
implementation is also free to provide special hidden operation for non
throwing move without forcing the user the cope with the limitation of option-2
when using the public move.</p>

<p>Option 4 impact the efficiency in all use cases due to rare throwing move.</p>

<p>The proposed wording will imply option 1 or 3 though option 2 is also
achievable using more wording. I personally oppose to option 2 that has impact
on usability.</p>

<p>
<b>Relaxation for user types</b>
</p>

<p>Disallowing throwing move constructors in general seems very restrictive
since, for example, common implementation of move will be default construction
+ <tt>swap</tt> so move will throw if the
default constructor will throw. This is currently the case with the Dinkumware
implementation of node based containers (e.g. <tt>std::list</tt>)
though this section doesn't refer to standard types.</p>

<p>For throwing move constructors it seem that the implementation should have
no problems to provide the basic guarantee instead of the strong one. It's
better to allow throwing move constructors with basic guarantee than to
disallow it silently (compile and run), via undefined behavior.</p>

<p>There might still be cases in which the relaxation will break existing generic
code that assumes the strong guarantee but it's broken either way given a
throwing move constructor since this is not a preserving optimization. </p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bjarne comments (referring to his draft paper):
"I believe that my suggestion simply solves that.
Thus, we don't need a throwing move."
</p>
<p>
Move to Open and recommend it be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Should wait to get direction from Dave/Rani
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2983.html">N2983</a>).
</blockquote>

<p><i>[
2010-03-28 Daniel updated wording to sync with N3092.
]</i></p>


<blockquote>
<p>
The suggested change of 23.3.2.3 [deque.modifiers]/2 should be removed,
because the current wording does say more general things:
</p>

<blockquote>
2 <i>Remarks:</i> If an exception is thrown other than by the copy constructor,
move constructor, assignment operator, or move assignment operator of <tt>T</tt>
there are no effects. If an exception is thrown by the move constructor of a
non-CopyConstructible <tt>T</tt>, the effects are unspecified.
</blockquote>

<p>
The suggested change of 23.4.1.2 [vector.capacity]/2 should be removed,
because the current wording does say more general things:
</p>

<blockquote>
2 <i>Effects:</i> A directive that informs a <tt>vector</tt> of a planned change
in size, so that it can manage the storage allocation accordingly. After
<tt>reserve()</tt>, <tt>capacity()</tt> is greater or equal to the argument of
<tt>reserve</tt> if reallocation happens; and equal to the previous value of
<tt>capacity()</tt> otherwise. Reallocation happens at this point if and only if
the current capacity is less than the argument of <tt>reserve()</tt>. If an
exception is thrown other than by the move constructor of a
non-<tt>CopyConstructible</tt> type, there are no effects.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
23.2.1 [container.requirements.general]  paragraph 11 add footnote:
</p>

<blockquote>
<p>
-11- Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
</ul>

<p>
<ins>[<i>Note</i>: for compatibility with C++
2003, when "no effect" is required, standard containers should not use the
value_type's throwing move constructor when the contained object is by itself a
standard container. -- <i>end note</i>]</ins>
</p>

</blockquote>

<p>23.2.5.1 [unord.req.except] change paragraph 2 to say: </p>

<blockquote>
<p>
-2- For unordered associative containers, if an exception is
thrown by any operation other than the container's hash function from within an
<tt>insert()</tt> function inserting a single element, the <tt>insert()</tt>
function has no effect<ins> unless the exception is thrown by the contained
object move constructor</ins>.
</p>

<p>
-4- For unordered associative containers, if an exception is
thrown from within a <tt>rehash()</tt> function other than by the container's hash
function or comparison function, the <tt>rehash()</tt> function has no effect
<ins>unless the exception is thrown by the contained
object move constructor</ins>.</p>

</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> If an exception is thrown other than by
the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt>
there are no effects.
<ins>If an exception is thrown by <tt>push_back()</tt> or <tt>emplace_back()</tt>
function, that function has no effects unless the exception is thrown by
the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.4.1.2 [vector.capacity] paragraph 2 change to say:
</p>

<blockquote>
-2- <i>Effects:</i> A directive that informs a <tt>vector</tt>
of a planned change in size, so
that it can manage the storage allocation accordingly. After <tt>reserve()</tt>,
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt>
if reallocation happens; and equal
to the previous value of <tt>capacity()</tt>
otherwise. Reallocation happens at this point if and only if the current
capacity is less than the argument of <tt>reserve()</tt>.
If an exception is thrown, there are no effects<ins>
unless the exception is thrown by the contained object move constructor</ins>.
</blockquote>

<p>
23.4.1.2 [vector.capacity] paragraph 12 change to say:
</p>

<blockquote>
-12- <i>Requires:</i> <del>If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins>If an exception is thrown, there are no effects unless the exception is thrown by
the contained object move constructor.</ins>
</blockquote>

<p>
23.4.1.4 [vector.modifiers] change paragraph 1 to say:
</p>

<blockquote>
-1- <del><i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins><i>Remarks:</i> If an exception is thrown by <tt>push_back()</tt>
or <tt>emplace_back()</tt> function, that function has no effect unless the
exception is thrown by the move constructor of <tt>T</tt>.</ins>
</blockquote>






<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a 
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>&#xB1HUGE_VALF</code>,
<code>&#xB1HUGE_VAL</code> and <code>&#xB1HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this
isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Some concern that this is changing the specification for an existing C++03 function, but it was pointed out that this was underspecified as resolved by issue 23.  This is clean-up for that issue in turn.

Some concern that we are trying to solve the same problem in both clause 22 and 27.

Bill: There's a change here as to whether val is stored to in an error case.

Pablo: Don't think this changes whether val is stored to or not, but changes the value that is stored.

Bill: Remembers having skirmishes with customers and testers as to whether val is stored to, and the resolution was not to store in error cases.

Howard: Believes since C++03 we made a change to always store in overflow.

Everyone took some time to review the issue.

Pablo: C++98 definitely did not store any value during an error condition.

Dietmar: Depends on the question of what is considered an error, and whether overflow is an error or not, which was the crux of LWG 23.

Pablo: Yes, but given the "zero, if the conversion function fails to convert the entire field", we are requiring every error condition to store.

Bill: When did this happen?

Alisdair: One of the last two or three meetings.

Dietmar: To store a value in case of failure is a very bad idea.

Move to Open, needs more study.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
 Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at both the clause 23 requirements tables and the constructor description of each unodered container to be sure.

Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.

Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.

Move to Open.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2010-11-08</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of 208<a href="lwg-defects.html#208">208</a> (including further updates by 278<a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue 208<a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote>
An iterator is valid if it is dereferenceable or past-the-end.
</blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was
incomplete, because by restricting feasible expressions of singular
iterators to
destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course
it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.9.9 [specialized.algorithms]/1 says:
</p>

<blockquote>
In all of the following algorithms, the formal template parameter
<tt>ForwardIterator</tt>
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is
required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>



<p><b>Proposed resolution:</b></p>
Consider to await the paper.





<hr>
<h3><a name="1214"></a>1214. Insufficient/inconsistent key immutability requirements for  associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-20 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Scott Meyers' mentions on a recent posting on <a
href="http://groups.google.de/group/comp.std.c++/msg/6f9160fc428bcbea">c.s.c++</a>
some arguments that point to an incomplete resolution
of 103<a href="lwg-defects.html#103">103</a> and to an inconsistency of requirements on keys in ordered and
unordered associative
containers:
</p>

<blockquote>
<p>
1) 103<a href="lwg-defects.html#103">103</a> introduced the term immutable without defining it in a unique manner in
23.2.4 [associative.reqmts]/5:
</p>

<blockquote>
[..] Keys in an associative container are immutable.
</blockquote>

<p>
According to conventional dictionaries immutable is an unconditional way of
saying that something cannot be changed. So without any further explicit
allowance a user <em>always</em> runs into undefined behavior if (s)he attempts
to modify such a key. IMO this was not the intend of the committee to resolve
103<a href="lwg-defects.html#103">103</a> in that way because the comments suggest an interpretation that
should give any user the freedom to modify the key in an <em>explicit</em> way
<em>provided</em> it would not affect the sort order in that container.
</p>

<p>
2) Another observation was that surprisingly no similar 'safety guards'
exists against unintentional key changes for the unordered associative
containers, specifically there is no such requirement as in
23.2.4 [associative.reqmts]/6 that "both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
iterators". But the need for such protection against unintentional
changes as well as the constraints in which manner any explicit
changes may be performed are both missing and necessary, because
such changes could potentially change the <em>equivalence</em> of keys that
is measured by the <tt>hasher</tt> and <tt>key_equal</tt>.
</p>

<p>
I suggest to fix the unconditional wording involved with "immutable keys"
by at least adding a hint for the reader that users <em>may</em> perform such
changes in an explicit manner <em>and</em> to perform similar wording changes
as 103<a href="lwg-defects.html#103">103</a> did for the ordered associative containers also for the unordered
containers.
</p>
</blockquote>

<p><i>[
2010-03-27 Daniel provides wording.
]</i></p>


<blockquote>
This update attempts to provide normative wording that harmonizes the key and
function object constraints of associative and unordered containers.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 23.2.4 [associative.reqmts]/2 as indicated: <i>[This ensures that
associative containers make better clear what this "arbitrary" type is, as the
unordered containers do in 23.2.5 [unord.req]/3]</i>
</p>

<blockquote>
2 Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that induces a strict weak ordering (25.4) on elements
of <tt>Key</tt>. In addition, <tt>map</tt> and <tt>multimap</tt> associate an
arbitrary <ins><em>mapped type</em></ins><del>type</del> <tt>T</tt> with the
<tt>Key</tt>. The object of type <tt>Compare</tt> is called the <em>comparison
object</em> of a container.
</blockquote>
</li>

<li>
<p>
Change 23.2.4 [associative.reqmts]/5 as indicated: <i>[This removes the
too strong requirement that keys must not be changed at all and brings this line
in sync with 23.2.5 [unord.req]/7. We take care about the real
constraints by the remaining suggested changes. The rationale provided by LWG
103<a href="lwg-defects.html#103">103</a> didn't really argue why that addition is necessary, and I
believe the remaining additions make it clear that any user changes have strong
restrictions]</i>:
</p>

<blockquote>
5 For <tt>set</tt> and <tt>multiset</tt> the value type is the same as the key
type. For <tt>map</tt> and <tt>multimap</tt> it is equal to <tt>pair&lt;const
Key, T&gt;</tt>. <del>Keys in an associative container are immutable.</del>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/3+4 as indicated: <i>[The current sentence of
p.4 has doesn't say something really new and this whole subclause misses to
define the concepts of the container-specific hasher <i>object</i> and predicate
<i>object</i>. We introduce the term <em>key equality predicate</em> which is
already used in the requirements table. This change does not really correct part
of this issue, but is recommended to better clarify the nomenclature and the
difference between the function objects and the function object <em>types</em>,
which is important, because both can potentially be stateful.]</i>
</p>

<blockquote>
<p>
3 Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object type <tt>Hash</tt> that meets the <tt>Hash</tt> requirements
(20.2.4) and acts as a hash function for argument values of type <tt>Key</tt>,
and by a binary predicate <tt>Pred</tt> that induces an equivalence relation on
values of type <tt>Key</tt>. Additionally, <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> associate an arbitrary <em>mapped type</em>
<tt>T</tt> with the <tt>Key</tt>.
</p>

<p>
4 <ins>The container's object of type <tt>Hash</tt> - denoted by
<tt>hash</tt> - is called the <em>hash function</em> of the container.
The container's object of type <tt>Pred</tt> - denoted by
<tt>pred</tt> - is called the <em>key equality predicate</em> of the
container.</ins><del>A hash function is a function object that takes a single
argument of type <tt>Key</tt> and returns a value of type
<tt>std::size_t</tt></del>.
</p>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/5 as indicated: <i>[This adds a similar
safe-guard as the last sentence of 23.2.4 [associative.reqmts]/3]</i>
</p>

<blockquote>
5 Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered
equivalent if the container's <ins>key equality
predicate</ins><del><tt>key_equal</tt> function object</del> returns
<tt>true</tt> when passed those values. If <tt>k1</tt> and <tt>k2</tt> are
equivalent, the <ins>container's</ins> hash function shall return the same value
for both. [<i>Note:</i> thus, when an unordered associative container is
instantiated with a non-default <tt>Pred</tt> parameter it usually needs a
non-default <tt>Hash</tt> parameter as well. &mdash; <i>end note</i>] <ins>For
any two keys <tt>k1</tt> and <tt>k2</tt> in the same container, calling
<tt>pred(k1, k2)</tt> shall always return the same value. For any key <tt>k</tt>
in a container, calling <tt>hash(k)</tt> shall always return the same
value.</ins>
</blockquote>
</li>

<li>
<p>
After 23.2.5 [unord.req]/7 add the following new paragraph: <i>[This
ensures the same level of compile-time protection that we already require for
associative containers. It is necessary for similar reasons, because any change
in the stored key which would change it's equality relation to others or would
change it's hash value such that it would no longer fall in the same bucket,
would break the container invariants]</i>
</p>

<blockquote>
<p>
7 For <tt>unordered_set</tt> and <tt>unordered_multiset</tt> the value type is
the same as the key type. For <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> it is <tt>std::pair&lt;const Key, T&gt;</tt>.
</p>
<p>
<ins>For unordered containers where the value type is the same as the key type,
both <tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It is
unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type. [<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have
identical semantics in this case, and <tt>iterator</tt> is convertible to
<tt>const_iterator</tt>. Users can avoid violating the One Definition Rule by
always using <tt>const_iterator</tt> in their function parameter lists. &mdash;
<i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1215"></a>1215. <tt>list::merge</tt> with unequal allocators</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-09-24 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#list.ops">active issues</a> in [list.ops].</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Bellevue (I think), we passed
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>,
which, among other things, specifies that the behavior of
<tt>list::splice</tt> is undefined if the allocators of the two lists
being spliced do not compare equal. The same rationale should apply to
<tt>list::merge</tt>. The intent of <tt>list::merge</tt> (AFAIK) is to
move nodes from one sorted <tt>list</tt> into another sorted
<tt>list</tt> without copying the elements. This is possible only if the
allocators compare equal.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Relative to the August 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>,
change 23.3.4.4 [list.ops],
paragraphs 22-25 as follows:
</p>

<blockquote>
<pre>
void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>
<i>Requires</i>: both the list and the argument list shall be sorted
according to operator&lt; or comp.
</p>
<p>
<i>Effects</i>: If <tt>(&amp;x == this)</tt> does nothing; otherwise, merges the
two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(),
x.end())</tt>. The result is a range in which the elements will be
sorted in non-decreasing order according to the ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt>, in the range other than the
<tt>first</tt>, the condition <tt>comp(*i, *(i - 1)<ins>)</ins></tt> will be
<tt>false</tt>.
</p>
<p>
<i>Remarks</i>: Stable. If <tt>(&amp;x != this)</tt> the range <tt>[x.begin(), x.end())</tt> is
empty after the merge. <ins>No elements are copied by this operation.
The behavior is undefined if <tt>this-&gt;get_allocator() !=
x.get_allocator()</tt>.</ins>
</p>
<p>
<i>Complexity</i>: At most <tt>size() + x.size() - 1</tt> applications of <tt>comp</tt>
if <tt>(&amp;x != this)</tt>; otherwise, no applications of <tt>comp</tt> are performed. If an
exception is thrown other than by a comparison there are no effects.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1252"></a>1252. <tt>wbuffer_convert::state_type</tt> inconsistency</h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Bo Persson  <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopisis for <tt>wbuffer_convert</tt> 22.3.3.2.3 [conversions.buffer]/2 contains
</p>

<blockquote><pre>
typedef typename Tr::state_type   state_type; 
</pre></blockquote>

<p>
making <tt>state_type</tt> a synonym for (possibly) some
<tt>char_traits&lt;x&gt;::state_type</tt>. 
</p>

<p>
However, in paragraph 9 of the same section, we have 
</p>

<blockquote><pre>
typedef typename Codecvt::state_type state_type;
</pre>

<blockquote>
The type shall be a synonym for <tt>Codecvt::state_type</tt>.
</blockquote>
</blockquote>

<p>
From what I can see, it might be hard to implement
<tt>wbuffer_convert</tt> if the types were not both
<tt>std::mbstate_t</tt>, but I cannot find a requirement that they must
be the same type.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1253"></a>1253. invalidation of iterators and <tt>emplace</tt> vs. <tt>insert</tt> inconsistence in assoc. containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Boris Du&scaron;ek <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest published draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
section 23.2.4 [associative.reqmts], paragraph 8, it is specifies
that that <tt>insert</tt> does not invalidate any iterators. As per
23.2.1 [container.requirements.general], paragraph 12, this holds
true not only for <tt>insert</tt>, but <tt>emplace</tt> as well. This
gives the <tt>insert</tt> member a special treatment w.r.t.
<tt>emplace</tt> member in 23.2.4 [associative.reqmts], par. 8,
since both modify the container. For the sake of consistency, in 23.2.4 [associative.reqmts], par. 8: either reference to
<tt>insert</tt> should be removed (i.e. count on 23.2.1 [container.requirements.general], par. 12), or reference to
<tt>emplace</tt> be added (i.e. mention all members of assoc. containers
that modify it).
</p>

<p><i>[
2009-11-18 Chris provided wording.
]</i></p>


<blockquote>
This suggested wording covers both the issue discussed, and a number of other
identical issues (namely insert being discussed without emplace). I'm happy to
go back and split and introduce a new issue if appropriate, but I think the
changes are fairly mechanical and obvious.
</blockquote>

<p><i>[
2010-01-23 Daniel Kr&uuml;gler and J. Daniel Garc&iacute;a updated wording to
make the use of <tt>hint</tt> consistent with <tt>insert</tt>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Modify bullet 1 of 23.2.1 [container.requirements.general], p10:
</p>

<p>
10 Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4)
all container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
if an exception is thrown by an <tt>insert()</tt> <ins>or
<tt>emplace()</tt></ins> function while inserting a single element, that
function has no effects.
</li>
<li>...</li>
</ul>

<p>
Modify 23.2.4 [associative.reqmts], p4:
</p>

<blockquote>
4 An associative container supports <i>unique keys</i> if it may contain at most
one element for each key. Otherwise, it supports <i>equivalent keys</i>. The
<tt>set</tt> and <tt>map</tt> classes support unique keys; the <tt>multiset</tt>
and <tt>multimap</tt> classes support equivalent keys. For <tt>multiset</tt> and
<tt>multimap</tt>, <tt>insert</tt><ins>, <tt>emplace</tt>,</ins> and
<tt>erase</tt> preserve the relative ordering of equivalent elements.
</blockquote>

<p>
Modify Table 96 &mdash; Associative container requirements in 23.2.4 [associative.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 96 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4"><center>...</center></td>
</tr>

<tr>
<td><tt>a_eq.emplace(args)</tt></td>
<td><tt>iterator</tt></td>
<td>inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> and returns the iterator pointing to
the newly inserted element. <ins>If a range containing elements equivalent to
<tt>t</tt> exists in <tt>a_eq</tt>, <tt>t</tt> is inserted at the end of that
range.</ins></td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a.emplace_hint(p, args)</tt></td>
<td><tt>iterator</tt></td>
<td>equivalent to <tt>a.emplace(std::forward&lt;Args&gt;(args)...)</tt>. Return
value is an iterator pointing to the element with the key equivalent to the
newly inserted element. <del>The <tt>const_iterator p</tt> is a hint pointing to
where the search should start.</del> <ins>The element is inserted as close as
possible to the position just prior to <tt>p</tt>.</ins> <del>Implementations
are permitted to ignore the hint.</del></td>
<td>logarithmic in general, but amortized constant if the element is inserted
right <del>after</del> <ins>before</ins> <tt>p</tt></td>
</tr>

<tr>
<td colspan="4"><center>...</center></td>
</tr>

</table>
</blockquote>

<p>
Modify 23.2.4 [associative.reqmts], p8:
</p>

<blockquote>
8 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators and references to the container, and the
<tt>erase</tt> members shall invalidate only iterators and references to the
erased elements.
</blockquote>

<p>
Modify 23.2.4.1 [associative.reqmts.except], p2:
</p>

<blockquote>
2 For associative containers, if an exception is thrown by any operation from
within an <tt>insert()</tt> <ins> or <tt>emplace()</tt></ins> function inserting
a single element, the <del><tt>insert()</tt> function</del> <ins>insertion</ins>
has no effect.
</blockquote>

<p>
Modify 23.2.5 [unord.req], p6, p12 and p13:
</p>

<blockquote>
<p>
6 An unordered associative container supports <i>unique keys</i> if it may
contain at most one element for each key. Otherwise, it supports <i>equivalent
keys</i>. <tt>unordered_set</tt> and <tt>unordered_map</tt> support unique keys.
<tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> support equivalent
keys. In containers that support equivalent keys, elements with equivalent keys
are adjacent to each other. For <tt>unordered_multiset</tt> and
<tt>unordered_multimap</tt>, <tt>insert</tt><ins>, <tt>emplace</tt>,</ins> and
<tt>erase</tt> preserve the relative ordering of equivalent elements.
</p>

<p>
12 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of references to container elements, but may invalidate all
iterators to the container. The erase members shall invalidate only iterators
and references to the erased elements.
</p>

<p>
13 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators if <tt>(N+n) &lt; z * B</tt>, where <tt>N</tt> is the
number of elements in the container prior to the insert operation, <tt>n</tt> is
the number of elements inserted, <tt>B</tt> is the container's bucket count, and
<tt>z</tt> is the container's maximum load factor.
</p>
</blockquote>

<p>
Modify 23.2.5.1 [unord.req.except], p2:
</p>

<blockquote>
2 For unordered associative containers, if an exception is thrown by any
operation other than the container's hash function from within an
<tt>insert()</tt> <ins>or <tt>emplace()</tt></ins> function inserting a single
element, the <del><tt>insert()</tt></del> <ins>insertion</ins>
<del>function</del> has no effect.
</blockquote>





<hr>
<h3><a name="1268"></a>1268. The Mutex requirements in 30.4.1 and 30.4.2 are wrong</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-17 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex">active issues</a> in [thread.mutex].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>Mutex</tt> requirements in 30.4.1 [thread.mutex.requirements] and
30.4.2 [thread.timedmutex.requirements] confuse the requirements on the
behaviour of <tt>std::mutex</tt> et al with the requirements on
<tt>Lockable</tt> types for use with <tt>std::unique_lock</tt>,
<tt>std::lock_guard</tt> and <tt>std::condition_variable_any</tt>.
</p>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
Concepts of threads chapter and issue presentation are: Lockable &lt; Mutex &lt;
TimedMutex and Lockable &lt; TimedLockable &lt; TimedMutex.
</p>
<p>
Typo in failed deletion of Mutex in 30.4.4 p4 edits.
</p>
<p>
Lockable requirements are too weak for condition_variable_any, but the Mutex
requirements are too strong.
</p>
<p>
Need subset of Lockable requirements for condition_variable_any that does not
include try_lock. E.g. CvLockable &lt; Lockable.
</p>
<p>
Text needs updating to recent draft changes.
</p>
<p>
Needs to specify exception behavior in Lockable.
</p>
<p>
The current standard is fine for what it says, but it places requirements that
are too strong on authors of mutexes and locks.
</p>
<p>
Move to open status. Suggest Anthony look at condition_variable_any
requirements. Suggest Anthony refine requirements/concepts categories.
</p>
<p>
Related to 964<a href="lwg-active.html#964">964</a> and 966<a href="lwg-active.html#966">966</a>
</p>
</blockquote>

<p><i>[
2010-03-28 Daniel synced with N3092.
]</i></p>


<p><i>[
2010-10-25 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Add a new section to 30.2 [thread.req] after 30.2.4 [thread.req.timing] as follows:
</p>

<blockquote>
<p>
30.2.5 Requirements for Lockable types
</p>

<p>
The standard library templates <tt>unique_lock</tt> (30.4.3.2 [thread.lock.unique]), <tt>lock_guard</tt> (30.4.3.1 [thread.lock.guard]), <tt>lock</tt>, <tt>try_lock</tt> (30.4.4 [thread.lock.algorithm]) and <tt>condition_variable_any</tt> (30.5.2 [thread.condition.condvarany]) all operate on user-supplied
<tt>Lockable</tt> objects. Such an object must support the member functions
specified for either the <tt>Lockable</tt> Requirements or the
<tt>TimedLockable</tt> requirements as appropriate to acquire or release
ownership of a <tt>lock</tt> by a given <tt>thread</tt>. [<i>Note:</i> the
nature of any lock ownership and any synchronization it may entail are not part
of these requirements. &mdash; <i>end note</i>]
</p>

<p>
30.2.5.1  Lockable Requirements
</p>

<p>
In order to qualify as a <tt>Lockable</tt> type, the following expressions must
be supported, with the specified semantics, where <tt>m</tt> denotes a value of
type <tt>L</tt> that supports the <tt>Lockable</tt>:
</p>

<p>
The expression <tt>m.lock()</tt> shall be well-formed and have the following
semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Block until a lock can be acquired for the current thread.</dd>
  <dt>Return type:</dt><dd><tt>void</tt></dd>
</dl>

<p>
The expression <tt>m.try_lock()</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current thread without blocking.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>

<p>
The expression <tt>m.unlock()</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Release a lock on <tt>m</tt> held by the current thread.</dd>
  <dt>Return type:</dt><dd><tt> void</tt></dd>
  <dt>Throws:</dt><dd> Nothing if the current thread holds a lock on <tt>m</tt>.</dd>
</dl>

<p>
30.2.5.2 <tt>TimedLockable</tt> Requirements
</p>

<p>
For a type to qualify as <tt>TimedLockable</tt> it must meet the
<tt>Lockable</tt> requirements, and additionally the following
expressions must be well-formed, with the specified semantics,
where <tt>m</tt> is an instance of a type <tt>TL</tt> that supports
the <tt>TimedLockable</tt> requirements, <tt>rel_time</tt> denotes
instantiation of <tt>duration</tt> (20.11.3 [time.duration]) and <tt>abs_time</tt>
denotes an instantiation of <tt>time_point</tt> (20.11.4 [time.point])

</p>

<p>
The expression <tt>m.try_lock_for(rel_time)</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current
  thread within the specified time period.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>

<p>
The expression <tt>m.try_lock_until(abs_time)</tt> shall be well-formed and have the
following semantics:
</p>

<dl>
  <dt>Effects:</dt><dd>Attempt to acquire a lock for the current
  thread before the specified point in time.</dd>
  <dt>Return type:</dt><dd><tt>bool</tt></dd>
  <dt>Returns:</dt><dd><tt>true</tt> if the lock was
  acquired, <tt>false</tt> otherwise.</dd>
</dl>
</blockquote>

<p>
Replace 30.4.1 [thread.mutex.requirements] paragraph 2 with the
following:
</p>

<blockquote>
2 This section describes requirements on <del>template argument types
used to instantiate templates defined in</del> <ins>the mutex types
supplied by</ins> the C++ standard library. <del>The template
definitions in the C++ standard library refer</del> These types shall
conform to the named <tt>Mutex</tt> requirements whose details are set
out below.  In this description, <tt>m</tt> is an object
of <del>a <tt>Mutex</tt> type</del>
<ins>one of the standard library mutex types <tt>std::mutex</tt>,
<tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt> or
<tt>std::recursive_timed_mutex</tt>.</ins>.
</blockquote>

<p>
Add the following paragraph after 30.4.1 [thread.mutex.requirements]
paragraph 2:
</p>

<blockquote><ins>
A <tt>Mutex</tt> type shall conform to the <tt>Lockable</tt>
requirements (30.2.5.1).
</ins></blockquote>

<p>
Replace 30.4.2 [thread.timedmutex.requirements] paragraph 1 with the
following:
</p>

<blockquote>
<ins>The C++ standard library <tt>TimedMutex</tt> types <tt>std::timed_mutex</tt>
  and <tt>std::recursive_timed_mutex</tt> </ins>
<del>A <tt>TimedMutex</tt> type</del> shall meet the requirements for
a <tt>Mutex</tt> type. In addition, <del>it</del><ins>they</ins> shall
meet the requirements set out <del>in this Clause 30.4.2</del><ins>below</ins>,
where <tt>rel_time</tt> denotes an instantiation of <tt>duration</tt>
(20.11.3 [time.duration]) and <tt>abs_time</tt> denotes an instantiation
of <tt>time_point</tt> (20.11.4 [time.point]).
</blockquote>

<p>
Add the following paragraph after 30.4.2 [thread.timedmutex.requirements] paragraph 1:
</p>

<blockquote><ins>
A <tt>TimedMutex</tt> type shall conform to the <tt>TimedLockable</tt>
requirements (30.2.5.1).
</ins></blockquote>


<p>
Add the following paragraph following 30.4.3.1 [thread.lock.guard]
paragraph 1:
</p>

<blockquote><ins>
The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> 
requirements
(30.2.5.1).
</ins></blockquote>

<p>
Add the following paragraph following 30.4.3.2 [thread.lock.unique]
paragraph 1:
</p>

<blockquote><ins>
The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> 
requirements
(30.2.5.1). <tt>unique_lock&lt;Mutex&gt;</tt> meets the <tt>Lockable</tt>
requirements. If <tt>Mutex</tt> meets the <tt>TimedLockable</tt> 
requirements
(30.2.5.2) then <tt>unique_lock&lt;Mutex&gt;</tt> also meets the
<tt>TimedLockable</tt> requirements.
</ins></blockquote>

<p>
Replace the use of "mutex" or "mutex object" with "lockable object"
throughout clause 30.4.3 [thread.lock] paragraph 1:
</p>

<blockquote>
1 A lock is an object that holds a reference to
a <del>mutex</del><ins>lockable object</ins> and may unlock
the <del>mutex</del><ins>lockable object</ins> during the lock's
destruction (such as when leaving block scope). A thread of execution
may use a lock to aid in managing <del>mutex</del> ownership <ins>of a
lockable object</ins> in an exception safe manner. A lock is said to
own a <del>mutex</del><ins>lockable object</ins> if it is currently
managing the ownership of that <del>mutex</del><ins>lockable
object</ins> for a thread of execution. A lock does not manage the
lifetime of the <del>mutex</del><ins>lockable object</ins> it
references.  [ Note: Locks are intended to ease the burden of
unlocking the <del>mutex</del><ins>lockable object</ins> under both
normal and exceptional circumstances. &mdash; end note ]
</blockquote>

<p>30.4.3 [thread.lock] paragaph 2:</p>

<blockquote>
2 Some lock constructors take tag types which describe what should be
done with the <del>mutex</del><ins>lockable</ins> object during the
lock's constuction.
</blockquote>

<p>30.4.3.1 [thread.lock.guard] paragaph 1:</p>

<blockquote>
1 An object of type <tt>lock_guard</tt> controls the ownership of a
  <del>mutex</del><ins>lockable</ins> object within a scope. A
<tt>lock_guard</tt> object maintains ownership of
a <del>mutex</del><ins>lockable</ins> object throughout
the <tt>lock_guard</tt> object's lifetime. The behavior of a program
is undefined if the <del>mutex</del><ins>lockable object</ins>
referenced by <tt>pm</tt> does not exist for the entire lifetime (3.8)
of the <tt>lock_guard</tt> object. <ins><tt>Mutex</tt> shall meet
  the <tt>Lockable</tt> requirements (30.2.5.1).</ins>
</blockquote>

<p>30.4.3.2 [thread.lock.unique] paragaph 1:</p>

<blockquote>
1 An object of type <tt>unique_lock</tt> controls the ownership of
a <del>mutex</del><ins>lockable object</ins> within a
scope. <Del>Mutex</Del> <del>o</del><ins>O</ins>wnership <Ins>of the
lockable object</Ins> may be acquired at construction or after
construction, and may be transferred, after acquisition, to
another <tt>unique_lock</tt> object. Objects of
type <tt>unique_lock</tt> are not copyable but are movable. The
behavior of a program is undefined if the contained
pointer <tt>pm</tt> is not null and the mutex pointed to
by <tt>pm</tt> does not exist for the entire remaining lifetime (3.8)
of the <tt>unique_lock</tt> object. <ins><tt>Mutex</tt> shall meet
the <tt>Lockable</tt> requirements (30.2.5.1).</ins>
</blockquote>


<p>
Add the following to the precondition of <tt>unique_lock(mutex_type&amp;
 m,
const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</tt> in 
30.4.3.2.1 [thread.lock.unique.cons] paragraph 18:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>

<blockquote>
18 <i>Requires:</i> If <tt>mutex_type</tt> is not a recursive mutex 
the
calling thread does not own the mutex. <ins>The supplied <tt>mutex_type</tt>
type shall meet the <tt>TimedLockable</tt> requirements (30.2.5.2).</ins>
</blockquote>
</blockquote>

<p>
Add the following to the precondition of <tt>unique_lock(mutex_type&amp;
 m,
const chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</tt> in 
30.4.3.2.1 [thread.lock.unique.cons]
paragraph 22
</p>

<blockquote>
22  <i>Requires:</i> If <tt>mutex_type</tt> is not a recursive mutex
 the
calling thread does not own the mutex. <ins>The supplied <tt>mutex_type</tt>
type shall meet the <tt>TimedLockable</tt> requirements (30.2.5.2).</ins>
</blockquote>

<p>
Add the following as a precondition of <tt>bool try_lock_until(const
chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</tt> before
30.4.3.2.2 [thread.lock.unique.locking] paragraph 8
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  bool try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote><ins>
<i>Requires:</i> The supplied <tt>mutex_type</tt> type shall meet the
<tt>TimedLockable</tt> requirements (30.2.5.2).
</ins></blockquote>
</blockquote>

<p>
Add the following as a precondition of <tt>bool try_lock_for(const
chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</tt> before 
30.4.3.2.2 [thread.lock.unique.locking] paragraph 12
</p>

<blockquote><pre>template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote><ins>
<i>Requires:</i> The supplied <tt>mutex_type</tt> type shall meet the
<tt>TimedLockable</tt> requirements (30.2.5.2).
</ins></blockquote>
</blockquote>

<p>
Replace 30.4.4 [thread.lock.algorithm] p1 with the following:
</p>

<blockquote><pre>template &lt;class L1, class L2, class... L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
1 <i>Requires:</i> Each template parameter type shall meet the
<tt><del>Mutex</del> <ins>Lockable</ins></tt> requirements
<ins>(30.2.5.1).</ins><del>, except that a call to <tt>try_lock()</tt> 
may throw
an exception.</del> [<i>Note:</i> The <tt>unique_lock</tt> class 
template meets
these requirements when suitably instantiated. &mdash; <i>end note</i>]
</blockquote>
</blockquote>

<p>
Replace 30.4.4 [thread.lock.algorithm] p4 with the following:
</p>

<blockquote><pre>template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
4 <i>Requires:</i> Each template parameter type shall meet the
<tt>Mutex<del>Mutex</del> <ins>Lockable</ins></tt>
requirements <ins>(30.2.5.1).</ins><del>, except that a call to
<tt>try_lock()</tt> may throw an exception.</del> [<i>Note:</i> The
<tt>unique_lock</tt> class template meets these requirements when 
suitably
instantiated. &mdash; <i>end note</i>]
</blockquote>
</blockquote>

<p>
Replace 30.5.2 [thread.condition.condvarany] paragraph 1 with:
</p>

<blockquote>
1 A <tt>Lock</tt> type shall meet the <del>requirements for a <tt>Mutex</tt>
type</del> <ins><tt>Lockable</tt> requirements (30.2.5.1)</ins>, except 
that
<tt>try_lock</tt> is not required. [<i>Note:</i> All of the standard 
mutex types
meet this requirement. &mdash; <i>end note</i>]
</blockquote>






<hr>
<h3><a name="1279"></a>1279. forbid <tt>[u|bi]nary_function</tt> specialization</h3>
<p><b>Section:</b> 20.8.3 [base] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-11-30 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A program should not be allowed to add specialization of class templates
<tt>unary_function</tt> and <tt>binary_function</tt>, in force of 17.6.3.2.1 [namespace.std]/1.
If a program were allowed to specialize these templates, the library could no
longer rely on them to provide the intended typedefs or there might be other
undesired interactions.
</p>

<p><i>[
2010-03-27 Daniel adds:
]</i></p>


<blockquote>
Accepting issue 1290<a href="lwg-active.html#1290">1290</a> would resolve this issue as NAD editorial.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a> would resolve this issue as NAD editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change paragraph 20.8.3 [base]/1 as follows:
</p>

<blockquote>
1 The following <del>classes</del> <ins>class templates</ins> are provided to
simplify the typedefs of the argument and result types<del>:</del><ins>. A
program shall not declare specializations of these templates.</ins>
</blockquote>





<hr>
<h3><a name="1289"></a>1289. Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility">active issues</a> in [utility].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 20.2.5 [allocator.requirements], Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
20.9.11.2.10 [util.smartptr.shared.cast], and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 14.8.1 [temp.arg.explicit] p.8 "Explicit template
argument specification":
</p>

<blockquote>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add to section 20.3 [utility] Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 20.3 [utility] Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 20.2.5 [allocator.requirements] Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1290"></a>1290. Don't require <tt>[u|bi]nary_function</tt> inheritance</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#function.objects">active issues</a> in [function.objects].</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is a follow-up of the discussion on issue 870<a href="lwg-defects.html#870">870</a> during
the 2009 Santa Cruz meeting.
</p>

<p>
The class templates <tt>unary_function</tt> and <tt>binary_function</tt> are
actually very simple typedef providers,
</p>

<blockquote><pre>
namespace std {

template &lt;class Arg, class Result&gt;
struct unary_function {
 typedef Arg argument_type;
 typedef Result result_type;
};

template &lt;class Arg1, class Arg2, class Result&gt;
struct binary_function {
 typedef Arg1 first_argument_type;
 typedef Arg2 second_argument_type;
 typedef Result result_type;
};

}
</pre></blockquote>

<p>
which <i>may</i> be used as base classes (similarly to the iterator template),
but were originally <i>not</i> intended as a customization point. The SGI
documentation introduced the concept <a
href="http://www.sgi.com/tech/stl/AdaptableUnaryFunction.html">Adaptable Unary
Function</a> as function objects "with nested typedefs that define its argument
type and result type" and a similar definition for <a
href="http://www.sgi.com/tech/stl/AdaptableBinaryFunction.html">Adaptable Binary
Function</a> related to <tt>binary_function</tt>. But as of TR1 a protocol was
introduced that relies on inheritance relations based on these types. 20.8.4 [refwrap]/3 b. 3 requires that a specialization of
<tt>reference_wrapper&lt;T&gt;</tt> shall derive from <tt>unary_function</tt>,
if type <tt>T</tt> is "a class type that is derived from
<tt>std::unary_function&lt;T1, R&gt;</tt>" and a similar inheritance-based rule
for <tt>binary_function</tt> exists as well.
</p>

<p>
As another disadvantage it has been pointed out in the TR1 issue list, <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf">N1837</a>
(see section 10.39), that the requirements of <tt>mem_fn</tt> 20.8.13 [func.memfn]/2+3 to <em>derive</em> from
<tt>std::unary_function/std::binary_function</tt> under circumstances, where the
provision of corresponding typedefs would be sufficient, unnecessarily prevent
implementations that take advantage of empty-base-class- optimizations.
</p>

<p>
Both requirements should be relaxed in the sense that the
<tt>reference_wrapper</tt> should provide typedef's <tt>argument_type</tt>,
<tt>first_argument_type</tt>, and <tt>second_argument_type</tt> based on similar
rules as the <i>weak result type</i> rule (20.8.2 [func.require]/3) does
specify the presence of <tt>result_type</tt> member types.
</p>

<p>
For a related issue see also 1279<a href="lwg-active.html#1279">1279</a>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a> would resolve this issue as NAD editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
The here proposed resolution is an attempt to realize the common denominator of
the reflector threads c++std-lib-26011, c++std-lib-26095, and c++std-lib-26124.
]</i></p>


<ol>
<li>
<p>
Change 20.8.3 [base]/1 as indicated: <i>[The intend is to provide an
alternative fix for issue 1279<a href="lwg-active.html#1279">1279</a> and some editorial harmonization
with existing wording in the library, like 24.4.2 [iterator.basic]/1]</i>
</p>

<blockquote>
<p>
1 The following class<ins> templat</ins>es are provided to simplify the
<ins>definition of</ins> typedefs of the argument and result types <ins>for
function objects. The behavior of a program that adds specializations for any of
these templates is undefined.</ins><del>:</del>
</p>

<blockquote><pre>
namespace std {
 template &lt;class Arg, class Result&gt;
 struct unary_function {
   typedef Arg argument_type;
   typedef Result result_type;
 };
}

namespace std {
 template &lt;class Arg1, class Arg2, class Result&gt;
 struct binary_function {
   typedef Arg1 first_argument_type;
   typedef Arg2 second_argument_type;
   typedef Result result_type;
 };
}
</pre></blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap], class template <tt>reference_wrapper</tt>
synopsis as indicated: <i>[The intent is to remove the requirement that
<tt>reference_wrapper</tt> derives from <tt>unary_function</tt> or
<tt>binary_function</tt> if the situation requires the definition of the
typedefs <tt>argument_type</tt>, <tt>first_argument_type</tt>, or
<tt>second_argument_type</tt>. This change is suggested, because the new way of
definition uses the same strategy as the <em>weak result type</em> specification
applied to argument types, which provides the following advantages: It creates
less potential conflicts between <tt>[u|bi]nary_function</tt> bases and typedefs
in a function object and it ensures that user-defined function objects which
provide typedefs but no such bases are handled as first class citizens.]</i>
</p>

<blockquote><pre>
namespace std {
 template &lt;class T&gt; class reference_wrapper
   <del>: public unary_function&lt;T1, R&gt; // <i>see below</i></del>
   <del>: public binary_function&lt;T1, T2, R&gt; // <i>see below</i></del>
 {
 public :
   // types
   typedef T type;
   typedef <i>see below</i> result_type; // not always defined
   <ins>typedef <i>see below</i> argument_type; // not always defined</ins>
   <ins>typedef <i>see below</i> first_argument_type; // not always defined</ins>
   <ins>typedef <i>see below</i> second_argument_type; // not always defined</ins>

   // construct/copy/destroy
   ...
 };
</pre></blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/3 as indicated: <i>[The intent is to remove the
requirement that <tt>reference_wrapper</tt> derives from <tt>unary_function</tt>
if the situation requires the definition of the typedef <tt>argument_type</tt>
and <tt>result_type</tt>. Note that this clause does concentrate on
<tt>argument_type</tt> alone, because the <tt>result_type</tt> is already ruled
by p. 2 via the <em>weak result type</em> specification. The new way of
specifying <tt>argument_type</tt> is equivalent to the <em>weak result type</em>
specification]</i>
</p>

<blockquote>
<p>
3 The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall <del>be
derived from <tt>std::unary_function&lt;T1, R&gt;</tt></del><ins>define a nested
type named <tt>argument_type</tt> as a synonym for <tt>T1</tt></ins> only if the
type <tt>T</tt> is any of the following:
</p>
<ul>
<li>a function type or a pointer to function type taking one argument
of type <tt>T1</tt><del> and returning <tt>R</tt></del>
</li>
<li>a pointer to member function <tt>R T0::f</tt> <em>cv</em> (where
<em>cv</em> represents the member function's cv-qualifiers);
the type <tt>T1</tt> is <em>cv</em> <tt>T0*</tt>
</li>
<li>a class type <del>that is derived from
<tt>std::unary_function&lt;T1, R&gt;</tt></del><ins>with a member type
<tt>argument_type</tt>;
	the type <tt>T1</tt> is <tt>T::argument_type</tt></ins>
</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/4 as indicated: <i>[The intent is to remove the
requirement that <tt>reference_wrapper</tt> derives from
<tt>binary_function</tt> if the situation requires the definition of the typedef
<tt>first_argument_type</tt>, <tt>second_argument_type</tt>, and
<tt>result_type</tt>. Note that this clause does concentrate on
<tt>first_argument_type</tt> and <tt>second_argument_type</tt> alone, because
the <tt>result_type</tt> is already ruled by p. 2 via the <em>weak result
type</em> specification. The new way of specifying <tt>first_argument_type</tt>
and <tt>second_argument_type</tt> is equivalent to the <em>weak result type</em>
specification]</i>
</p>

<blockquote>
<p>
The template instantiation <tt>reference_wrapper&lt;T&gt;</tt> shall <del>be
derived from <tt>std::binary_function&lt;T1, T2, R&gt;</tt></del><ins>define two
nested types named <tt>first_argument_type</tt> and
<tt>second_argument_type</tt> as a synonym for <tt>T1</tt> and <tt>T2</tt>,
respectively,</ins> only if the type <tt>T</tt> is any of the following:
</p>
<ul>
<li>a function type or a pointer to function type taking two arguments
of types <tt>T1</tt> and <tt>T2</tt><del> and returning
<tt>R</tt></del>
</li>
<li>a pointer to member function <tt>R T0::f(T2)</tt> <em>cv</em>
(where <em>cv</em> represents the member function's cv-qualifiers);
	the type <tt>T1</tt> is <em>cv</em> <tt>T0*</tt>
</li>
<li>a class type <del>that is derived from
<tt>std::binary_function&lt;T1, T2, R&gt;</tt></del><ins>with member
types <tt>first_argument_type</tt>
	and <tt>second_argument_type</tt>; the type <tt>T1</tt> is
<tt>T::first_argument_type</tt> and the type <tt>T2</tt> is
	<tt>T::second_argument_type</tt></ins>
</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.8.13 [func.memfn]/2+3 as indicated: <i>[The intent is to remove
the requirement that mem_fn's return type has to derive
from <tt>[u|bi]nary_function</tt>. The reason for suggesting the
change here is to better support empty-base-class optimization
choices as has been pointed out in <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf">N1837</a>]</i>
</p>

<blockquote>
<p>
2 The simple call wrapper shall <del>be derived from
<tt>std::unary_function&lt;<em>cv</em> T*, <i>Ret</i>&gt;</tt></del><ins>define
two nested types named <tt>argument_type</tt> and <tt>result_type</tt> as a
synonym for <tt><em>cv</em> T*</tt> and <tt><i>Ret</i></tt>, respectively,</ins>
when <tt>pm</tt> is a pointer to member function with cv-qualifier <em>cv</em>
and taking no arguments, where <tt><i>Ret</i></tt> is <tt>pm</tt>'s return type.
</p>
<p>
3 The simple call wrapper shall <del>be derived from
<tt>std::binary_function&lt;<em>cv</em> T*, T1,
<i>Ret</i>&gt;</tt></del><ins>define three nested types named
<tt>first_argument_type</tt>, <tt>second_argument_type</tt>, and
<tt>result_type</tt> as a synonym for <tt><em>cv</em> T*</tt>, <tt>T1</tt>, and
<tt><i>Ret</i></tt>, respectively,</ins> when <tt>pm</tt> is a pointer to member
function with cv-qualifier <em>cv</em> and taking one argument of type
<tt>T1</tt>, where <tt><i>Ret</i></tt> is <tt>pm</tt>'s return type.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1297"></a>1297. <tt>unique_ptr</tt>'s relational operator functions should induce a total order</h3>
<p><b>Section:</b> 20.9.10.4 [unique.ptr.special] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-12-23 <b>Last modified:</b> 2010-11-06</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The comparison functions of <tt>unique_ptr</tt> currently directly delegate to
the underlying comparison functions of <tt>unique_ptr&lt;T, D&gt;::pointer</tt>.
This is disadvantageous, because this would not guarantee to induce a total
ordering for native pointers and it is hard to define a total order for mixed
types anyway.
</p>
<p>
The currently suggested resolution for <tt>shared_ptr</tt> comparison as of
1262<a href="lwg-defects.html#1262">1262</a> uses a normalization strategy: They perform the comparison on
the <em>composite pointer type</em> (5.9 [expr.rel]). This is not
exactly possible for <tt>unique_ptr</tt> in the presence of user-defined
pointer-like types but the existing definition of <tt>std::duration</tt>
comparison as of 20.11.3.6 [time.duration.comparisons] via
<tt>common_type</tt> of both argument types demonstrates a solution of this
problem. The approach can be seen as the general way to define a <em>composite
pointer type</em> and this is the approach which is used for here suggested
wording change.
</p>
<p>
For consistency reasons I would have preferred the same normalization strategy
for <tt>==</tt> and <tt>!=</tt>, but Howard convinced me not to do so (now).
</p>

<p><i>[
2010-11-03 Daniel comments and adjustes the currently proposed wording changes:
]</i></p>


<p>
Issue 1401<a href="lwg-active.html#1401">1401</a> is remotely related. <a href="#1401_extra_bullet">Bullet A</a> of its proposed resolution 
provides an alternative solution for issue discussed here and addresses NB comment GB-99.
Additionally I updated the below suggested wording in regard to the following:
It is an unncessary requirement that the below defined effective composite pointer-like
type <tt>CT</tt> satisfies the <tt>LessThanComparable</tt> requirements. All what is 
needed is, that the function object type <tt>less&lt;CT&gt;</tt> induces a strict
weak ordering on the pointer values.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 20.9.10.4 [unique.ptr.special]/4-7 as indicated: <i>[The implicit
requirements and remarks imposed on the last three operators are the same as for
the first one due to the normative "equivalent to" usage within a Requires
element, see 17.5.1.4 [structure.specifications]/4. The effects of this
change are that all real pointers wrapped in a <tt>unique_ptr</tt> will order
like <tt>shared_ptr</tt> does.]</i>
</p>

<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>? <i>Requires:</i> Let <tt>CT</tt> be <tt>common_type&lt;unique_ptr&lt;T1,
D1&gt;::pointer, unique_ptr&lt;T2, D2&gt;::pointer&gt;::type</tt>. Then
the specialization <tt>less&lt;CT&gt</tt> shall be a function object type ([function.objects]) 
that induces a strict weak ordering ([alg.sorting]) on the pointer values.</ins>
</p>

<p>
4 <i>Returns:</i> <tt><ins>less&lt;CT&gt;()(x.get(), y.get())</ins><del>x.get()
&lt; y.get()</del></tt>.
</p>

<p>
<ins>? <i>Remarks:</i> If <tt>unique_ptr&lt;T1, D1&gt;::pointer</tt> is not
implicitly convertible to <tt>CT</tt> or <tt>unique_ptr&lt;T2,
D2&gt;::pointer</tt> is not implicitly convertible to <tt>CT</tt>, the program
is ill-formed.</ins>
</p>
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
5 <ins><i>Effects:</i> Equivalent to <tt>return !(y &lt; x)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &lt;= y.get()</tt></del>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
6 <ins><i>Effects:</i> Equivalent to <tt>return (y &lt; x)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &gt; y.get()</tt></del>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
7 <ins><i>Effects:</i> Equivalent to <tt>return !(x &lt; y)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &gt;= y.get()</tt></del>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1310"></a>1310. <tt>forward_list splice_after</tt> from lvalues</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-02-05 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We've moved 1133<a href="lwg-defects.html#1133">1133</a> to Tentatively Ready and I'm fine with that.
</p>

<p>
1133<a href="lwg-defects.html#1133">1133</a> adds lvalue-references to the <tt>splice</tt> signatures for <tt>list</tt>.  So now
<tt>list</tt> can <tt>splice</tt> from lvalue and rvalue lists (which was the intent of the
original move papers btw).  During the discussion of this issue it was mentioned
that if we want to give the same treatment to <tt>forward_list</tt>, that should be a
separate issue.
</p>

<p>
This is that separate issue.
</p>

<p>
Consider the following case where you want to splice elements from one place in
a <tt>forward_list</tt> to another.  Currently this must be coded like so:
</p>

<blockquote><pre>
fl.splice_after(to_here, std::move(fl), from1, from2);
</pre></blockquote>

<p>
This looks pretty shocking to me.  I would expect to be able to code instead:
</p>

<blockquote><pre>
fl.splice_after(to_here, fl, from1, from2);
</pre></blockquote>

<p>
but we currently don't allow it.
</p>

<p>
When I say <tt>move(fl)</tt>, I consider that as saying that I don't care about
the value of <tt>fl</tt> any more (until I assign it a new value).  But in the
above example, this simply isn't true.  I do care about the value of <tt>fl</tt>
after the move, and I'm not assigning it a new value.  I'm merely permuting its
current value.
</p>

<p>
I propose adding <tt>forward_list&amp;</tt> overloads to the 3
<tt>splice_after</tt> members.  For consistency's sake (principal of least
surprise) I'm also proposing to overload <tt>merge</tt> this way as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis of 23.3.3 [forwardlist]:
</p>

<blockquote><pre>
template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class forward_list {
public:
  ...
  <ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x);
  <ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
  <ins>void splice_after(const_iterator p, forward_list&amp; x,
                    const_iterator first, const_iterator last);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x,
                    const_iterator first, const_iterator last);
  ...
  <ins>void merge(forward_list&amp; x);</ins>
  void merge(forward_list&amp;&amp; x);
  <ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
  template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
  ...
};
</pre></blockquote>

<p>
Add to the signatures of 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x);
</pre>
<blockquote>
<p>1 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>5 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x,
                const_iterator first, const_iterator last);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x,
                const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>9 ...</p>
</blockquote>

<pre>
<ins>void merge(forward_list&amp; x);</ins>
void merge(forward_list&amp;&amp; x);
<ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>18 ...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1318"></a>1318. N2982 removes previous allocator capabilities</h3>
<p><b>Section:</b> 20.9.4.1 [allocator.traits.types] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2010-02-11 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1375">1375</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-87</b></p>
<p>
<a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>
says that containers should have a nested typedef that defines their
<tt>reference_type</tt> as <tt>value_type&amp;</tt>; the previous
standard deferred to the allocator to define its
<tt>reference_type</tt>, and containers simply passed the allocator's
typedef on. This change is a mistake. Allocators should define both a
<tt>pointer</tt> type and a <tt>reference</tt> type. That's essential
for their original purpose, which was to make different memory models
transparent. If an allocator defines a <tt>pointer</tt> type that isn't
compatible with a normal pointer it also has to define a corresponding
<tt>reference</tt> type. For example (and please forgive a Windows-ism),
if an allocator's pointer is <tt>T __far*</tt>, then it's
<tt>reference</tt> has to be <tt>T __far&amp;</tt>. Otherwise everything
crashes (under the hood, references are pointers and have to have the
same memory access mechanics). Extensions such as this for more general
memory models were explicitly encouraged by C++03, and the allocator's
<tt>pointer</tt> and <tt>reference</tt> typedefs were the hooks for such
extensions. Removing the allocator's <tt>reference</tt> and
<tt>const_reference</tt> typedefs makes those extensions unimplementable
and breaks existing implementations that rely on those hooks.
</p>

<p><i>[
2010-02-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;::reference</tt> is a nested class, and not a typedef.  It
should be removed from the list of containers when this change is made.
</p>

<p>
In general, I am unfcomfortable placing this reference requirement on each
container, as I would prefer to require:
</p>

<blockquote><pre>
is_same&lt;Container::reference, Container::iterator::reference&gt;
</pre></blockquote>

<p>
This distinction is important, if we intend to support proxy iterators.  The
iterator paper in the pre-Pittsburgh mailing
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3046.html">N3046</a>)
does <em>not</em> make this proposal, but organises clause 24 in such a way this
will be much easier to specify.
</p>

<p>
The changes to clause 20 remain important for all the reasons Pete highlights.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Add the following two rows to Table 40, Allocator requirements:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td><ins><tt>X::reference</tt></ins></td>

<td><tt></tt></td>

<td><tt></tt></td>

<td><ins><tt>T&amp;</tt></ins></td>
</tr>

<tr>
<td><ins><tt>X::const_reference</tt></ins></td>

<td><tt></tt></td>

<td><tt></tt></td>

<td><ins><tt>const T&amp;</tt></ins></td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
2. Change the following two rows in Table 40:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td><ins><tt>*p</tt></ins></td>

<td><tt><del>T&amp;</del> <ins>X::reference</ins></tt></td>

<td><tt></tt></td>

<td></td>
</tr>

<tr>
<td><ins><tt>*q</tt></ins></td>

<td><tt><del>const T&amp;</del> <ins>X::const_reference</ins></tt></td>

<td><tt></tt></td>

<td></td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
Add the following typedef declarations to allocator_traits 20.9.4 [allocator.traits]:
</p>

<blockquote><pre>
template &lt;class Alloc&gt; struct allocator_traits {
  ...
  <ins>typedef <i>see below</i> reference;</ins>
  <ins>typedef <i>see below</i> const_reference;</ins>
  ...
</pre></blockquote>
</li>

<li>
<p>
Add the following descriptions to 20.9.4.1 [allocator.traits.types]:
</p>

<blockquote>
<pre>typedef see below reference;</pre>
<blockquote>
<i>Type:</i> <tt>Alloc::reference</tt> if such a type exists; otherwise,
<tt>value_type&amp;</tt>.
</blockquote>

<pre>typedef see below const reference;</pre>
<blockquote>
<i>Type:</i> <tt>Alloc::const_reference</tt> if such a type exists; otherwise,
<tt>const value_type&amp;</tt>.
</blockquote>
</blockquote>
</li>

<li>
<p>
Add the following typdef declarations to scoped_allocator_adaptor 20.10 [allocator.adaptor]:
</p>

<blockquote><pre>
template &lt;class OuterAlloc, class... InnerAllocs&gt;
class scoped_allocator_adaptor : public OuterAlloc {
  ...
  <ins>typedef typename OuterTraits::reference reference;</ins>
  <ins>typedef typename OuterTraits::const_reference const_reference;</ins>
  ...
</pre></blockquote>
</li>

<li>
<p>
Change the nested typedefs reference and
const_reference to:
</p>

<blockquote><pre>
typedef typename allocator_traits&lt;Allocator&gt;::reference reference;
typedef typename allocator_traits&lt;Allocator&gt;::const_reference const_reference;
</pre></blockquote>

<p>
for each of the following class templates:
</p>

<blockquote>
<tt>deque</tt> 23.3.2 [deque]<br/>
<tt>forward_list</tt> 23.3.3 [forwardlist]<br/>
<tt>list</tt> 23.3.4 [list]<br/>
<tt>queue</tt> 23.5.1.1 [queue.defn]<br/>
<tt>priority_queue</tt> 23.5.2 [priority.queue]<br/>
<tt>stack</tt> 23.5.3.1 [stack.defn]<br/>
<tt>vector</tt> 23.4.1 [vector]<br/>
<tt>vector&lt;bool&gt;</tt> 23.4.2 [vector.bool]<br/>
<tt>map</tt> 23.6.1 [map]<br/>
<tt>multimap</tt> 23.6.2 [multimap]<br/>
<tt>set</tt> 23.6.3 [set]<br/>
<tt>multiset</tt> 23.6.4 [multiset]<br/>
<tt>unordered_map</tt> 23.7.1 [unord.map]<br/>
<tt>unordered_multimap</tt> 23.7.2 [unord.multimap]<br/>
<tt>unordered_set</tt> 23.7.3 [unord.set]<br/>
<tt>unordered_multiset</tt> 23.7.4 [unord.multiset]<br/>
<tt>basic_string</tt> 21.4 [basic.string]<br/>
<tt>match_results</tt> 28.10 [re.results]
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1320"></a>1320. Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 24.3 [iterator.synopsis] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (24.3 [iterator.synopsis]), with a note that it is
documented in clause 25 [algorithms].
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 25 [algorithms]</i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1322"></a>1322. Explicit <tt>CopyConstructible</tt> requirements are insufficient</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the acceptance of library defect 822<a href="lwg-defects.html#822">822</a> only
direct-initialization is supported, and not copy-initialization in the
requirement sets <tt>MoveConstructible</tt> and <tt>CopyConstructible</tt>. This
is usually a good thing, if only the library implementation needs to obey these
restrictions, but the Empire strikes back quickly:
</p>

<ol>
<li>
<p>
<em>Affects user-code</em>: <tt>std::exception_ptr</tt> is defined purely via
requirements, among them <tt>CopyConstructible</tt>. A strict reading of the
standard would make implementations conforming where <tt>std::exception_ptr</tt>
has an explicit copy-c'tor and user-code must code defensively. This is a very
unwanted effect for such an important component like
<tt>std::exception_ptr</tt>.
</p>
</li>

<li>
<p>
<em>Wrong re-use</em>: Recently proposed requirement sets
(<tt>NullablePointer</tt> as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3025.html">N3025</a>,
Hash) or cleanup of existing requirement sets (e.g. iterator requirements as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3046.html">N3046</a>)
tend to reuse existing requirement sets, so reusing <tt>CopyConstructible</tt>
is attempting, even in cases, where the intend is to support copy-initialization
as well.
</p>
</li>

<li>
<p>
<em>Inconsistency</em>: The current iterator requirements set Table 102 (output
iterator requirements) and Table 103 (forward iterator requirements) demonstrate
quite clearly a strong divergence of copy-semantics: The specified semantics of
</p>

<blockquote><pre>
X u(a);
X u = a;
</pre></blockquote>

<p>
are underspecified compared to the most recent clarifications of the
<tt>CopyConstructible</tt> requirements, c.f. issue 1309<a href="lwg-defects.html#1309">1309</a> which is
very unsatisfactory. This will become worse for each further issue that involves
the <tt>CopyConstructible</tt> specification (for possible directions see 1173<a href="lwg-closed.html#1173">1173</a>).
</p>
</li>
</ol>

<p>
The suggested resolution is to define two further requirements
<tt>implicit-MoveConstructible</tt> and <tt>implicit-CopyConstructible</tt> (or
any other reasonable name like <tt>MoveConvertible</tt> and
<tt>CopyConvertible</tt>) each with a very succinct but precise meaning solving
all three problems mentioned above.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Add the following new table ?? after Table 34 &mdash; <tt>MoveConstructible</tt>
requirements [moveconstructible]:
</p>

<blockquote>

<table border="1">
<caption><ins>Table ?? &mdash; <tt>Implicit MoveConstructible</tt> requirements
[implicit.moveconstructible] (in addition to
<tt>MoveConstructible</tt>)</ins></caption>

<tr>
<th><ins>Expression</ins></th>
<th><ins>Operational Semantics</ins></th>
</tr>

<tr>
<td><ins><tt>T u = rv;</tt></ins></td>
<td><ins>Equivalent to: <tt>T u(rv);</tt></ins></td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
Add the following new table ?? after Table 35 &mdash; <tt>CopyConstructible</tt>
requirements [copyconstructible]:
</p>

<blockquote>

<table border="1">
<caption><ins>Table ?? &mdash; <tt>Implicit CopyConstructible</tt> requirements
[implicit.copyconstructible] (in addition to
<tt>CopyConstructible</tt>)</ins></caption>

<tr>
<th><ins>Expression</ins></th>
<th><ins>Operational Semantics</ins></th>
</tr>

<tr>
<td><ins><tt>T u = v;</tt></ins></td>
<td><ins>Equivalent to: <tt>T u(v);</tt></ins></td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
Change 20.2.3 [nullablepointer.requirements]/1 as follows:
</p>

<blockquote>
<p>
A <tt>NullablePointer</tt> type is a pointer-like type that supports null
values. A type <tt>P</tt> meets the requirements of <tt>NullablePointer</tt> if:
</p>

<ul>
<li>
<tt>P</tt> satisfies the requirements of <tt>EqualityComparable</tt>,
<tt>DefaultConstructible</tt>, <tt><ins>implicit</ins> CopyConstructible</tt>,
<tt>CopyAssignable</tt>, and <tt>Destructible</tt>,
</li>

<li>[..]</li>
</ul>
</blockquote>
</li>

<li>
<p>
Change 20.2.4 [hash.requirements]/1 as indicated: <i>[explicit
copy-constructible functors could not be provided as arguments
to any algorithm that takes these by value. Also a typo is fixed.]</i>
</p>

<blockquote>
<p>
1 A type <tt>H</tt> meets the <i>Hash</i> requirements if:
</p>
<ul>
<li>
it is a function object type (20.8),
</li>
<li>
it satis<ins>fies</ins><del>ifes</del> the requirements of
<tt><ins>implicit</ins> CopyConstructible</tt> and <tt>Destructible</tt>
(20.2.1),
</li>
<li>
[..]
</li>
</ul>

</blockquote>

</li>

<li>
<p>
Change 20.7.1 [meta.rqmts]/1+2 as indicated:
</p>

<blockquote>
<p>
1 A <i>UnaryTypeTrait</i> describes a property of a type. It shall be a class
template that takes one template type argument and, optionally, additional
arguments that help define the property being described. It shall be
<tt>DefaultConstructible</tt>, <tt><ins>implicit</ins> CopyConstructible</tt>,
[..]
</p>

<p>
2 A <tt>BinaryTypeTrait</tt> describes a relationship between two types. It
shall be a class template that takes two template type arguments and,
optionally, additional arguments that help define the relationship being
described. It shall be <tt>DefaultConstructible</tt>,
<tt><ins>implicit </ins>CopyConstructible</tt>, and [..]
</p>

</blockquote>

</li>

<li>
<p>
Change 20.8.2 [func.require]/4 as indicated: <i>[explicit
copy-constructible functors could not be provided as arguments to any algorithm
that takes these by value]</i>
</p>

<blockquote>
4 Every call wrapper (20.8.1) shall be <tt><ins>implicit</ins>
MoveConstructible</tt>. A simple call wrapper is a call wrapper that is
<tt><ins>implicit</ins> CopyConstructible</tt> and <tt>CopyAssignable</tt> and
whose copy constructor, move constructor, and assignment operator do not throw
exceptions. [..]
</blockquote>
</li>

<li>
<p>
Change 20.8.4 [refwrap]/1 as indicated:
</p>

<blockquote>
1 <tt>reference_wrapper&lt;T&gt;</tt> is a<ins>n <tt>implicit</tt></ins>
<tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> wrapper around a
reference to an object or function of type <tt>T</tt>.
</blockquote>
</li>

<li>
<p>
Change 20.8.10.1.2 [func.bind.bind]/5+9 as indicated:
</p>

<blockquote>
<p>
5 <i>Remarks:</i> The return type shall satisfy the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt>. If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt>, then the
return type shall satisfy the requirements of <tt><ins>implicit</ins>
CopyConstructible</tt>. [<i>Note:</i> this implies that all of <tt>FD</tt> and
<tt>TiD</tt> are <tt>MoveConstructible</tt>. &mdash; <i>end note</i>]
</p>

<p>
[..]
</p>

<p>
9 <i>Remarks:</i> The return type shall satisfy the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt>. If all of <tt>FD</tt> and
<tt>TiD</tt> satisfy the requirements of <tt>CopyConstructible</tt>, then the
return type shall satisfy the requirements of <tt><ins>implicit</ins>
CopyConstructible</tt>. [<i>Note:</i> this implies that all of <tt>FD</tt> and
<tt>TiD</tt> are <tt>MoveConstructible</tt>. &mdash; <i>end note</i>]
</p>
</blockquote>

</li>

<li>
<p>
Change 20.8.10.1.3 [func.bind.place] as indicated:
</p>

<blockquote>
1 All placeholder types shall be <tt>DefaultConstructible</tt> and
<tt><ins>implicit</ins> CopyConstructible</tt>, and [..]
</blockquote>
</li>

<li>
<p>
Change 20.9.10 [unique.ptr]/5 as indicated:
</p>

<blockquote>
5 Each object of a type <tt>U</tt> instantiated form the <tt>unique_ptr</tt>
template specified in this subclause has the strict ownership semantics,
specified above, of a unique pointer. In partial satisfaction of these
semantics, each such <tt>U</tt> is <tt><ins>implicit</ins>
MoveConstructible</tt> and <tt>MoveAssignable</tt>, but is not
<tt>CopyConstructible</tt> nor <tt>CopyAssignable</tt>. The template parameter
<tt>T</tt> of <tt>unique_ptr</tt> may be an incomplete type.
</blockquote>
</li>

<li>
<p>
Change 20.9.11.2 [util.smartptr.shared]/2 as indicated:
</p>

<blockquote>
2 Specializations of <tt>shared_ptr</tt> shall be
<tt><ins>implicit</ins> CopyConstructible</tt>, <tt>CopyAssignable</tt>, and
<tt>LessThanComparable</tt>, [..]
</blockquote>
</li>

<li>
<p>
Change 20.9.11.3 [util.smartptr.weak]/2 as indicated:
</p>

<blockquote>
2 Specializations of <tt>weak_ptr</tt> shall be <tt><ins>implicit</ins>
CopyConstructible</tt> and <tt>CopyAssignable</tt>, allowing their use in
standard containers. The template parameter <tt>T</tt> of <tt>weak_ptr</tt> may
be an incomplete type.
</blockquote>
</li>

<li>
<p>
Change 24.2.2 [iterator.iterators]/2 as indicated: <i>[This fixes a
defect in the Iterator requirements. None of the usual algorithms accepting
iterators would be usable with iterators with explicit copy-constructors]</i>
</p>

<blockquote>
<p>
2 A type <tt>X</tt> satisfies the Iterator requirements if:
</p>

<ul>
<li>
<tt>X</tt> satisfies the <tt><ins>implicit</ins> CopyConstructible</tt>,
<tt>CopyAssignable</tt>, and <tt>Destructible</tt> requirements (20.2.1)
and lvalues of type <tt>X</tt> are swappable (20.2.2), and [..]
</li>
<li>...</li>
</ul>

</blockquote>

</li>

<li>
<p>
Change D.10.1 [auto.ptr]/3 as indicated:
</p>

<blockquote>
3 [..] Instances of <tt>auto_ptr</tt> meet the requirements of
<tt><ins>implicit</ins> MoveConstructible</tt> and <tt>MoveAssignable</tt>, but
do not meet the requirements of <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt>. &mdash; <i>end note</i>]
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1324"></a>1324. Still too many implicit conversions for <tt>pair</tt> and  <tt>tuple</tt></h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair], 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-03-20 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In analogy to library defect 811<a href="lwg-defects.html#811">811</a>, <tt>tuple</tt>'s variadic
constructor
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre></blockquote>

<p>
creates the same problem as pair:
</p>

<blockquote><pre>
#include &lt;tuple&gt;

int main()
{
  std::tuple&lt;char*&gt; p(0);
}
</pre></blockquote>

<p>
produces a similar compile error for a recent gcc implementation.
</p>

<p>
I suggest to follow the same resolution path as has been applied to
<tt>pair</tt>'s corresponding c'tor, that is require that these c'tors should
not participate in overload resolution, if the arguments are not implicitly
convertible to the element types.
</p>

<p>
Further-on both <tt>pair</tt> and <tt>tuple</tt> provide converting constructors
from different <tt>pairs</tt>/<tt>tuples</tt> that should be not available, if
the corresponding element types are not implicitly convertible. It seems
astonishing that in the following example
</p>

<blockquote><pre>
struct A {
  explicit A(int);
};

A  a = 1; <font color="#C80000">// Error</font>

std::tuple&lt;A&gt; ta = std::make_tuple(1); <font color="#C80000">// # OK?</font>
</pre></blockquote>

<p>
the initialization marked with # could be well-formed.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
Only constraints on constructors are suggested. Adding similar constraints on
assignment operators is considered as QoI, because the assigments wouldn't be
well-formed anyway.
]</i></p>


<ol>

<li>
<p>
Following 20.3.5.2 [pairs.pair]/5 add a new Remarks element:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);
</pre>

<blockquote>
<p>
5 <i>Effects:</i> Initializes members from the corresponding members of the
argument<del>, performing implicit conversions as needed</del>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U</tt> is implicitly convertible to <tt>first_type</tt>
and <tt>V</tt> is implicitly convertible to <tt>second_type</tt>.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li>
<p>
Following 20.3.5.2 [pairs.pair]/6 add a new Remarks element:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>
<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::move(p.first)</tt> and second with <tt>std::move(p.second)</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U</tt> is implicitly convertible to <tt>first_type</tt>
and <tt>V</tt> is implicitly convertible to <tt>second_type</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/7 add a new Remarks element:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
<p>
6 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the requirements of
<tt>MoveConstructible</tt> (Table 33) from the corresponding type in
<tt>UTypes</tt>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
7 <i>Effects:</i> Initializes the elements in the <tt>tuple</tt> with the
corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/13 add a new Remarks element:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt; tuple(const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
12 <i>Requires:</i> Each type in <tt>Types</tt> shall be constructible from the
corresponding type in <tt>UTypes</tt>. <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt>.
</p>

<p>
13 <i>Effects:</i> Constructs each element of <tt>*this</tt> with the
corresponding element of <tt>u</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>

<p>
14 [<i>Note:</i> <tt>enable_if</tt> can be used to make the converting
constructor and assignment operator exist only in the cases where the source and
target have the same number of elements. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/16 add a new Remarks element:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt; tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 33) from the corresponding
type in <tt>UTypes</tt>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
16 <i>Effects:</i> Move-constructs each element of <tt>*this</tt> with the
corresponding element of <tt>u</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless each type in <tt>UTypes</tt> is implicitly convertible to its
corresponding type in <tt>Types</tt>.</ins>
</p>

<p>
[<i>Note:</i> <tt>enable_if</tt> can be used to make the converting constructor
and assignment operator exist only in the cases where the source and target have
the same number of elements. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/18 add a new Remarks element:
</p>

<blockquote><pre>
template &lt;class U1, class U2&gt; tuple(const pair&lt;U1, U2&gt;&amp; u);
</pre>

<blockquote>
<p>
17 <i>Requires:</i> The first type in <tt>Types</tt> shall be constructible from
<tt>U1</tt> and the second type in <tt>Types</tt> shall be constructible from
<tt>U2</tt>. <tt>sizeof...(Types) == 2</tt>.
</p>

<p>
18 <i>Effects:</i> Constructs the first element with <tt>u.first</tt> and the
second element with <tt>u.second</tt>.
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U1</tt> is implicitly convertible to the first type in
<tt>Types</tt> and <tt>U2</tt> is implicitly convertible to the second type in
<tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Following 20.4.2.1 [tuple.cnstr]/20 add a new Remarks element:
</p>

<blockquote><pre>
template &lt;class U1, class U2&gt; tuple(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
19 <i>Requires:</i> The first type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt>(Table 33) from <tt>U1</tt> and the
second type in <tt>Types</tt> shall be move-constructible from <tt>U2</tt>.
<tt>sizeof...(Types) == 2</tt>.
</p>

<p>
20 <i>Effects:</i> Constructs the first element with <tt>std::move(u.first)</tt>
and the second element with <tt>std::move(u.second)</tt>
</p>

<p>
<ins><i>Remarks:</i> This constructor shall not participate in overload
resolution unless <tt>U1</tt> is implicitly convertible to the first type in
<tt>Types</tt> and <tt>U2</tt> is implicitly convertible to the second type in
<tt>Types</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1326"></a>1326. Missing/wrong preconditions for <tt>pair</tt> and <tt>tuple</tt> functions</h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair], 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-03-07 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are several constructors and creation functions of std::tuple
that impose requirements on it's arguments, that are unnecessary
restrictive and don't match the intention for the supported argument
types. This is related to the fact that tuple is supposed to accept both
object types and lvalue-references and the usual MoveConstructible and
CopyConstructible requirements are bad descriptions for non-const
references. Some examples:
</p>

<ol type="a">
<li>
<p>
20.4.2.1 [tuple.cnstr] before p.4 and p.8, resp.:
</p>

<blockquote><pre>
explicit tuple(const Types&amp;...);
</pre>
<blockquote>
4 <i>Requires:</i> Each type in <tt>Types</tt> shall be copy constructible.
</blockquote>

<pre>
tuple(const tuple& u) = default;
</pre>
<blockquote>
8 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the requirements of
<tt>CopyConstructible</tt> (Table 34).

</blockquote>
</blockquote>

<p>
A tuple that contains lvalue-references to non-const can never
satisfy the <tt>CopyConstructible</tt> requirements. <tt>CopyConstructible</tt>
requirements <i>refine</i> the <tt>MoveConstructible</tt> requirements and
this would require that these lvalue-references could bind
rvalues. But the core language does not allow that. Even, if we
would interpret that requirement as referring to the underlying
non-reference type, this requirement would be wrong as well,
because there is no reason to disallow a type such as
</p>

<blockquote><pre>
struct NoMoveNoCopy {
  NoMoveNoCopy(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy(const NoMoveNoCopy&amp;) = delete;
  ...
}:
</pre></blockquote>

<p>
for the instantiation of <tt>std::tuple&lt;NoMoveNoCopy&amp;&gt;</tt> and
that of it's copy constructor.
</p>

<p>
A more reasonable requirement for this example would be to require that
"<tt>is_constructible&lt;Ti, const Ti&amp;&gt;::value</tt> shall
evaluate to true for all <tt>Ti</tt> in <tt>Types</tt>". In this case
the special reference-folding and const-merging rules of references
would make this well-formed in all cases. We could also add the further
constraint "if <tt>Ti</tt> is an object type, it shall satisfy the
<tt>CopyConstructible</tt> requirements", but this additional
requirement seems not really to help here. Ignoring it would only mean
that if a user would provide a curious object type <tt>C</tt> that
satisfies the <tt>std::is_constructible&lt;C, const C&amp;&gt;</tt>
test, but not the "<tt>C</tt> is <tt>CopyConstructible</tt>" test would
produce a <tt>tuple&lt;C&gt;</tt> that does not satisfy the
<tt>CopyConstructible</tt> requirements as well.
</p>
</li>

<li>
<p>
20.4.2.1 [tuple.cnstr] before p.6 and p.10, resp.:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
6 <i>Requires:</i> Each type in <tt>Types</tt> shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 33) from the
corresponding type in <tt>UTypes</tt>. <tt>sizeof...(Types) ==
sizeof...(UTypes)</tt>.
</blockquote>

<pre>
tuple(tuple&amp;&amp; u);
</pre>
<blockquote>
10 <i>Requires:</i> Each <tt>type</tt> in <tt>Types</tt> shall shall
satisfy the requirements of <tt>MoveConstructible</tt> (Table 33).
</blockquote>
</blockquote>

<p>
We have a similar problem as in (a): Non-const lvalue-references
are intended template arguments for <tt>std::tuple</tt>, but cannot satisfy
the <tt>MoveConstructible</tt> requirements. In this case the correct
requirements would be
</p>

<blockquote>
<tt>is_constructible&lt;Ti, Ui&gt;::value</tt> shall evaluate to true
for all <tt>Ti</tt> in <tt>Types</tt> and for all <tt>Ui</tt> in
<tt>UTypes</tt>
</blockquote>

<p>
and
</p>

<blockquote>
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall evaluate to true
for all <tt>Ti</tt> in <tt>Types</tt>
</blockquote>

<p>
respectively.
</p>
</li>
</ol>

<p>
Many <tt>std::pair</tt> member functions do not add proper requirements, e.g.
the default c'tor does not require anything. This is corrected within the
suggested resolution. Further-on the P/R has been adapted to the FCD numbering.
</p>

<p><i>[
2010-03-25 Daniel updated wording:
]</i></p>


<blockquote>
The issue became updated to fix some minor inconsistencies and to ensure a
similarly required fix for <tt>std::pair</tt>, which has the same specification
problem as <tt>std::tuple</tt>, since <tt>pair</tt> became extended to support
reference members as well.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/1 as indicated <i>[The changes for the effects
elements are not normative changes, they just ensure
harmonization with existing wording style]</i>:
</p>

<blockquote><pre>
constexpr pair();
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>first_type</tt> and <tt>second_type</tt> shall satisfy
the <tt>DefaultConstructible</tt> requirements.</ins>
</p>

<p>
1 <i>Effects:</i> <ins>Value-initializes <tt>first</tt> and
<tt>second</tt>.</ins><del>Initializes its members as if implemented: <tt>pair()
: first(), second() { }</tt>.</del>
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/2 as indicated:
</p>

<blockquote><pre>
pair(const T1&amp; x, const T2&amp; y);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;T1, const T1&amp;&gt;::value</tt>
is <tt>true</tt> and <tt>is_constructible&lt;T2, const T2&amp;&gt;::value</tt>
is <tt>true</tt>.</ins>
</p>

<p>
2 <i>Effects:</i> The constructor initializes <tt>first</tt> with <tt>x</tt> and
<tt>second</tt> with <tt>y</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/3 as indicated:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(U&amp;&amp; x, V&amp;&amp; y);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, U&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;second_type, V&gt;::value</tt> is
<tt>true</tt>.</ins>
</p>

<p>
3 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::forward&lt;U&gt;(x)</tt> and <tt>second</tt> with
<tt>std::forward&lt;V&gt;(y)</tt>.
</p>

<p>
4 <i>Remarks:</i> If <tt>U</tt> is not implicitly convertible to
<tt>first_type</tt> or <tt>V</tt> is not implicitly convertible to
<tt>second_type</tt> this constructor shall not participate in overload
resolution.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/5 as indicated <i>[The change in the effects
element should be non-normatively and is in compatible to the change suggestion
of 1324<a href="lwg-active.html#1324">1324</a>]</i>:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, const
U&amp;&gt;::value</tt> is <tt>true</tt> and <tt>is_constructible&lt;second_type,
const V&amp;&gt;::value</tt> is <tt>true</tt>.</ins>
</p>

<p>
5 <i>Effects:</i> Initializes members from the corresponding members of the
argument<del>, performing implicit conversions as needed</del>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/6 as indicated:
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>is_constructible&lt;first_type, U&gt;::value</tt> is
<tt>true</tt> and <tt>is_constructible&lt;second_type, V&gt;::value</tt> is
<tt>true</tt>.</ins>
</p>

<p>
6 <i>Effects:</i> The constructor initializes <tt>first</tt> with
<tt>std::<del>move</del><ins>forward&lt;U&gt;</ins>(p.first)</tt> and
<tt>second</tt> with
<tt>std::<del>move</del><ins>forward&lt;V&gt;</ins>(p.second)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair]/7+8 as indicated [The deletion in the effects
element should be non-normatively]:
</p>

<blockquote><pre>
template&lt;class... Args1, class... Args2&gt;
  pair(piecewise_construct_t,
       tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);
</pre>

<blockquote>
<p>
7 <i>Requires:</i> <ins><tt>is_constructible&lt;first_type,
Args1...&gt;::value</tt> is <tt>true</tt> and
<tt>is_constructible&lt;second_type, Args2...&gt;::value</tt> is
<tt>true</tt>.</ins> <del>All the types in <tt>Args1</tt> and <tt>Args2</tt>
shall be <tt>CopyConstructible</tt> (Table 35). <tt>T1</tt> shall be
constructible from <tt>Args1</tt>. <tt>T2</tt> shall be constructible from
<tt>Args2</tt>.</del>
</p>

<p>
8 <i>Effects:</i> The constructor initializes <tt>first</tt> with arguments of
types <tt>Args1...</tt> obtained by forwarding the elements of
<tt>first_args</tt> and initializes <tt>second</tt> with arguments of types
<tt>Args2...</tt> obtained by forwarding the elements of <tt>second_args</tt>.
<del>(Here, forwarding an element <tt>x</tt> of type <tt>U</tt> within a
<tt>tuple</tt> object means calling <tt>std::forward&lt;U&gt;(x)</tt>.)</del>
This form of construction, whereby constructor arguments for <tt>first</tt> and
<tt>second</tt> are each provided in a separate <tt>tuple</tt> object, is called
piecewise construction.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.3.5.2 [pairs.pair] before 12 as indicated:
</p>

<blockquote><pre>
pair&amp; operator=(pair&amp;&amp; p);
</pre>

<blockquote>
<p>
<ins><i>Requires:</i> <tt>first_type</tt> and <tt>second_type</tt> shall satisfy
the <tt>MoveAssignable</tt> requirements.</ins>
</p>

<p>
12 <i>Effects:</i> Assigns to <tt>first</tt> with <tt>std::move(p.first)</tt>
and to <tt>second</tt> with <tt>std::move(p.second)</tt>.
</p>

<p>
13 <i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change [pairs.pair] before 14 as indicated: [The heterogeneous usage
of MoveAssignable is actually not defined,
but the library uses it at several places, so we follow this tradition
until a better term has been agreed on. One
alternative could be to write "first_type shall be assignable from an
rvalue of U [..]"]
</p>

<blockquote><pre>
template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</pre>

<blockquote>

<p>
<ins><i>Requires:</i> <tt>first_type</tt> shall be <tt>MoveAssignable</tt> from
<tt>U</tt> and <tt>second_type</tt> shall be <tt>MoveAssignable</tt> from
<tt>V</tt>.</ins>
</p>

<p>
14 <i>Effects:</i> Assigns to <tt>first</tt> with <tt>std::move(p.first)</tt>
and to <tt>second</tt> with <tt>std::move(p.second)</tt>.
</p>

<p>
15 <i>Returns:</i> <tt>*this</tt>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/4+5 as indicated:
</p>

<blockquote><pre>
explicit tuple(const Types&amp;...);
</pre>

<blockquote>
<p>
4 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for e</ins><del>E</del>ach type
<ins><tt>Ti</tt></ins> in <tt>Types</tt><del> shall be copy
constructible</del>.
</p>

<p>
5 <i>Effects:</i> <del>Copy i</del><ins>I</ins>nitializes each element with the
value of the corresponding parameter.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/6 as indicated:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt;
explicit tuple(UTypes&amp;&amp;... u);
</pre>

<blockquote>
<p>
6 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, Ui&gt;::value ==
true</tt> for e</ins><del>E</del>ach type <ins><tt>Ti</tt></ins> in
<tt>Types</tt> <del>shall satisfy the requirements of
<tt>MoveConstructible</tt> (Table 33) from</del><ins>and for</ins> the
corresponding type <ins><tt>Ui</tt></ins> in <tt>UTypes</tt>.
<tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
7 <i>Effects:</i> Initializes the elements in the <tt>tuple</tt> with the
corresponding value in <tt>std::forward&lt;UTypes&gt;(u)</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/8+9 as indicated:
</p>

<blockquote><pre>
tuple(const tuple&amp; u) = default;
</pre>

<blockquote>
<p>
8 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for e</ins><del>E</del>ach type
<ins><tt>Ti</tt></ins> in <tt>Types</tt><del> shall satisfy the
requirements of <tt>CopyConstructible</tt>(Table 34)</del>.
</p>

<p>
9 <i>Effects:</i> <ins>Initializes</ins><del>Copy constructs</del> each element
of <tt>*this</tt> with the corresponding element of <tt>u</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/10+11 as indicated:
</p>

<blockquote><pre>
tuple(tuple&amp;&amp; u);
</pre>

<blockquote>
<p>
10 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(Types))</tt> and
let <tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>.
Then <tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for
all <tt>i</tt>.</ins> <del>Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
11 <i>Effects:</i> <ins>For each <tt>Ti</tt> in <tt>Types</tt>, initializes the
<tt>i</tt><sup><i>th</i></sup></ins> <del>Move-constructs each</del> element of
<tt>*this</tt> with <del>the corresponding element of</del>
<ins><tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(</tt></ins><tt>u</tt><ins><tt>))</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/15+16 as indicated:
</p>

<blockquote><pre>
template &lt;class... UTypes&gt; tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(Types))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>, and
<tt>Ui</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>. Then
<tt>is_constructible&lt;Ti, Ui&gt;::value</tt> shall be <tt>true</tt> for all
<tt>i</tt>.</ins> <del>Each type in <tt>Types</tt> shall shall satisfy the
requirements of <tt>MoveConstructible</tt> (Table 34) from the corresponding
type in <tt>UTypes</tt></del>. <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
</p>

<p>
16 <i>Effects:</i> <ins>For each type <tt>Ti</tt>, initializes the
<tt>i</tt><sup><i>th</i></sup></ins> <del>Move-constructs each</del> element of
<tt>*this</tt> with <del>the corresponding element of</del>
<ins><tt>std::forward&lt;Ui&gt;(get&lt;i&gt;(</tt></ins><tt>u</tt><ins><tt>))</tt></ins>.
</p>

</blockquote>
</blockquote>

</li>

<li>
<p>
Change 20.4.2.1 [tuple.cnstr]/19+20 as indicated:
</p>

<blockquote><pre>
template &lt;class U1, class U2&gt; tuple(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
19 <i>Requires:</i> <ins><tt>is_constructible&lt;T1, U1&gt;::value ==
true</tt> for <tt>t</tt></ins><del><tt>T</tt></del>he first type
<ins><tt>T1</tt></ins> in <tt>Types</tt> <del>shall shall satisfy the
requirements of <tt>MoveConstructible</tt>(Table 33) from
<tt>U1</tt></del> and <ins><tt>is_constructible&lt;T2, U2&gt;::value ==
true</tt> for</ins> the second type <ins><tt>T2</tt></ins> in
<tt>Types</tt> <del>shall be move-constructible from <tt>U2</tt></del>.
<tt>sizeof...(Types) == 2</tt>.
</p>

<p>
20 <i>Effects:</i> <ins>Initializes</ins><del>Constructs</del> the first
element with
<tt>std::<ins>forward&lt;U1&gt;</ins><del>move</del>(u.first)</tt> and
the second element with
<tt>std::<ins>forward&lt;U2&gt;</ins><del>move</del>(u.second)</tt>.
</p>

</blockquote>
</blockquote>
</li>

<li>
<p>
Change 20.4.2.4 [tuple.creation]/9-16 as indicated:
</p>

<blockquote><pre>
template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
9 <i>Requires:</i> <ins><tt>is_constructible&lt;Ti, const
Ti&amp;&gt;::value == true</tt> for each type <tt>Ti</tt></ins><del>All
the types</del> in <tt>TTypes</tt> <del>shall be
<tt>CopyConstructible</tt> (Table 34)</del>.
<ins><tt>is_constructible&lt;Ui, const Ui&amp;&gt;::value == true</tt>
for each type <tt>Ui</tt></ins><del>All the types</del> in
<tt>UTypes</tt> <del>shall be <tt>CopyConstructible</tt> (Table
34)</del>.
</p>

<p>
10 <i>Returns:</i> A <tt>tuple</tt> object constructed by
<ins>initializing</ins><del>copy constructing</del> its first
<tt>sizeof...(TTypes)</tt> elements from the corresponding elements of
<tt>t</tt> and <ins>initializing</ins><del>copy constructing</del> its
last <tt>sizeof...(UTypes)</tt> elements from the corresponding elements
of <tt>u</tt>.
</p>
</blockquote>

<pre>
template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>

<blockquote>
<p>
11 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for each
type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, const Uj&amp;&gt;::value</tt>
shall be <tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35)</del>.
</p>

<p>
12 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(t))</tt> for all <tt>Ti</tt> in
<tt>TTypes</tt> and initializing the
<tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>get&lt;j&gt;(u)</tt> for all <tt>Uj</tt> in <tt>UTypes</tt>.</ins> <del>move
constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and copy constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>

<pre>
template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
13 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, const Ti&amp;&gt;::value</tt> shall be <tt>true</tt>
for each type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, Uj&gt;::value</tt>
shall be <tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
14 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with <tt>get&lt;i&gt;(t)</tt> for each
type <tt>Ti</tt> and initializing the
<tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Uj&gt;(get&lt;j&gt;(u))</tt> for each type <tt>Uj</tt></ins>
<del>copy constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and move constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>

<pre>
template &lt;class... TTypes, class... UTypes&gt;
tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>

<blockquote>
<p>
15 <i>Requires:</i> <ins>Let <tt>i</tt> be in <tt>[0, sizeof...(TTypes))</tt>,
<tt>Ti</tt> be the <tt>i</tt><sup><i>th</i></sup> type in <tt>Types</tt>,
<tt>j</tt> be in <tt>[0, sizeof...(UTypes))</tt>, and <tt>Uj</tt> be the
<tt>j</tt><sup><i>th</i></sup> type in <tt>UTypes</tt>.
<tt>is_constructible&lt;Ti, Ti&gt;::value</tt> shall be <tt>true</tt> for each
type <tt>Ti</tt> and <tt>is_constructible&lt;Uj, Uj&gt;::value</tt> shall be
<tt>true</tt> for each type <tt>Uj</tt></ins> <del>All the types in
<tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34)</del>.
</p>

<p>
16 <i>Returns:</i> A <tt>tuple</tt> object constructed by <ins>initializing the
<tt>i</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Ti&gt;(get&lt;i&gt;(t))</tt> for each type <tt>Ti</tt> and
initializing the <tt>(j+sizeof...(TTypes))</tt><sup><i>th</i></sup> element with
<tt>std::forward&lt;Uj&gt;(get&lt;j&gt;(u))</tt> for each type <tt>Uj</tt></ins>
<del>move constructing its first <tt>sizeof...(TTypes)</tt> elements from the
corresponding elements of <tt>t</tt> and move constructing its last
<tt>sizeof...(UTypes)</tt> elements from the corresponding elements of
<tt>u</tt></del>.
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1328"></a>1328. istream extractors not setting failbit if eofbit is already set</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-02-17 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
basing on the recent discussion on the library reflector, see c++std-lib-27728
and follow ups, I hereby formally ask for LWG 419 to be re-opened, the rationale
being that according to the current specifications, per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">n3000</a>,
it seems actually impossible to seek away from end of file, contrary to the
rationale which led 342<a href="lwg-closed.html#342">342</a> to its closure as NAD. My request is also
supported by Martin Sebor, and I'd like also to add, as tentative proposed
resolution for the re-opened issue, the wording suggested by Sebor, thus, change
the beginning of 27.7.1.1.3 [istream::sentry]/2, to:
</p>

<blockquote>
2 <i>Effects:</i> If <tt><ins>(!noskipws &amp;&amp; !</ins>is.good())</tt> is
<tt><del>false</del> <ins>true</ins></tt>, calls <tt>is.setstate(failbit)</tt>.
Otherwise prepares for formatted or unformatted input. ...
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.1.1.3 [istream::sentry]/2:
</p>

<blockquote>
2 <i>Effects:</i> If <tt><ins>(!noskipws &amp;&amp; !</ins>is.good())</tt> is
<tt><del>false</del> <ins>true</ins></tt>, calls <tt>is.setstate(failbit)</tt>.
Otherwise prepares for formatted or unformatted input. ...
</blockquote>






<hr>
<h3><a name="1330"></a>1330. Move container requirements into requirements tables</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Abstract:
</p>
<p>
In general, it seems that in a couple of places container behavior is
not described in requirement tables although it is a general behavior.
</p>

<p>
History:
</p>

<p>
Issue 676<a href="lwg-defects.html#676">676</a> added move semantics to unordered containers.
For the added insert functions the Editor requested to put their
semantic description into a requirements table rather than describing
them for each container individually. The text however was taken from
the associative containers, where we also have the semantics for each
container described. Also, 1034<a href="lwg-defects.html#1034">1034</a> is to some extend
requesting a clarification of the requirement tables and it turned out
that in other places we have the same problem (e.g. we have no general
requirement for type pointer and const_pointer although each container
has them with issue 1306<a href="lwg-defects.html#1306">1306</a>).
</p>

<p>
From my personal list of functions in requirement tables
and containers, the following types/functions are missing in
requirement tables:
</p>

<ul>
<li>
<tt>pointer</tt>, <tt>const_pointer</tt> in Table 91 (container requirements)
</li>
<li>
<p>
all copy constructors, copy constructors with allocator,
 assignment operators, and insert operators
 with move semantics for associative and unordered containers
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;)
ContType c1(c2&amp;&amp;,alloc)
c1 = c2&amp;&amp;
c.insert(val&amp;&amp;)
c.insert(pos,val&amp;&amp;)
</pre></blockquote>
</li>
</ul>

<p>
As a special case, we lack the following requirements for all sequence
containers BUT array (so special wording or a new container category is
required):
</p>

<ul>
<li>
<p>
constructor with only a size argument
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>
</li>
<li>
<p>
copy constructor with allocator and move semantics
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;,alloc)
</pre></blockquote>
</li>
<li>
<p>
all constructors that insert multiple elements with additional allocator
</p>
<blockquote><pre>
ContType c(num, val,alloc)
ContType c(beg, end,alloc)
ContType c(initlist,alloc)
</pre></blockquote>
</li>
<li>
<p>
all resize functiuons:
</p>
<blockquote><pre>
c.resize(num)
c.resize(num,val)
</pre></blockquote>
</li>
</ul>

<p>
Note that we also might have to add additional requirements on other
places for sequence containers because having an allocator requires
additional statements for the treatment of the allocators. E.g. swap for
containers with allocators is not specified in any requirement table.
</p>

<p>
And finally, if we have the requirements in the requirements tables, we
can remove the corresponding descriptions for the individual container.
However, note that sequence container requirements have NO complexity
column, so that we still need container specific descriptions for the
functions listed there.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1331"></a>1331. incorporate move special member functions into library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Review the library portion of the spec and incorporate the newly added
core feature Move Special Member Functions (N3044).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1332"></a>1332. Let Hash objects throw!</h3>
<p><b>Section:</b> 20.2.4 [hash.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-03-26 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The currently added Hash requirements demand in Table 40 &mdash; Hash
requirements [hash]:
</p>

<blockquote>
<table border="1">

<caption>Table 40 &mdash; Hash requirements [hash]</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Requirement</th>
</tr>

<tr>
<td><tt>h(k)</tt></td>
<td><tt>size_t</tt></td>
<td>Shall not throw exceptions. [..]</td>
</tr>

</table>
</blockquote>

<p>
While it surely is a generally accepted idea that hash function objects
<i>should</i> not throw exceptions, this basic constraint for such a fundamental
requirement set does neither match the current library policy nor real world
cases:
</p>

<ol>
<li>
There are little known situations where a swap or move operation may throw an
exception and in some popular domains such functions are <em>required</em> not
to throw. But the library invested already efforts for good reasons to require
"working" container implementations in the presence of throwing move or swap
operations, see e.g. 23.2.4.1 [associative.reqmts.except], 23.2.5.1 [unord.req.except].
</li>

<li>
The container library is already specified to cope with potentially throwing
comparers, predicates, <i>and</i> hash function objects, see above.
</li>

<li>
<p>
The new definition goes beyond the original hash requirements as specified
by SGI library in regard to the exception requirement:
</p>
<blockquote>
<a href="http://www.sgi.com/tech/stl/HashFunction.html">http://www.sgi.com/tech/stl/HashFunction.html</a>
</blockquote>
</li>

<li>
There are indeed real-world examples of potentially throwing hash functions,
typically when the proxy pattern is used and when the to-be hashed proxied
instance is some <i>volatile</i> object, e.g. a file or internet resource, that
might suddenly be unavailable at the time of hashing.
</li>

<li>
With the new <tt>noexcept</tt> language facility libraries can still take
advantage of no-throw guarantees of hasher functions with stricter guarantees.
</li>
</ol>

<p>
Even though the majority of all known move, swap, and hash functions won't throw
and in some cases <em>must</em> not throw, it seems like unnecessary
over-constraining the definition of a Hash functor not to propagate exceptions
in any case and it contradicts the general principle of C++ to impose such a
requirement for this kind of fundamental requirement.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change Table 40 &mdash; Hash requirements [hash] as indicated:
</p>

<blockquote>
<table border="1">

<caption>Table 40 &mdash; Hash requirements [hash]</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Requirement</th>
</tr>

<tr>
<td><tt>h(k)</tt></td>
<td><tt>size_t</tt></td>
<td><del>Shall not throw exceptions.</del> [..]</td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>
Add to 20.8.15 [unord.hash]/1 a new bullet:
</p>

<blockquote>
<p>
1 The unordered associative containers defined in Clause 23.5 use
specializations of the class template <tt>hash</tt>
as the default hash function. For all object types <tt>Key</tt> for which there
exists a specialization <tt>hash&lt;Key&gt;</tt>, the
instantiation <tt>hash&lt;Key&gt;</tt> shall:
</p>
<ul>
<li>
satisfy the <tt>Hash</tt> requirements (20.2.4), with <tt>Key</tt> as the
function call argument type, the <tt>DefaultConstructible</tt> requirements
(33), the <tt>CopyAssignable</tt> requirements (37),
</li>
<li>
be swappable (20.2.2) for lvalues,
</li>
<li>
provide two nested types <tt>result_type</tt> and <tt>argument_type</tt> which
shall be synonyms for <tt>size_t</tt> and <tt>Key</tt>, respectively,
</li>
<li>
satisfy the requirement that if <tt>k1 == k2</tt> is true, <tt>h(k1) ==
h(k2)</tt> is also true, where <tt>h</tt> is an object of type
<tt>hash&lt;Key&gt;</tt> and <tt>k1</tt> and <tt>k2</tt> are objects of type
<tt>Key</tt><ins>,</ins><del>.</del>
</li>
<li>
<ins>satisfy the requirement that the expression <tt>h(k)</tt>, where <tt>h</tt>
is an object of type <tt>hash&lt;Key&gt;</tt> and <tt>k</tt> is an object of
type <tt>Key</tt>, shall not throw an expression, unless
<tt>hash&lt;Key&gt;</tt> is a user-defined specialization that depends on at
least one user-defined type.</ins>
</li>
</ul>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="1344"></a>1344. [FCD] Replace <tt>throw()</tt> with <tt>noexcept</tt></h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1351">1351</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-60, CH-16</b></p>
<p>
Dynamic exception specifications are deprecated; the
library should recognise this by replacing all non-throwing
exception specifications of the form <tt>throw()</tt> with the
<tt>noexcept</tt> form.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Replace all non-throwing exception specifications
of the form 'throw()' with the 'noexcept' form.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3148.html">n3148</a>
would satisfy this request.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3148.html">n3148</a>





<hr>
<h3><a name="1345"></a>1345. [FCD] Library classes should have <tt>noexcept</tt> move operations</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-61</b></p>
<p>
All library types should have non-throwing move
constructors and move-assignment operators unless
wrapping a type with a potentially throwing move operation.
When such a type is a class-template, these
operations should have a conditional <tt>noexcept</tt>
specification.
</p>
<p>
There are many other places where a <tt>noexcept</tt>
specification may be considered, but the move operations
are a special case that must be called out, to effectively
support the <tt>move_if_noexcept</tt> function template.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Review every class and class template in the
library. If noexcept move constructor/assignment
operators can be implicitly declared, then they
should be implicitly declared, or explicitly
defaulted. Otherwise, a move constructor/moveassingment
operator with a <tt>noexcept</tt> exception
specification should be provided.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>
would satisfy this request.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>





<hr>
<h3><a name="1346"></a>1346. [FCD] Apply <tt>noexcept</tt> where library specification does not permit exceptions</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1352">1352</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-62, CH-17</b></p>
<p>
Issues with efficiency and unsatisfactory semantics mean
many library functions document they do not throw
exceptions with a Throws: Nothing clause, but do not
advertise it with an exception specification. The semantic
issues are largely resolved with the new 'noexcept'
specifications, and the noexcept operator means we will
want to detect these guarantees programatically in order
to construct programs taking advantage of the guarantee.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a <tt>noexcept</tt> exception specification on each
libary API that offers an unconditional <i>Throws</i>:
Nothing guarantee. Where the guarantee is
conditional, add the appropriate
<tt>noexcept(<i>constant-expression</i>)</tt> if an appropriate
constant expression exists.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">n3149</a>
would satisfy this request.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">n3149</a>





<hr>
<h3><a name="1347"></a>1347. [FCD] Apply <tt>noexcept</tt> judiciously throughout the library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-63, US-80</b></p>
<p>
Since the newly introduced operator <tt>noexcept</tt> makes it
easy (easier than previously) to detect whether or not a
function has been declared with the empty exception
specification (including <tt>noexcept</tt>) library functions that
cannot throw should be decorated with the empty
exception specification. Failing to do so and leaving it as a
matter of QoI would be detrimental to portability and
efficiency.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Review the whole library, and apply the <tt>noexcept</tt>
specification where it is appropriate.
</p>


<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of the combination of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3155.html">n3155</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3156.html">n3156</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3167.html">n3167</a>
would satisfy this request. The paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3150.html">n3150</a> is related
to this as well.
</blockquote>

<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3155.html">n3155</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3156.html">n3156</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3167.html">n3167</a> and remotely
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3150.html">n3150</a>





<hr>
<h3><a name="1348"></a>1348. [FCD] Exception safety of unspecified types</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-64</b></p>
<p>
There are a number of unspecified types used throughout
the library, such as the container iterators. Many of these
unspecified types have restrictions or expectations on
their behaviour in terms of exceptions. Are they permitted
or required to use exception specifications, more
specifically the new <tt>noexcept</tt> specification? For example,
if <tt>vector&lt;T>::iterator</tt> is implemented as a native pointer,
all its operations will have an (effective) <tt>noexcept</tt>
specification. If the implementation uses a class type to
implement this iterator, is it permitted or required to
support that same guarantee?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Clearly state the requirements for exception
specifications on all unspecified library types. For
example, all container iterator operations should
be conditionally <tt>noexcept</tt>, with the condition
matching the same operation applied to the
allocator's <tt>pointer_type</tt>, a certain subset of which
are already required not to throw.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1349"></a>1349. [FCD] <tt>swap</tt> should not throw</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-65</b></p>
<p>
Nothrowing <tt>swap</tt> operations are key to many C++ idioms,
notably the common copy/swap idiom to provide the
strong exception safety guarantee.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Where possible, all library types should provide a
<tt>swap</tt> operation with an exception specification
guaranteeing no exception shall propagate.
Where <tt>noexcept(true)</tt> cannot be guaranteed to
not terminate the program, and the <tt>swap</tt> in
questions is a template, an exception specification
with the appropriate conditional expression could
be specified.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1353"></a>1353. [FCD] Clarify the state of a <i>moved-from</i> object</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-05</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-18</b></p>
<p>
The general approach on moving is that a library object
after moving out is in a "valid but unspecified state". But
this is stated at the single object specifications, which is
error prone (especially if the move operations are implicit)
and unnecessary duplication.
</p>

<p><i>[
Resolution propsed by ballot comment
]</i></p>

<p>
Consider putting a general statement to the same
effect into clause 17.
</p>

<p><i>[2010-11-05 Beman provides exact wording.
The wording was inspired by Dave Abrahams'
message c++std-lib-28958, and refined with help from Alisdair, Daniel, and Howard.
]</i></p>




<p><b>Proposed resolution:</b></p>
    <p><i>Add a new definition to 17.3 Definitions [definitions]:</i></p>
    
    <blockquote>
    <p>17.3.24 [defns.valid.unspecified]<br/>
    <b>valid but unspecified state</b><br/>
    an object state that is not specified except that the object's invariants are met, and operations 
    on the object perform as specified, 
    subject only to the operation's normal preconditions.</p>
    <p>
    [<i>Example:</i> If an object <tt>x</tt> of type <tt>std::vector&lt;int&gt;</tt> is in a valid but 
    unspecified state, <tt>x.empty()</tt> can be called unconditionally, and
    <tt>x.front()</tt> can be called provided <tt>x.empty()</tt> returns
    <tt>false</tt>. <i>--end example</i>]</p>
    </blockquote>
    
    <p><i>Change Table 34 - MoveConstructible requirements [moveconstructible] as 
    indicated:</i></p>
    <blockquote>
    <p><del>[ <i>Note:</i> <tt>rv</tt> remains a valid object. Its state is 
    unspecified&nbsp; <i>--end note</i> ]</del><br/>
    <ins><i>Postcondition:</i><tt> rv</tt> is in a valid but 
    unspecified state ([defns.valid.unspecified]).</ins></p>
    </blockquote>
    
    <p><i>Change Table 36 - MoveAssignable requirements [moveassignable] as 
    indicated:</i></p>
    <blockquote>
    <p><del>[ <i>Note:</i> <tt>rv</tt> remains a valid object. Its state is 
    unspecified&nbsp; <i>--end note</i> ]</del><br/>
    <ins><i>Postcondition:</i><tt> rv</tt> is in a valid but 
    unspecified state ([defns.valid.unspecified]).</ins></p>
    </blockquote>
    
    <p><i>No change in the half-dozen or so places in the standard library that 
    use &quot;valid but unspecified state&quot; directly, and no change in the many places 
    that require <tt>MoveCostructible</tt> or <tt>MoveAssignable</tt>, 
    since <tt>MoveCostructible</tt> and <tt>MoveAssignable</tt> will now 
    normatively require &quot;valid but unspecified state&quot;.</i></p>






<hr>
<h3><a name="1354"></a>1354. [FCD] The definition of deadlock excludes cases involving a single thread</h3>
<p><b>Section:</b> 17.3.7 [defns.deadlock] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-52</b></p>
<p>
The definition of deadlock in 17.3.7 excludes cases
involving a single thread making it incorrect.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
The definition should be corrected.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1358"></a>1358. [FCD] Add <tt>&lt;chrono></tt> and <tt>&lt;ratio></tt> to
freestanding implementations</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-55</b></p>
<p>
The <tt>&lt;thread></tt> header uses <tt>duration</tt> types, found in the
<tt>&lt;chrono></tt> header, and which rely on the <tt>ratio</tt> types
declared in the <tt>&lt;ratio></tt> header.
</p>

<p><i>[
Extracts from lengthy Rapperswil discussion:
]</i></p>

<p>
There is a concern that this issue is a misunderstanding of the actual
requirements of a free-standing implementation to support the <tt>&lt;thread></tt>
header.  In general, a free-standanding implementation will provide an <em>empty</em>
header, specifically so that a user can test for the absence of the 
<tt>_ _ STDCPP_THREADS _ _</tt> macro.  This idiom as used as there is no portable way to test for the lack of a header.
</p>
<p>
At this point, it was suggested the NB comment is trying to solve the wrong problem, and that <tt>_ _ STDCPP_THREADS _ _</tt> should be a pre-defined macro in clause 16 that can be tested before including <tt>&lt;thread></tt>.  That would remove the need to add additional headers to the free-standanding requirements.
</p>
<p>
It is worth noting that Japan requested <tt>&lt;ratio></tt> as a free-standing header in their CD1 comments.  No-one seemed keen to require clocks of a free-standing implementation though.
</p>

<p>Detlef volunteers to look at a way to redraft 17.6.1.3 p3.</p> 

<p><i>[
Original resolution proposed by NB comment:
]</i></p>


<blockquote>
<p>
Add the <tt>&lt;chrono></tt> and <tt>&lt;ratio></tt> headers to the
freestanding requirements.
</p>
<p>
It might be necessary to address scaled-down
expectations of clock support in a freestanding
environment, much like <tt>&lt;thread></tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1364"></a>1364. [FCD] It is not clear how <tt>exception_ptr</tt> is synchronized</h3>
<p><b>Section:</b> 18.8.6 [propagation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-19</b></p>
<p>
It is not clear how <tt>exception_ptr</tt> is synchronized.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make clear that accessing in different threads
multiple <tt>exception_ptr</tt> objects that all refer to the
same exception introduce a race.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1365"></a>1365. [FCD] Thread-safety of handler functions</h3>
<p><b>Section:</b> 18.6.2 [alloc.errors] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-71</b></p>
<p>
The thread safety of <tt>std::set_new_handler()</tt>,
<tt>std::set_unexpected()</tt>, <tt>std::set_terminate()</tt>, is
unspecified making the the functions impossible to use in a thread
safe manner.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
The thread safety guarantees for the functions
must be specified and new interfaces should be
provided to make it possible to query and install
handlers in a thread safe way.
</blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a>
partially addresses this request. This issue is related to 1366<a href="lwg-active.html#1366">1366</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a>





<hr>
<h3><a name="1366"></a>1366. [FCD] New-handler and data races</h3>
<p><b>Section:</b> 18.6.1.4 [new.delete.dataraces] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-14</b></p>
<p>
It is unclear how a user replacement function can
simultaneously satisfy the race-free conditions imposed in
this clause and query the new-handler in case of a failed
allocation with the only available, mutating interface
<tt>std::set_new_handler</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Offer a non-mutating interface to query the current new-handler.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a> would solve this issue.
This issue is related to 1365<a href="lwg-active.html#1365">1365</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
See  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3122.html">n3122</a>.





<hr>
<h3><a name="1368"></a>1368. [FCD] Thread safety of <tt>std::uncaught_exception()</tt></h3>
<p><b>Section:</b> 18.8.5 [uncaught] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-73</b></p>
<p>
The thread safety <tt>std::uncaught_exception()</tt> and the
result of the function when multiple threads throw
exceptions at the same time are unspecified. To make the
function safe to use in the presence of exceptions in
multiple threads the specification needs to be updated.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Update this clause to support safe calls from
multiple threads without placing synchronization
requirements on the user.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1369"></a>1369. [FCD] <tt>rethrow_exception</tt> may introduce data races</h3>
<p><b>Section:</b> 18.8.6 [propagation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-74</b></p>
<p>
One idea for the <tt>exception_ptr</tt> type was that a reference-counted
implementation could simply 'reactivate' the same
exception object in the context of a call to
<tt>rethrow_exception</tt>. Such an implementation would allow
the same exception object to be active in multiple threads
(such as when multiple threads join on a <tt>shared_future</tt>)
and introduce potential data races in any exception
handler that catches exceptions by reference - notably
existing library code written before this capability was
added. <tt>rethrow_exception</tt> should <em>always</em> make a copy
of the target exception object.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to 18.8.5, [propogation]
</p>
<blockquote><ins>
<i>Throws</i>: a copy of the exception object to which <tt>p</tt> refers.
</ins></blockquote>






<hr>
<h3><a name="1370"></a>1370. [FCD] <tt>throw_with_nested</tt> should not use perfect forwarding</h3>
<p><b>Section:</b> 18.8.7 [except.nested] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-84</b></p>
<p>
The <tt>throw_with_nested</tt> specification passes in its argument as
<tt>T&amp;&amp;</tt> (perfect forwarding pattern), but then discusses
requirements on <tt>T</tt> without taking into account that <tt>T</tt>
may be an lvalue-reference type. It is also not clear in the spec that
<tt>t</tt> is intended to be perfectly forwarded.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Patch [except.nested] p6-7 to match the intent with regards to
requirements on <tt>T</tt> and the use of
<tt>std::forward&lt;T&gt;(t)</tt>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3144.html">n3144</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p> 
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3144.html">n3144</a>.





<hr>
<h3><a name="1371"></a>1371. [FCD] standard exceptions require stronger no-throw guarantees</h3>
<p><b>Section:</b> 19 [diagnostics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-75</b></p>
<p>
None of the exception types defined in clause 19 are
allowed to throw an exception on copy or move
operations, but there is no clear specification that the
operations have an exception specification to prove it.
Note that the implicitly declared constructors, taking the
exception specification from their base class (ultimately
<tt>std::exception</tt>) will implicitly generate a <tt>noexcept</tt>
exception specification if all of their data members
similarly declare <tt>noexcept</tt> operations. As the
representation is unspecified, we cannot assume nonthrowing
operations unless we explicitly state this as a
constraint on the implementation.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a global guarantee that all exception types
defined in clause 19 that rely on implicitly declared
operations have a non-throwing exception
specification on those operations.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1373"></a>1373. [FCD] Customizable traits should have their own headers</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility">active issues</a> in [utility].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-79</b></p>
<p>
The library provides several traits mechanisms intended a
customization points for users. Typically, they are
declared in headers that are growing quite large. This is
not a problem for standard library vendors, who can
manage their internal file structure to avoid large
dependencies, but can be a problem for end users who
have no option but to include these large headers.
</p>

<p><i>[
Rapperswil
]</i></p>

<p>
There was no enthusiasm for touching <tt>char_traits</tt> or <tt>regex_traits</tt>.
Consensus to move <tt>iterator_traits</tt>, <tt>allocator_traits</tt>
and <tt>pointer_traits</tt> to their own respective headers once wording supplied.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Move the following traits classes into their own
headers, and require the existing header to
<tt>#include</tt> the traits header to support backwards
compatibility:
</p>
<blockquote><pre>
iterator_traits (plus the iterator tag-types)
allocator_traits
pointer_traits
char_traits
regex_traits
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1374"></a>1374. [FCD] Clarify moved-from objects are &quot;toxic&quot;</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility.arg.requirements">active issues</a> in [utility.arg.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-85</b></p>
<p>
20.2.1 Table 34 "MoveConstructible requirements" says
"Note: rv remains a valid object. Its state is unspecified".
Some components give stronger guarantees. For
example, moved-from <tt>shared_ptr</tt>s are guaranteed <tt>empty</tt>
(20.9.11.2.1/25).
In general, what the standard really should say (preferably
as a global blanket statement) is that moved-from objects
can be destroyed and can be the destination of an
assignment. Anything else is radioactive. For example,
containers can be "emptier than empty". This needs to be
explicit and required generally.
</p>
<p>
Note: The last time that one of us mentioned "emptier
than empty" (i.e. containers missing sentinel nodes, etc.)
the objection was that containers can store sentinel nodes
inside themselves in order to avoid dynamically allocating
them. This is unacceptable because
</p>
<p>
(a) it forces existing implementations (i.e. Dinkumware's, Microsoft's,
IBM's,  etc.) to change for no good reason (i.e. permitting more
operations on moved-from objects), and 
</p>
<p>
(b) it invalidates end-iterators when swapping containers. (The Working
Paper currently permits end-iterator invalidation, which we
consider to be wrong, but that's a separate argument. In
any event, <em>mandating</em> end-iterator invalidation is very
different from permitting it.)
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
State as a general requirement that moved-from
objects can be destroyed and can be the
destination of an assignment. Any other use is
undefined behavior.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1376"></a>1376. [FCD] Allocator interface is not backward compatible</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-88</b></p>
<p>
Allocator interface is not backward compatible.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a> provides an alternative resolution.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a>





<hr>
<h3><a name="1377"></a>1377. [FCD] The revised <tt>forward</tt> is not compatible with access-control</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#utility">active issues</a> in [utility].</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-90</b></p>
<p>
In n3090, at variance with previous iterations of the idea
discussed in papers and incorporated in WDs,
<tt>std::forward</tt> is constrained via <tt>std::is_convertible</tt>,
thus is not robust wrt access control. This causes problems in
normal uses as implementation detail of member
functions. For example, the following snippet leads to a
compile time failure, whereas that was not the case for an
implementation along the lines of n2835 (using <tt>enable_if</tt>s
instead of concepts for the constraining, of course)
</p>
<pre>
#include &lt;utility>
struct Base { Base(Base&amp;&amp;); };

struct Derived
  : private Base
{
  Derived(Derived&amp;&amp; d)
    : Base(std::forward&lt;Base>(d)) { }
};
</pre>
<p>
In other terms, LWG 1054 can be resolved in a better
way, the present status is not acceptable.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">n3143</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html">n3143</a>.





<hr>
<h3><a name="1378"></a>1378. [FCD] <tt>pair</tt> and <tt>tuple</tt> have too many conversions</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-15</b></p>
<p>
Several function templates of <tt>pair</tt> and <tt>tuple</tt> allow for too
many implicit conversions, for example:
</p>
<pre>
#include &lt;tuple>
std::tuple&lt;char*> p(0); // Error?

struct A { explicit A(int){} };
A a = 1; // Error
std::tuple&lt;A> ta = std::make_tuple(1); // OK?
</pre>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Consider to add wording to constrain these function templates.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>




<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1379"></a>1379. [FCD] <tt>pair</tt> copy-assignment not consistent for references</h3>
<p><b>Section:</b> 20.3.5.2 [pairs.pair] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-95</b></p>
<p>
Copy-assignment for <tt>pair</tt> is defaulted and does not work
for pairs with reference members. This is inconsistent with
conversion-assignment, which deliberately succeeds even
if one or both elements are reference types, just as for
<tt>tuple</tt>. The copy-assignment operator should be
consistent with the conversion-assignment operator and
with <tt>tuple</tt>'s assignment operators.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would provide a superior resolution,
because <tt>pair</tt> does not depend on the semantic requirements of <tt>CopyAssignable</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
Add to <tt>pair</tt> synopsis:
<blockquote>
<tt>pair&amp; operator=(const pair&amp; p);</tt>
</blockquote>
<p>
Add before paragraph 9:
</p>
<blockquote>
<tt>pair&amp; operator=(const pair&amp; p);</tt>
<blockquote>
<p>
<i>Requires</i>: <tt>T1</tt> and <tt>T2</tt> shall satisfy the
requirements of <tt>CopyAssignable</tt>.
</p>
<p>
<i>Effects</i>: Assigns <tt>p.first</tt> to <tt>first</tt> and <tt>p.second</tt> to
<tt>second</tt>.
<i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1380"></a>1380. [FCD] <tt>pair</tt> and <tt>tuple</tt> of references need to better specify move-semantics</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-16</b></p>
<p>
Several <tt>pair</tt> and <tt>tuple</tt> functions in regard to move
operations are incorrectly specified if the member types
are references, because the result of a <tt>std::move</tt> cannot
be assigned to lvalue-references. In this context the usage
of the requirement sets <tt>MoveConstructible</tt> and
<tt>CopyConstructible</tt> also doesn't make sense, because
non-const lvalue-references cannot satisfy these requirements.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Replace the usage of <tt>std::move</tt> by that of
<tt>std::forward</tt> and replace <tt>MoveConstructible</tt> and
<tt>CopyConstructible</tt> requirements by other requirements.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1382"></a>1382. [FCD] <tt>pair</tt> and <tt>tuple</tt> constructors should <tt>forward</tt> arguments</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-96</b></p>
<p>
<tt>pair</tt> and <tt>tuple</tt> constructors and assignment operators use
<tt>std::move</tt> when they should use <tt>std::forward</tt>. This
causes lvalue references to be erroneously converted to
rvalue references. Related requirements clauses are also
wrong.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<blockquote>
See Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1383"></a>1383. [FCD] Inconsistent defaulted move/copy members in <tt>pair</tt> and <tt>tuple</tt></h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs">active issues</a> in [pairs].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-97</b></p>
<p>
<tt>pair</tt>'s class definition in N3092 20.3.5.2 [pairs.pair]
contains "<tt>pair(const pair&amp;) = default;</tt>" and 
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>". The latter is described by
20.3.5.2 [pairs.pair] p.12-13.
</p>
"<tt>pair(const pair&amp;) = default;</tt>" is a user-declared explicitly defaulted
copy constructor. According to 12.8 [class.copy]/10, this inhibits 
the implicitly-declared move constructor. <tt>pair</tt> should be move constructible. 
(12.8 [class.copy]/7 explains that "<tt>pair(pair&lt;U, V&gt;&amp;&amp; p)</tt>" 
will never be instantiated to move <tt>pair&lt;T1, T2&gt;</tt> to <tt>pair&lt;T1, T2&gt;</tt>.)<BR/>
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" is a user-provided move
assignment operator (according to 8.4.2 [dcl.fct.def.default]/4: "A 
special member function is user-provided if it is user-declared and not explicitly defaulted
on its first declaration."). According to 12.8 [class.copy]/20, this inhibits
the implicitly-declared copy assignment operator. <tt>pair</tt>
should be copy assignable, and was in C++98/03. (Again,
12.8 [class.copy]/7 explains that "<tt>operator=(const pair&lt;U, V&gt;&amp; p)</tt>" 
will never be instantiated to copy <tt>pair&lt;T1, T2&gt;</tt> to <tt>pair&lt;T1, T2&gt;</tt>.)<BR/>
Additionally, "<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" is
unconditionally defined, whereas according to 12.8 [class.copy]/25,
defaulted copy/move assignment operators are defined as
deleted in several situations, such as when non-static data
members of reference type are present.
<p/>
If "<tt>pair(const pair&amp;) = default;</tt>" and "<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" 
were removed from <tt>pair</tt>'s class definition in 20.3.5.2 [pairs.pair] and from 
20.3.5.2 [pairs.pair]/12-13, <tt>pair</tt> would
receive implicitly-declared copy/move constructors and
copy/move assignment operators, and 12.8 [class.copy]/25 would
apply. The implicitly-declared copy/move constructors
would be trivial when <tt>T1</tt> and <tt>T2</tt> have trivial copy/move
constructors, according to 12.8 [class.copy]/13, and similarly for the
assignment operators, according to12.8 [class.copy]/27. Notes could
be added as a reminder that these functions would be
implicitly-declared, but such notes would not be necessary
(the Standard Library specification already assumes a
high level of familiarity with the Core Language, and
casual readers will simply assume that <tt>pair</tt> is copyable
and movable).
<p/>
Alternatively, <tt>pair</tt> could be given explicitly-defaulted
copy/move constructors and copy/move assignment
operators. This is a matter of style.
<p/>
<tt>tuple</tt> is also affected. <tt>tuple</tt>'s class definition in 20.4 [tuple] contains:
<PRE>
tuple(const tuple&amp;) = default;
tuple(tuple&amp;&amp;);
tuple&amp; operator=(const tuple&amp;);
tuple&amp; operator=(tuple&amp;&amp;);
</PRE>
They should all be removed or all be explicitly-defaulted,
to be consistent with <tt>pair</tt>. Additionally, 20.4.2.1 [tuple.cnstr]/8-9 specifies the 
behavior of an explicitly defaulted function, which is currently inconsistent with
<tt>pair</tt>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Either remove "<tt>pair(const pair&amp;) = default;</tt>" and
"<tt>pair&amp; operator=(pair&amp;&amp; p);</tt>" from <tt>pair</tt>'s class
definition in  20.3.5.2 [pairs.pair] and from  20.3.5.2 [pairs.pair] p.12-13, or
give pair explicitly-defaulted copy/move constructors and copy/move assignment operators.<BR/>
Change <tt>tuple</tt> to match.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a> would solve this issue:
The move/copy constructor will be defaulted, but the corresponding assignment operators need a non-default implementation
because they are supposed to work for references as well.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.





<hr>
<h3><a name="1385"></a>1385. [FCD] <tt>tuple_cat</tt> should be a single variadic signature</h3>
<p><b>Section:</b> 20.4.2.4 [tuple.creation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-88</b></p>
<p>
The <tt>tuple_cat</tt> template consists of four overloads and that
can concatenate only two <tt>tuple</tt>s. A single variadic
signature that can concatenate an arbitrary number of
<tt>tuple</tt>s would be preferred.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Adopt a simplified form of the proposal in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2975.pdf">n2975</a>,
restricted to <tt>tuple</tt>s and neither requiring nor outlawing support for other <tt>tuple</tt>-like types.
</blockquote>

<p><i>[
2010 Rapperswil: Alisdair to provide wording.
]</i></p>


<p><i>[
2010-11-06: Daniel comments and proposes some alternative wording:
]</i></p>


<p>
There are some problems in the wording: First, even though the result type <tt>tuple&lt;<i>see below</i>&gt;</tt>
implies it, the specification of the contained tuple element types is missing. Second, the term &quot;<tt>tuple</tt> 
protocol&quot; is not defined anywhere and I see no reason why this normative wording should not be a non-normative
note. We could at least give a better approximation, maybe "tuple-like protocol" as indicated from header
<tt>&lt;utility&gt;</tt> synopsis. Further, it seems to me that the effects need to contain a combination of <tt>std::forward</tt>
with the call of <tt>get</tt>. Finally I suggest to replace the requirements <tt>Move/CopyConstructible</tt>
by proper usage of <tt>is_constructible</tt>, as indicated by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">n3140</a>.
</p>

<p>Alternative proposed resolution:</p>

<p>
<ol>
<li>Change 20.4.1 [tuple.general] p. 2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:
<blockquote><pre>
namespace std {

...

// <i>20.4.2.4, tuple creation functions:</i>
const unspecified ignore;

template &lt;class... Types&gt;
  tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;...);
  template &lt;class... Types&gt;
  tuple&lt;<i>ATypes</i>...&gt; forward_as_tuple(Types&amp;&amp;...);
  
template&lt;class... Types&gt;
  tuple&lt;Types&amp;...&gt; tie(Types&amp;...);
  
<del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);</del>
<ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;...);</ins>

...

</pre></blockquote>
</li>
<li>Change 20.4.2.4 [tuple.creation] as indicated:
<blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<p><blockquote><del>
8 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in 
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35).
</del></blockquote></p>
<p><blockquote><del>
9 <i>Returns</i>: A <tt>tuple</tt> object constructed by copy constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and copy constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></blockquote></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<p><blockquote><del>
10 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in 
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35).
</del></blockquote></p>
<p><blockquote><del>
11 <i>Returns</i>: A <tt>tuple</tt> object constructed by move constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and copy constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></blockquote></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<p><blockquote><del>
12 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in 
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34).
</del></blockquote></p>
<p><blockquote><del>
13 <i>Returns</i>: A <tt>tuple</tt> object constructed by copy constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and move constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></blockquote></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<p><blockquote><del>
14 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in 
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34).
</del></blockquote></p>
<p><blockquote><del>
15 <i>Returns</i>: A <tt>tuple</tt> object constructed by move constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and move constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></blockquote></p>
<pre><ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>CTypes</i>...&gt; tuple_cat(Tuples&amp;&amp;... tpls);
</ins></pre>
<p><blockquote><ins>
8 Let <tt>Ti</tt> be the <tt><i>i</i></tt><sup>th</sup> type in <tt>Tuples</tt>, <tt>Ui</tt> be <tt>remove_reference&lt;Ti&gt;::type</tt>,
and <tt>tp<sub><i>i</i></sub></tt> be the <tt><i>i</i></tt><sup>th</sup> parameter in the function parameter pack <tt>tpls</tt>, where all 
indexing is zero-based in the following paragraphs of this sub-clause [tuple.creation].
</ins></blockquote></p>
<p><blockquote><ins>
9 <i>Requires</i>: For all <tt><i>i</i></tt>, <tt>Ui</tt> shall be the type <i>cv<sub><tt>i</tt></sub>&nbsp;</i><tt>tuple&lt;Args<sub><i>i</i></sub>...&gt;</tt>, 
where <i>cv<sub><tt>i</tt></sub></i> is the (possibly empty) <tt><i>i</i></tt><sup>th</sup> <i>cv</i>-qualifier-seq, and 
<tt>Args<sub><i>i</i></sub></tt> is the parameter pack representing the element types in <tt>Ui</tt>. Let <tt>Aik</tt> be the 
<tt><i>k<sub>i</sub></i></tt><sup>th</sup> type in <tt>Args<sub><i>i</i></sub></tt>, then for all <tt>Aik</tt> the following 
requirements shall be satisfied: If <tt>Ti</tt> is deduced as an lvalue reference type, then 
<tt>is_constructible&lt;Aik, <i>cv<sub>i</sub>&nbsp;</i>Aik&amp;&gt;::value == true</tt>, otherwise 
<tt>is_constructible&lt;Aik, <i>cv<sub>i</sub>&nbsp;</i>Aik&amp;&amp;&gt;::value == true</tt>.
</ins></blockquote></p>
<p><blockquote><ins>
10 <i>Remarks</i>: The types in <tt><i>CTypes</i></tt> shall be equal to the ordered sequence of the expanded types
<tt>Args<sub>0</sub>..., Args<sub>1</sub>..., Args<sub><i>n</i>-1</sub>...</tt>, where <tt><i>n</i></tt> equals 
<tt>sizeof...(Tuples)</tt>. Let <tt><i>e<sub>i</sub></i>...</tt> be the <tt><i>i</i></tt><sup>th</sup> ordered 
sequence of tuple elements of the result <tt>tuple</tt> object corresponding to the type sequence 
<tt>Args<sub><i>i</i></sub></tt>.
</ins></blockquote></p>
<p><blockquote><ins>
11 <i>Returns</i>: A <tt>tuple</tt> object constructed by initializing all elements in <tt><i>e<sub>i</sub></i>...</tt>
with <tt>get&lt;<i>k<sub>i</sub></i>&gt;(tp<sub>i</sub>)</tt>, when <tt>Ti</tt> is deduced as an lvalue reference type 
and with <tt>std::forward&lt;Aik&gt;(get&lt;<i>k<sub>i</sub></i>&gt;(tp<sub>i</sub>))</tt> otherwise, for each valid 
<tt><i>k<sub>i</sub></i></tt> and each element group <tt><i>e<sub>i</sub></i></tt> in order. 
</ins></blockquote></p>
<p><blockquote><ins>
12 <i>Notes</i>: An implementation may also support additional types that support the <tt>tuple</tt>-like protocol in the 
parameter pack <tt>Tuples</tt> such as <tt>pair</tt> and <tt>array</tt>.
</ins></blockquote></p>
</blockquote>
</li>
</ol>
</p>



<p><b>Proposed resolution:</b></p>
<p>
Ammend 20.4.1 [tuple.general]:
</p>

<blockquote>
2 Header <tt>&lt;tuple&gt;</tt> synopsis
<pre>
namespace std {

...

// <i>20.4.2.4, tuple creation functions:</i>
const unspecified ignore;

template &lt;class... Types&gt;
  tuple&lt;<i>VTypes</i>...&gt; make_tuple(Types&amp;&amp;...);
  template &lt;class... Types&gt;
  tuple&lt;<i>ATypes</i>...&gt; forward_as_tuple(Types&amp;&amp;...);
  
template&lt;class... Types&gt;
  tuple&lt;Types&amp;...&gt; tie(Types&amp;...);
  
<del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, const tuple&lt;UTypes...&gt;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);
template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp;, tuple&lt;UTypes...&gt;&amp;&amp;);</del>
<ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>see below</i>&gt; tuple_cat(Tuples&amp;&amp;...);</ins>

...

</pre>
</blockquote>

<p>
Ammend 20.4.2.4 [tuple.creation]:
</p>

<blockquote>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<p><del>
8 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in 
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35).
</del></p>
<p><del>
9 <i>Returns</i>: A <tt>tuple</tt> object constructed by copy constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and copy constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></pre>
<p><del>
10 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in 
<tt>UTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35).
</del></p>
<p><del>
11 <i>Returns</i>: A <tt>tuple</tt> object constructed by move constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and copy constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(const tuple&lt;TTypes...&gt;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<p><del>
12 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>CopyConstructible</tt> (Table 35). All the types in <tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34).
</del></p>
<p><del>
13 <i>Returns</i>: A <tt>tuple</tt> object constructed by copy constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and move constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></p>
<pre><del>template &lt;class... TTypes, class... UTypes&gt;
  tuple&lt;TTypes..., UTypes...&gt; tuple_cat(tuple&lt;TTypes...&gt;&amp;&amp; t, tuple&lt;UTypes...&gt;&amp;&amp; u);</del></pre>
<p><del>
14 <i>Requires</i>: All the types in <tt>TTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34). All the types in 
<tt>UTypes</tt> shall be <tt>MoveConstructible</tt> (Table 34).
</del></p>
<p><del>
15 <i>Returns</i>: A <tt>tuple</tt> object constructed by move constructing its first <tt>sizeof...(TTypes)</tt> elements 
from the corresponding elements of <tt>t</tt> and move constructing its last <tt>sizeof...(UTypes)</tt> elements from the 
corresponding elements of <tt>u</tt>.
</del></p>
<pre><ins>template &lt;class... Tuples&gt;
  tuple&lt;<i>see below</i>&gt; tuple_cat(Tuples&amp;&amp;... tpls);</ins></pre>
<p><ins>
8 <i>Requires</i>: All the types in template parameter pack <tt>Tuples</tt> shall be instantiations of the <tt>std::tuple</tt> template.
The type of all elements in each <tt>tuple</tt> shall be <tt>MoveConstructible</tt> (Table 34) if the corresponding argument is 
passed as an rvalue, or <tt>CopyConstructible</tt> (Table 35) if passed as an lvalue.
</ins></p>
<p><ins>
9 <i>Returns</i>: A <tt>tuple</tt> object constructed by calling <tt>get&lt;I&gt;(tpls)</tt> for each valid <tt>I</tt> in turn on each 
<tt>tuple</tt> object in the function parameter pack <tt>tpls</tt>. [<i>Note</i>: The effect is to concatenate each succeeding 
<tt>tuple</tt> in the parameter pack <tt>tpls</tt> into one large <tt>tuple</tt>. Elements are not interleaved &mdash; <i>end note</i>].
</ins></p>
<p><ins>
10 <i>Remark</i>: An implementation may also support additional types that support the <tt>tuple</tt> protocol in the 
parameter pack <tt>Tuples</tt> such as <tt>pair</tt> and <tt>array</tt>.
</ins></p>
</blockquote>






<hr>
<h3><a name="1389"></a>1389. [FCD] Compile-time rational arithmetic and overflow</h3>
<p><b>Section:</b> 20.6.2 [ratio.arithmetic] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-89</b></p>
<p>
The alias representations of the <tt>ratio</tt> arithmetic templates
do not allow implementations to avoid overflow, since they
explicitly specify the form of the aliased template
instantiation. For example
<tt>ratio_multiply</tt>, <tt>ratio&lt;2, LLONG_MAX&gt;</tt> is <em>required</em> to
alias <tt>ratio&lt;2*LLONG_MAX, LLONG_MAX*2&gt;</tt>, which
overflows, so is ill-formed. However, this is trivially equal
to <tt>ratio&lt;1, 1&gt;</tt>. It also contradicts the opening statement of
20.6.2 [ratio.arithmetic] p. 1 "implementations may use other algorithms to
compute these values".
</p>

<p><i>[
2010-10-25 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3131.html">n3131</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Change the wording in 20.6.2 [ratio.arithmetic] p. 2-5 as follows:
<p/>
<blockquote><pre>
template &lt;class R1, class R2&gt; using ratio_add = <em>see below</em>;
</pre><blockquote>
2 The type <tt>ratio_add&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den + R2::num * R1::den</tt> 
and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>
template &lt;class R1, class R2&gt; using ratio_subtract = <em>see below</em>;
</pre><blockquote>
3 The type <tt>ratio_subtract&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num * R1::den</tt> 
and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>
template &lt;class R1, class R2&gt; using ratio_multiply = <em>see below</em>;
</pre><blockquote>
4 The type <tt>ratio_multiply&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::num</tt> and <tt>T2</tt> 
has the value <tt>R1::den * R2::den</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>
<blockquote><pre>
template &lt;class R1, class R2&gt; using ratio_divide = <em>see below</em>;
</pre><blockquote>
5 The type <tt>ratio_divide&lt;R1, R2&gt;</tt> shall be a synonym for <del><tt>ratio&lt;T1, T2&gt;</tt></del>
<ins><tt>ratio&lt;U, V&gt;</tt> such that <tt>ratio&lt;U, V&gt;::num</tt> and <tt>ratio&lt;U, V&gt;::den</tt> 
are the same as the corresponding members of <tt>ratio&lt;T1, T2&gt;</tt> would be in the absence of 
arithmetic overflow</ins> where <tt>T1</tt> has the value <tt>R1::num * R2::den</tt> and <tt>T2</tt> 
has the value <tt>R1::den * R2::num</tt>. <ins>If the required values of <tt>ratio&lt;U, V&gt;::num</tt> 
and <tt>ratio&lt;U, V&gt;::den</tt> cannot be represented in <tt>intmax_t</tt> then the program is ill-formed.</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1392"></a>1392. [FCD] <tt>result_of</tt> should support pointer-to-data-member</h3>
<p><b>Section:</b> 20.7.4 [meta.unary] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-102</b></p>
<p>
Despite Library Issue 520's ("<tt>result_of</tt> and pointers to
data members") resolution of CD1, the FCD's <tt>result_of</tt>
supports neither pointers to member functions nor
pointers to data members. It should.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Ensure <tt>result_of</tt> supports pointers to member
functions and pointers to data members.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3123.html">n3123</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3123.html">n3123</a>.





<hr>
<h3><a name="1396"></a>1396. [FCD] <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1451">1451</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>
<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt>
in shared memory, but not a <tt>regex</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Add allocators to regexes
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a>.





<hr>
<h3><a name="1397"></a>1397. [FCD] Deprecate '98 binders</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#function.objects">active issues</a> in [function.objects].</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-95</b></p>
<p>
The adaptable function protocol supported by
<tt>unary_function</tt>/<tt>binary_function</tt> has been superceded by
lambda expressions and <tt>std::bind</tt>. Despite the name, the
protocol is not very adaptable as it requires intrusive
support in the adaptable types, rather than offering an
external traits-like adaption mechanism. This protocol and
related support functions should be deprecated, and we
should not make onerous requirements for the
specification to support this protocol for callable types
introduced in this standard revision, including those
adopted from TR1. It is expected that high-quality
implementations will provide such support, but we should
not have to write robust standard specifications mixing this
restricted support with more general components such as
<tt>function</tt>, <tt>bind</tt> and <tt>reference_wrapper</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Move clauses 20.8.3, 20.8.9, 20.8.11 and 20.8.12
to Annex D.
</p>
<p>
Remove the requirements to conditionally derive from
<tt>unary</tt>/<tt>binary_function</tt> from <tt>function</tt>,
<tt>reference_wrapper</tt>, and the results of calling <tt>mem_fn</tt>
and <tt>bind</tt>.
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3145.html">n3145</a>.





<hr>
<h3><a name="1401"></a>1401. [FCD] <tt>unique_ptr&lt;T&gt; == nullptr</tt></h3>
<p><b>Section:</b> 20.9 [memory] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-06</p>
<p><b>View all other</b> <a href="lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-99</b></p>
<p>
One reason that the <tt>unique_ptr</tt> constructor taking a
<tt>nullptr_t</tt> argument is not <tt>explicit</tt> is to allow conversion
of <tt>nullptr</tt> to <tt>unique_ptr</tt> in contexts like equality
comparison. Unfortunately <tt>operator==</tt> for <tt>unique_ptr</tt> is a
little more clever than that, deducing template parameters for both
arguments. This means that <tt>nullptr</tt> does not get deduced
as <tt>unique_ptr</tt> type, and there are no other comparison
functions to match.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Add the following signatures to 20.9 [memory] p.1, <tt>&lt;memory&gt;</tt>
header synopsis:
<blockquote><pre>
template&lt;typename T, typename D&gt;
bool operator==(const unique_ptr&lt;T, D&gt; &amp; lhs, nullptr_t);
template&lt;typename T, typename D&gt;
bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt; &amp; rhs);
template&lt;typename T, typename D&gt;
bool operator!=(const unique_ptr&lt;T, D&gt; &amp; lhs, nullptr_t);
template&lt;typename T, typename D&gt;
bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt; &amp; rhs);
</pre></blockquote>
</blockquote>

<p><i>[
2010-11-02 Daniel comments and provides a proposed resolution:
]</i></p>


<blockquote>
The same problem applies to <tt>shared_ptr</tt> as well: In both cases there are no
conversions considered because the comparison functions are templates. I agree with
the direction of the proposed resolution, but I believe it would be very surprising
and inconsistent, if given a smart pointer object <tt>p</tt>, the expression
<tt>p == nullptr</tt> would be provided, but not <tt>p &lt; nullptr</tt> and the
other relational operators. According to 5.9 [expr.rel] they are defined
if null pointer values meet other pointer values, even though the result is unspecified
for all except some trivial ones. But null pointer values are nothing special here: 
The Library already defines the relational operators for both <tt>unique_ptr</tt> and 
<tt>shared_ptr</tt> and the outcome of comparing non-null pointer values will be equally 
unspecified. If the idea of supporting <tt>nullptr_t</tt> arguments for relational
operators is not what the committee prefers, I suggest at least to consider to remove 
the existing relational operators for both <tt>unique_ptr</tt> and <tt>shared_ptr</tt>
for consistency. But that would not be my preferred resolution of this issue.
<p/>
The number of overloads triple the current number, but I think it is much clearer to 
provide them explicitly instead of adding wording that attempts to say that "sufficient overloads" are
provided. The following proposal makes the declarations explicit.
<p/>
Additionally, the proposal adds the missing declarations for some <tt>shared_ptr</tt>
comparison functions for consistency.
</blockquote>

<p><i>[
2010-11-03 Daniel adds:
]</i></p>


<p>
Issue 1297<a href="lwg-active.html#1297">1297</a> is remotely related. The following proposed resolution splits
<a href="#1401_extra_bullet">this bullet</a> into sub-bullets A and B. Sub-bullet A would 
also solve 1297<a href="lwg-active.html#1297">1297</a>, but sub-bullet B would not.
<p/>
A further remark in regard to the proposed semantics of the ordering of <tt>nullptr</tt>
against other pointer(-like) values: One might think that the following definition might
be superior because of simplicity:

<blockquote><pre>
template&lt;class T&gt;
bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t);
template&lt;class T&gt;
bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a);
</pre><blockquote>
<i>Returns</i>: <tt>false</tt>.
</blockquote></blockquote>

The underlying idea behind this approach is the assumption that nullptr corresponds
to the least ordinal pointer value. But this assertion does not hold for all supported
architectures, therefore this approach was not followed because it would lead to
the inconsistency, that the following assertion could fire: 
</p>
<blockquote><pre>
shared_ptr&lt;int&gt; p(new int);
shared_ptr&lt;int&gt; null;
bool v1 = p &lt; nullptr;
bool v2 = p &lt; null;
assert(v1 == v2);
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
Wording changes are against N3126.
<p/>
<ol>
<li>Change 20.9 [memory] p. 1, header <tt>&lt;memory&gt;</tt> synopsis as indicated.
<tt>noexcept</tt> specifications are only added, where the guarantee exists, that the function
shall no throw an exception (as replacement of &quot;<i>Throws</i>: Nothing&quot;. This needs 
to be harmonized with the result of the <tt>noexcept</tt> proposals:
<blockquote><pre>
namespace std {
  [..]
  // <i>20.9.10 Class unique_ptr:</i>
  template &lt;class T&gt; class default_delete;
  template &lt;class T&gt; class default_delete&lt;T[]&gt;;
  template &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;

  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  
  // <i>20.9.11.1, Class bad_weak_ptr:</i>
  class bad_weak_ptr;

  // <i>20.9.11.2, Class template shared_ptr:</i>
  template&lt;class T&gt; class shared_ptr;

  // <i>20.9.11.2.7, shared_ptr comparisons:</i>
  template&lt;class T, class U&gt;
  bool operator==(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);
  template&lt;class T, class U&gt;
  bool operator!=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);
  template&lt;class T, class U&gt;
  bool operator&lt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);
  template&lt;class T, class U&gt;
  bool operator&gt;(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);
  template&lt;class T, class U&gt;
  bool operator&lt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);
  template&lt;class T, class U&gt;
  bool operator&gt;=(shared_ptr&lt;T&gt; const&amp; a, shared_ptr&lt;U&gt; const&amp; b);

  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator==(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator==(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator!=(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator!=(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;=(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;=(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;=(shared_ptr&lt;T&gt; const&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;=(nullptr_t, shared_ptr&lt;T&gt; const&amp; a) noexcept;</ins>

  [..]
}
</pre></blockquote>
</li>
<li>Change the synopsis just after 20.9.10 [unique.ptr] p. 6 as indicated:
<blockquote><pre>
namespace std {
  [..]
  
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);

  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
  <ins>template &lt;class T, class D&gt;</ins>
  <ins>bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>

}
</pre></blockquote>
</li>
<li><a name="1401_extra_bullet">This bullet splits into two sub-bullets A and B as mentioned in the discussion comment:</a>
<ol style="list-style-type:upper-alpha">
<li>Change 20.9.10.4 [unique.ptr.special]/4-7 as indicated and add a series of prototype
descriptions:
<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>? <i>Requires:</i> Let <tt>CT</tt> be <tt>common_type&lt;unique_ptr&lt;T1,
D1&gt;::pointer, unique_ptr&lt;T2, D2&gt;::pointer&gt;::type</tt>. Then
the specialization <tt>less&lt;CT&gt</tt> shall be a function object type ([function.objects]) 
that induces a strict weak ordering ([alg.sorting]) on the pointer values.</ins>
</p>

<p>
4 <i>Returns:</i> <tt><ins>less&lt;CT&gt;()(x.get(), y.get())</ins><del>x.get()
&lt; y.get()</del></tt>.
</p>

<p>
<ins>? <i>Remarks:</i> If <tt>unique_ptr&lt;T1, D1&gt;::pointer</tt> is not
implicitly convertible to <tt>CT</tt> or <tt>unique_ptr&lt;T2,
D2&gt;::pointer</tt> is not implicitly convertible to <tt>CT</tt>, the program
is ill-formed.</ins>
</p>
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
5 <i>Returns:</i> <tt><ins>!(y &lt; x)</ins><del>x.get() &lt;= y.get()</del></tt>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
6 <i>Returns:</i> <tt><ins>(y &lt; x)</ins><del>x.get() &gt; y.get()</del></tt>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
7 <i>Returns:</i> <tt><ins>!(x &lt; y)</ins><del>x.get() &gt;= y.get()</del></tt>.
</blockquote>
</blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!x</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>(bool) x</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre>
<blockquote>
<ins>? <i>Requires:</i> The specialization <tt>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt</tt> 
shall be a function object type ([function.objects]) that induces a strict weak ordering ([alg.sorting])
on the pointer values.</ins>
</blockquote>
<blockquote>
<ins>? <i>Returns</i>: <tt>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt;()(x.get(), nullptr)</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre>
<blockquote>
<ins>? <i>Requires:</i> The specialization <tt>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt</tt> 
shall be a function object type ([function.objects]) that induces a strict weak ordering ([alg.sorting])
on the pointer values.</ins>
</blockquote>
<blockquote>
<ins>? <i>Returns</i>: <tt>less&lt;unique_ptr&lt;T, D&gt;::pointer&gt;()(nullptr, x.get())</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!(nullptr &lt; x)</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!(x &lt; nullptr)</tt>.</ins>
</blockquote></blockquote>

</li>
<li>
Add the following series of prototype specifications at the very end of 20.9.10.4 [unique.ptr.special].
Intentionally, the relational operators are defined individually, because there is no guarantee that
from <tt>x.get() &lt; nullptr</tt> follows the relation <tt>nullptr &gt; x.get()</tt>:
<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!x</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</ins>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>(bool) x</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>x.get() &lt; nullptr</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>nullptr &lt; x.get()</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>x.get() &lt;= nullptr</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>nullptr &lt;= x.get()</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>x.get() &gt; nullptr</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>nullptr &gt; x.get()</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>x.get() &gt;= nullptr</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template &lt;class T, class D&gt;</ins>
<ins>bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x);</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>nullptr &gt;= x.get()</tt>.</ins>
</blockquote></blockquote>
</li>
</ol>
</li>
<li>Change 20.9.11.2 [util.smartptr.shared] p. 1, class template shared_ptr 
synopsis as indicated. For consistency reasons the remaining normal relation
operators are added as well:
<blockquote><pre>
namespace std {
  [..]
  // <i>20.9.11.2.7, shared_ptr comparisons:</i>
  template&lt;class T, class U&gt;
  bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
  template&lt;class T, class U&gt;
  bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
  template&lt;class T, class U&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b);
  <ins>template&lt;class T, class U&gt;</ins>
  <ins>bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</ins>
  <ins>template&lt;class T, class U&gt;</ins>
  <ins>bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</ins>
  <ins>template&lt;class T, class U&gt;</ins>
  <ins>bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</ins>

  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&lt;class T&gt;</ins>
  <ins>bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
  <ins>template&gt;class T&gt;</ins>
  <ins>bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>

  [..]
}
</pre></blockquote>
</li>
<li>Add the following series of prototype specifications at the very end of 20.9.11.2.7 [util.smartptr.shared.cmp].
For mixed comparison the general &quot;generation&quot; rule of 20.3.1 [operators] p. 10 does not apply, 
therefore all of them are defined. Below wording takes advantage of the simplified definition of the
<em>composite pointer type</em> if one partner is a null pointer constant:
<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator==(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!a</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>(bool) a</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>less&lt;T*&gt;()(a.get(), nullptr)</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>less&lt;T*&gt;()(nullptr, a.get())</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!(nullptr &lt; a)</tt>.</ins>
</blockquote></blockquote>

<blockquote><pre>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</ins>
<ins>template&lt;class T&gt;</ins>
<ins>bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</ins>
</pre><blockquote>
<ins>? <i>Returns</i>: <tt>!(a &lt; nullptr)</tt>.</ins>
</blockquote></blockquote>

</li>
</ol>





<hr>
<h3><a name="1408"></a>1408. [FCD] Allow recycling of pointers after <tt>undeclare_no_pointers</tt></h3>
<p><b>Section:</b> 20.9.12 [util.dynamic.safety] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View all other</b> <a href="lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-103</b></p>
<p>
The precondition to calling <tt>declare_no_pointers</tt> is that no
bytes in the range "have been previously registered" with
this call. As written, this precondition includes bytes in
ranges, even after they have been explicitly unregistered
with a later call to <tt>undeclare_no_pointers</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update 20.9.12 [util.dynamic.safety] p.9:
</p>
<blockquote><pre>
void declare_no_pointers(char *p, size_t n);
</pre><blockquote>
<tt>9</tt> <em>Requires</em>: No bytes in the specified range <del>have been
previously registered</del><ins>are currently registered</ins> with <tt>declare_no_pointers()</tt>.
If the specified range is in an allocated object, then it must be entirely within a single allocated object.
The object must be live until the corresponding <tt>undeclare_no_pointers()</tt> call. [..]
</blockquote></blockquote>





<hr>
<h3><a name="1409"></a>1409. [FCD] Specify whether <tt>monotonic_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> 20.11.5.2 [time.clock.monotonic] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.clock.monotonic">active issues</a> in [time.clock.monotonic].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-111</b></p>
<p>
What it means for <tt>monotonic_clock</tt> to be a synonym is
undefined. If it may or may not be a typedef, then certain
classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Require that it be a distinct class type.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is not a typedef.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a>.





<hr>
<h3><a name="1410"></a>1410. [FCD] Add a feature-detect macro for <tt>monotonic_clock</tt></h3>
<p><b>Section:</b> 20.11.5.2 [time.clock.monotonic] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.clock.monotonic">active issues</a> in [time.clock.monotonic].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1411">1411</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-107, DE-20</b></p>
<p>
1.4 [intro.compliance] p.9 states that which conditionally
supported constructs are available should be provided in the 
documentation for the implementation. This doesn't help programmers trying
to write portable code, as they must then rely on
implementation-specific means to determine the
availability of such constructs. In particular, the presence
or absence of <tt>std::chrono::monotonic_clock</tt> may require
different code paths to be selected. This is the only
conditionally-supported library facility, and differs from the
conditionally-supported language facilities in that it has
standard-defined semantics rather than implementation-defined
semantics.
</p>

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Provide feature test macro for determining the
presence of <tt>std::chrono::monotonic_clock</tt>. Add
<tt>_STDCPP_HAS_MONOTONIC_CLOCK</tt> to the
<tt>&lt;chrono&gt;</tt> header, which is defined if
<tt>monotonic_clock</tt> is present, and not defined if it is
not present.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is not conditionally supported,
so there is no need to detect it.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a>.





<hr>
<h3><a name="1412"></a>1412. [FCD] Make monotonic clocks mandatory</h3>
<p><b>Section:</b> 20.11.5.2 [time.clock.monotonic] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-02</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.clock.monotonic">active issues</a> in [time.clock.monotonic].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-21</b></p>
<p>
Monotonic clocks are generally easy to provide on all
systems and are implicitely required by some of the library
facilities anyway.
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> addresses
this issue by replacing <tt>monotonic_clock</tt> with <tt>steady_clock</tt>, which is mandatory.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Make monotonic clocks mandatory.</p>
<p>Strike 20.11.5.2 [time.clock.monotonic] p.2</p>
<blockquote>
<tt>2</tt> <del>The class <tt>monotonic_clock</tt> is conditionally supported.</del>
</blockquote>

<p>Change 30.2.4 [thread.req.timing] p.2 accordingly</p>
<blockquote>
The member functions whose names end in <tt>_for</tt> take an argument that
specifies a relative time. Implementations should use a monotonic clock to
measure time for these functions. <del>[ <em>Note</em>: Implementations are not
required to use a monotonic clock because such a clock may not be available.
&mdash; <em>end note</em> ]</del>
</blockquote>






<hr>
<h3><a name="1413"></a>1413. [FCD] Specify whether <tt>high_resolution_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> 20.11.5.3 [time.clock.hires] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-112</b></p>
<p>
What it means for <tt>high_resolution_clock</tt> to be a synonym
is undefined. If it may or may not be a typedef, then
certain classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Require that it be a distinct class type.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1418"></a>1418. [FCD] Effects of <tt>resize(size())</tt> on a <tt>deque</tt></h3>
<p><b>Section:</b> 23.3.2.2 [deque.capacity] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-113</b></p>
<p>
There is no mention of what happens if <tt>sz==size()</tt>. While
it obviously does nothing I feel a standard needs to say
this explicitely.
</p>


<p><b>Proposed resolution:</b></p>
<p>Ammend [deque.capacity]</p>
<blockquote>
</blockquote>
<p><tt>void resize(size_type sz);</tt></p>
<p>
<i>Effects</i>: If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() +
sz, end());</tt>. If <tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> <del>default constructed</del><ins>value initialized</ins> elements to the sequence.<ins> If <tt>sz == size()</tt>,
does nothing.</ins>
</p>





<hr>
<h3><a name="1420"></a>1420. [FCD] Effects of <tt>resize(size())</tt> on a <tt>list</tt></h3>
<p><b>Section:</b> 23.3.4.2 [list.capacity] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View all other</b> <a href="lwg-index.html#list.capacity">issues</a> in [list.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-115</b></p>
<p>
There is no mention of what happens if <tt>sz==size()</tt>. While
it obviously does nothing I feel a standard needs to say
this explicitely.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Express the semantics as pseudo-code similarly
to the way it is done for the copying overload that
follows (in p3). Include an else clause that does
nothing and covers the <tt>sz==size()</tt> case.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Ammend [list.capacity] p1:
</p>
<blockquote>
<p><tt>void resize(size_type sz);</tt></p>
<blockquote>
<i>Effects</i>: If <tt>sz &lt; size()</tt>, equivalent to <tt>list&lt;T&gt;::iterator
it = begin(); advance(it, sz); erase(it, end());</tt><del>.</del> <del>I</del><ins>i</ins>f
<tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> <del>default constructed</del>
<ins>value initialized</ins> elements to the sequence<del>.</del><ins>; otherwise, has no
effect.</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="1421"></a>1421. [FCD] Accidental move-only library types due to new core language rules</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.adaptors">active issues</a> in [container.adaptors].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1350">1350</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE-22, CH-15</b></p>
<p>
With the final acceptance of move operations as special
members and introduction of corresponding suppression
rules of implicitly generated copy operations the some
library types that were copyable in C++03 are no longer
copyable (only movable) in C++03, among them <tt>queue</tt>,
<tt>priority_queue</tt>, and <tt>stack</tt>.
</p>

<p><i>[
2010-10-26: Daniel comments:
]</i></p>


<p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3112.pdf">n3112</a> should fix this.
</p>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3112.pdf">n3112</a>





<hr>
<h3><a name="1422"></a>1422. [FCD] vector&lt;bool&gt;</tt> iterators are not random access</h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-118</b></p>
<p>
<tt>vector&lt;bool></tt> iterators are not random access iterators
because their reference type is a special class, and not
<tt>bool &amp;</tt>. All standard libary operations taking iterators
should treat this iterator as if it was a random access iterator, rather
than a simple input iterator.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Either revise the iterator requirements to support proxy iterators
(restoring functionality that was lost when the Concept facility was
removed) or add an extra paragraph to the <tt>vector&lt;bool</tt>
specification requiring the library to treat <tt>vector&lt;bool></tt>
iterators as-if they were random access iterators, despite having the wrong
reference type.
</p>

<p><i>[
Rapperswil Review
]</i></p>

<p>
The consensus at Rapperswil is that it is too late for full support for
proxy iterators, but requiring the library to respect <tt>vector&;t;bool></tt>
iterators as-if they were random access would be preferable to flagging
this container as deliberately incompatible with standard library algorithms.
</p>
<p>
Alisdair to write the note, which may become normative <i>Remark</i> depending
on the preferences of the project editor.
</p>

<p><i>[
Post-Rapperswil Alisdair provides wording
]</i></p>

<p>
Initial wording is supplied, deliberately using <i>Note</i> in preference to
<i>Remark</i> although the author notes his preference for <i>Remark</i>.  The
issue of whether <tt>iterator_traits&lt;vector&lt;bool>>::iteratator_category</tt>
is permitted to report <tt>random_access_iterator_tag</tt> or must report 
<tt>input_iterator_tag</tt> is not addressed.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph into [vector.bool] between p4 and p5:
</p>
<blockquote>
[<i>Note</i> All functions in the library that take a pair of iterators to
denote a range shall treat <tt>vector&lt;bool></tt> iterators as-if they were
random access iterators, even though the <tt>reference</tt> type is not a
true reference.<i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="1435"></a>1435. [FCD] Unclear returns specifications for C99 complex number functions</h3>
<p><b>Section:</b> 26.4.7 [complex.value.ops] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-06</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.value.ops">issues</a> in [complex.value.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-120</b></p>

The complex number functions added for compatibility
with the C99 standard library are defined purely as a
cross-reference, with no hint of what they should return.
This is distinct from the style of documentation for the
functions in the earlier standard. In the case of the
inverse-trigonometric and hyperbolic functions, a
reasonable guess of the functionality may be made from
the name, this is not true of the cproj function, which
apparently returns the projection on the Reimann Sphere.
A single line description of each function, associated with
the cross-reference, will greatly improve clarity.

<p><i>[2010-11-06 Beman provides proposed resolution wording.]</i></p>



<p><b>Proposed resolution:</b></p>

<p><i>Change 26.4.7 complex value operations [complex.value.ops] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; proj(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i> the projection of <tt>x</tt> onto the Riemann 
    sphere.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cproj</tt>, 
    defined in 7.3.9.4.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; acos(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc cosine  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cacos</tt>, 
    defined in 7.3.5.1.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; asin(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc sine  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>casin</tt>, 
    defined in 7.3.5.2.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; atan(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc tangent  of <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>catan</tt>, 
    defined in 7.3.5.3.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; acosh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic cosine of
    <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>cacosh</tt>, 
    defined in 7.3.6.1.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; asinh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic sine  of <tt>
    x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>casinh</tt>, 
    defined in 7.3.6.2.</p>
  </blockquote>
</blockquote>

<p><i>Change 26.4.8 complex transcendentals [complex.transcendentals] as indicated:</i></p>
<blockquote>
  <p><tt>template&lt;class T&gt; complex&lt;T&gt; atanh(const complex&lt;T&gt;&amp; x);</tt></p>
  <blockquote>
    <p><ins><i>Returns:</i>&nbsp; the complex arc hyperbolic tangent  of
    <tt>x</tt>.</ins></p>
    <p><del><i>Effects:</i></del> <ins><i>Remarks:</i></ins> Behaves the same as the C function <tt>catanh</tt>, 
    defined in 7.3.6.2.</p>
  </blockquote>
</blockquote>







<hr>
<h3><a name="1436"></a>1436. [FCD] Random number engine constructor concerns</h3>
<p><b>Section:</b> 26.5.3 [rand.eng] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-06</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-121</b></p>

All the random number engine types in this clause have a
constructor taking an unsigned integer type, and a
constructor template for seed sequences. This means that
an attempt to create a random number engine seeded by
an integer literal must remember to add the appropriate
unsigned suffix to the literal, as a signed integer will
attempt to use the seed sequence template, yielding
undefined behaviour, as per 26.5.1.1p1a. It would be
helpful if at least these anticipated cases produced a
defined behaviour, either an erroneous program with
diagnostic, or a conversion to unsigned int forwarding to
the appropriate constructor.

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>
I suggest to apply a similar solution as recently suggested for 1234<a href="lwg-active.html#1234">1234</a>.
It is basically a requirement for an implementation to constrain the template.
</p>

<p><i>[
2010-11-04 Howard suggests to use <tt>!is_convertible&lt;Sseq, result_type&gt;::value</tt>
as minimum requirement instead of the originally proposed <tt>!is_scalar&lt;Sseq&gt;::value</tt>.
This would allow for a user-defined type <tt>BigNum</tt>, that is convertible to <tt>result_type</tt>,
to be used as argument for a seed instead of a seed sequence. The wording has been updated to 
reflect this suggestion.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add the following paragraph at the end of 26.5.3 [rand.eng]:
<blockquote>
<blockquote>
5 Each template specified in this section [rand.eng] requires one or more relationships, involving the value(s) of
its non-type template parameter(s), to hold. A program instantiating any of these templates is ill-formed if
any such required relationship fails to hold.
</blockquote>

<blockquote>
<ins>? For every random number engine and for every random number engine adaptor <tt>X</tt> defined in this sub-clause 
[rand.eng] and in sub-clause [rand.adapt]:</ins>
<ul>
<li><ins>If the constructor</ins>
<blockquote><pre>
<ins>template&lt;class Sseq&gt; explicit X(Sseq&amp; q);</ins>
</pre></blockquote>
<ins>is called with a type <tt>Sseq</tt> that does not qualify as a seed sequence, then this constructor 
shall not participate in overload resolution.
</ins>
</li>
<li><ins>If the member function</ins>
<blockquote><pre>
<ins>template&lt;class Sseq&gt; void seed(Sseq&amp; q);</ins>
</pre></blockquote>
<ins>is called with a type <tt>Sseq</tt> that does not qualify as a seed sequence, then this function 
shall not participate in overload resolution.
</ins>
</li>
</ul>
<ins>The extent to which an implementation determines that a type cannot be a seed sequence is unspecified,
except that as a minimum a type shall not qualify as seed sequence, if it is implicitly convertible
to <tt>X::result_type</tt>.</ins>
</blockquote>

</blockquote>





<hr>
<h3><a name="1437"></a>1437. [FCD] Mersenne twister meaningless for word sizes less than two</h3>
<p><b>Section:</b> 26.5.3.2 [rand.eng.mers] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-124</b></p>

The Mersenne twister algorithm is meaningless for word
sizes less than two, as there are then insufficient bits
available to be &#8220;twisted&#8221;.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Insert the following among the relations that are required to hold: <tt>2u &lt; w</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
Change 26.5.3.2 [rand.eng.mers] p. 4 as indicated:
<p/>
<blockquote>
4 The following relations shall hold: <tt>0 &lt; m</tt>, <tt>m &lt;= n</tt>, <ins><tt>2u &lt; w</tt>,</ins>
<tt>r &lt;= w</tt>, <tt>u &lt;= w</tt>, <tt>s &lt;= w</tt>, <tt>t &lt;= w</tt>, 
<tt>l &lt;= w</tt>, <tt>w &lt;= numeric_limits&lt;UIntType&gt;::digits</tt>, 
<tt>a &lt;= (1u&lt;&lt;w) - 1u</tt>, <tt>b &lt;= (1u&lt;&lt;w) - 1u</tt>, 
<tt>c &lt;= (1u&lt;&lt;w) - 1u</tt>, <tt>d &lt;= (1u&lt;&lt;w) - 1u</tt>, 
and <tt>f &lt;= (1u&lt;&lt;w) - 1u</tt>.
</blockquote>





<hr>
<h3><a name="1438"></a>1438. [FCD] No definition for <tt>base()</tt></h3>
<p><b>Section:</b> 26.5.4.1 [rand.adapt.disc] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.adapt.disc">issues</a> in [rand.adapt.disc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-126</b></p>

Each adaptor has a member function called <tt>base()</tt> which has no definition.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Give it the obvious definition.
</blockquote>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The following proposal adds <tt>noexcept</tt> specifiers to the declarations of
the <tt>base()</tt> functions as replacement for a &quot;<i>Throws</i>: Nothing&quot; element.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change in [rand.adapt.disc]/3, class template <tt>discard_block_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.disc]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>Change in [rand.adapt.ibits]/4, class template <tt>independent_bits_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.ibits]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>Change in [rand.adapt.shuf]/3, class template <tt>shuffle_order_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.shuf]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1439"></a>1439. [FCD] Return from densities() functions?</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-134</b></p>

These two distributions have a member function called
<tt>densities()</tt> which returns a <tt>vector&lt;double&gt;</tt>. The
distribution is templated on <tt>RealType</tt>. The distribution
also has another member called <tt>intervals()</tt> which returns
a <tt>vector&lt;RealType&gt;</tt>. Why doesn't densities return
<tt>vector&lt;RealType&gt;</tt> as well? If <tt>RealType</tt> is <tt>long double</tt>,
the computed densities property isn't being computed to
the precision the client desires. If <tt>RealType</tt> is <tt>float</tt>, the
densities vector is taking up twice as much space as the client desires.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change the piecewise constant and linear
distributions to hold / return the densities in a
<tt>vector&lt;result_type&gt;</tt>.
<p/>
If this is not done, at least correct 26.5.8.5.2 [rand.dist.samp.pconst] p. 13 which describes
the return of densities as a <tt>vector&lt;result_type&gt;</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1440"></a>1440. [FCD] Incorrect specification for rand.dist.samp.plinear</h3>
<p><b>Section:</b> 26.5.8.5.3 [rand.dist.samp.plinear] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-135</b></p>

This paragraph says: Let bk = xmin+k&middot;&delta; for k = 0,...,n,
and wk = fw(bk +&delta;) for k = 0,...,n.
However I believe that fw(bk) would be far more desirable.
I strongly suspect that this is nothing but a type-o.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change p. 10 to read:<BR/>
Let bk = xmin+k&middot;&delta; for k = 0,...,n, and wk = fw(bk)
for k = 0,...,n.
</blockquote>

<p><i>[
2010-11-02 Daniel translates into a proposed resolution
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 26.5.8.5.3 [rand.dist.samp.plinear] p. 10 as indicated:
<blockquote>
10 <em>Effects</em>: Constructs a <tt>piecewise_linear_distribution</tt> object with parameters taken or calculated
from the following values: Let <tt><em>b<sub>k</sub></em> = xmin+<em>k</em>&middot;&delta;</tt> for 
<tt><em>k</em> = 0, . . . , <em>n</em></tt>, and <tt><em>w<sub>k</sub></em> = fw(<em>b</em><sub><em>k</em></sub><del> +&delta;</del>)</tt> 
for <tt><em>k</em> = 0, . . . , <em>n</em></tt>.</blockquote>





<hr>
<h3><a name="1442"></a>1442. [FCD] "happens-before" should be "synchronizes-with"</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1443">1443</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-9, GB-122</b></p>

<p><i>[CA-9:]</i></p>


Imposed happens-before edges should be in
synchronizes-with<BR/>
Each use of the words "happens-before" should be
replaced with the words "synchronizes-with" in the
following sentences:<BR/>
27.2.3p2<BR/>
30.3.1.2p6<BR/>
30.3.1.5p7<BR/>
30.6.4p7<BR/>
30.6.9p5<BR/>
30.6.10.1p23<BR/>
Rationale: Happens-before is defined in 1.10p11 in a way
that (deliberately) does not make it explicitly transitively
closed. Adding edges to happens-before directly, as in
27.2.3p2 etc., does not provide transitivity with
sequenced-before or any other existing happens-before
edge. This lack of transitivity seems to be unintentional.

<p><i>[GB-122]</i></p>


<p>At various points in the standard new edges are added to
happens-before, for example 27.2.3:2 adds happens-before edges between
writes and reads from a stream:</p>

<p>If one thread makes a library call a that writes a value to a
stream and, as a result, another thread reads this value from the
stream through a library call b such that this does not result in a
data race, then a happens before b.</p>

<p>Happens-before is defined in 1.10:11 in a deliberate way that makes it
not explicitly transitively closed. Adding edges to happens-before
directly, as in 27.2.3:2, does not provide transitivity with
sequenced-before or any other existing happens-before edge. This lack
of transitivity seems to be unintentional. In order to achieve
transitivity we suggest each edge be added to
inter-thread-happens-before as a synchronises-with edge (as per
conversation with Hans Boehm). In the standard, each use of the words
"happens-before" should be replaced with the words "synchronizes-with"
in the following sentences:</p>

<p>27.2.3:2,
30.3.1.2:6,
30.3.1.5:7,
30.6.4:7,
30.6.9:5,
30.6.10.1:23</p>

<p><b>Proposed resolution:</b></p>

<p><i>[Beman provided specific wording for the proposed resolution.]</i></p>


<p>Change 27.2.3 Thread Safety [iostreams.threadsafety] paragraph 2:</p>

<p>If one thread makes a library call <tt>a</tt> that writes a value to a stream and, as a result, another thread reads this value from the stream through a library call <tt>b</tt> such that this does not result in a data race, then <tt>a</tt> <del>happens before</del> <ins>synchronizes with</ins> <tt>b</tt>.</p>

<p>Change 30.3.1.2 thread constructors [thread.thread.constr] paragraph 6:</p>

<p><i>Synchronization:</i> The invocation of the constructor <del>happens before</del> <ins>synchronizes with</ins> the invocation of the copy of <tt>f</tt>.</p>

<p>Change 30.3.1.5 thread members [thread.thread.member] paragraph 7:</p>

<p><i>Synchronization:</i> The completion of the thread represented by <tt>*this</tt> <del>happens before</del> <ins>synchronizes with</ins> (1.10) <tt>join()</tt> <del>returns</del> <ins>returning</ins>. [ Note: Operations on <tt>*this</tt> are not synchronized. end note ]</p>

<p>Change 30.6.4 Associated asynchronous state [futures.state] paragraph 7:</p>

<p>Calls to functions that successfully set the stored result of an associated asynchronous state synchronize
with (1.10) calls to functions successfully detecting the ready state resulting from that setting. The storage of the result (whether normal or exceptional) into the associated asynchronous state <del>happens before</del> <ins>synchronizes with</ins> (1.10) that state <del>is</del> <ins>being</ins> set to ready.</p>

<p>Change 30.6.9 Function template async [futures.async] paragraph 5:</p>

<p><i>Synchronization:</i> the invocation of <tt>async</tt> <del>happens before</del> <ins>synchronizes with</ins> (1.10) the invocation of <tt>f</tt>. [ Note: this
statement applies even when the corresponding future object is moved to another thread. end
note ] If the invocation is not deferred, a call to a waiting function on an asynchronous return object
that shares the associated asynchronous state created by this async call shall block until the associated
thread has completed. If the invocation is not deferred, the <tt>join()</tt> on the created thread <del>happens before</del> <ins>synchronizes with</ins>
(1.10) the first function that successfully detects the ready status of the associated asynchronous
state returns or before the function that gives up the last reference to the associated asynchronous
state returns, whichever happens first. If the invocation is deferred, the completion of the invocation
of the deferred function <del>happens before</del> <ins>synchronizes with</ins> the calls to the waiting functions return.</p>

<p>Change 30.6.10.1 packaged_task member functions [futures.task.members] paragraph 23:</p>

<p><i>Synchronization:</i> a successful call to <tt>operator()</tt> synchronizes with (1.10) a call to any member function of a <tt>future</tt>, <tt>shared_future</tt>, or <tt>atomic_future</tt> object that shares the associated asynchronous
state of <tt>*this</tt>. The completion of the invocation of the stored task and the storage of the result
(whether normal or exceptional) into the associated asynchronous state <del>happens before</del> <ins>synchronizes with</ins> (1.10) the
state <del>is</del> <ins>being</ins> set to ready. [ Note: <tt>operator()</tt> synchronizes and serializes with other functions through the
associated asynchronous state. end note ]</p>






<hr>
<h3><a name="1445"></a>1445. [FCD] Several iostreams member functions incorrectly specified</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS/PJ Plauger <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#iostream.format">active issues</a> in [iostream.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-137</b></p>

Several iostreams member functions are incorrectly
specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3168.htm">n3168</a>.





<hr>
<h3><a name="1446"></a>1446. [FCD] Move and swap for I/O streams</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#iostream.format">active issues</a> in [iostream.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-138</b></p>

For istreams and ostreams, the move-constructor does
not move-construct, the move-assignment operator does
not move-assign, and the swap function does not swap
because these operations do not manage the <tt>rdbuf()</tt>
pointer. Useful applications of these operations are
prevented both by their incorrect semantics and because
they are protected.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
In short: reverse the resolution of issue 900, then
change the semantics to move and swap the
<tt>rdbuf()</tt> pointer. Add a new protected constructor
that takes an rvalue reference to a stream and a
pointer to a streambuf, a new protected <tt>assign()</tt>
operator that takes the same arguments, and a
new protected <tt>partial_swap()</tt> function that doesn't
swap <tt>rdbuf()</tt>.
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a>.





<hr>
<h3><a name="1447"></a>1447. [FCD] Request to resolve issue LWG 1328</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#iostream.format">active issues</a> in [iostream.format].</p>
<p><b>View all other</b> <a href="lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-139</b></p>

Resolve issue LWG 1328 one way or the other, but
preferably in the direction outlined in the proposed
resolution, which, however, is not complete as-is: in any
case, the sentry must not set ok_ = false if is.good() ==
false, otherwise istream::seekg, being an unformatted
input function, does not take any action because the
sentry object returns false when converted to type bool.
Thus, it remains impossible to seek away from end of file.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1448"></a>1448. [FCD] Concerns about <tt>basic_stringbuf::str(basic_string)</tt> postconditions</h3>
<p><b>Section:</b> 27.8.1.3 [stringbuf.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-124</b></p>

N3092 27.8.1.3 Member functions contains this text
specifying the postconditions of
basic_stringbuf::str(basic_string):<BR/>
"Postconditions: If mode &amp; ios_base::out is true, pbase()
points to the first underlying character and epptr() &gt;=
pbase() + s.size() holds; in addition, if mode &amp;
ios_base::in is true, pptr() == pbase() + s.data() holds,
otherwise pptr() == pbase() is true. [...]"<BR/>
Firstly, there's a simple mistake: It should be pbase() +
s.length(), not pbase() + s.data().<BR/>
Secondly, it doesn't match existing implementations. As
far as I can tell, GCC 4.5 does not test for mode &amp;
ios_base::in in the second part of that sentence, but for
mode &amp; (ios_base::app | ios_base_ate), and Visual C++ 9
for mode &amp; ios_base::app. Besides, the wording of the
C++0x draft doesn't make any sense to me. I suggest
changing the second part of the sentence to one of the
following:<BR/>
Replace ios_base::in with (ios_base::ate | ios_base::app),
but this would require Visual C++ to change (replacing
only with ios_base::ate would require GCC to change, and
would make ios_base::app completely useless with
stringstreams):<BR/>
in addition, if mode &amp; (ios_base::ate | ios_base::app) is
true, pptr() == pbase() + s.length() holds, otherwise pptr()
== pbase() is true.<BR/>
Leave pptr() unspecified if mode &amp; ios_base::app, but not
mode &amp; ios_base::ate (implementations already differ in
this case, and it's always possible to use ios_base::ate to
get the effect of appending, so it's not necessary to
require any implementation to change):
in addition, if mode &amp; ios_base::ate is true, pptr() ==
pbase() + s.length() holds, if neither mode &amp; ios_base::ate
nor mode &amp; ios_base::app is true, pptr() == pbase() holds,
otherwise pptr() &gt;= pbase() &amp;&amp; pptr() &lt;= pbase() +
s.length() (which of the values in this range is
unspecified).<BR/>
Slightly stricter:<BR/>
in addition, if mode &amp; ios_base::ate is true, pptr() ==
pbase() + s.length() holds, if neither mode &amp; ios_base::ate
nor mode &amp; ios_base::app is true, pptr() == pbase() holds,
otherwise pptr() == pbase() || pptr() == pbase() +
s.length() (which of these two values is unspecified).
A small table might help to better explain the three cases.
BTW, at the end of the postconditions is this text: "egptr()
== eback() + s.size() hold". Is there a perference for
basic_string::length or basic_string::size? It doesn't really
matter, but it looks a bit inconsistent.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1450"></a>1450. [FCD] Contradiction in regex_constants</h3>
<p><b>Section:</b> 28.5.2 [re.matchflag] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-127</b></p>

The Bitmask Type requirements in 17.5.2.1.3 [bitmask.types] p.3 say that
all elements on a bitmask type have distinct values, but
28.5.2 [re.matchflag] defines <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> as elements of the
bitmask type <tt>regex_constants::match_flag_type</tt>, both with
value 0. This is a contradiction.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
One of the bitmask elements should be removed
from the declaration and should be defined
separately, in the same manner as
<tt>ios_base::adjustfield</tt>, <tt>ios_base::basefield</tt> and
<tt>ios_base::floatfield</tt> are defined by 27.5.2.1.2 [ios::fmtflags] p.2
and Table 120. These are constants of a bitmask
type, but are not distinct elements, they have
more than one value set in the bitmask.
<tt>regex_constants::format_default</tt> should be
specified as a constant with the same value as
<tt>regex_constants::match_default</tt>.
</blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>

<p>
Strictly speaking, a bitmask type cannot have any element of value 0 at all, because
any such value would contradict the requirement expressed in 17.5.2.1.3 [bitmask.types] p. 3:
<blockquote>
for any pair <em>Ci</em> and <em>Cj</em>, <em>Ci</em> &amp; <em>Ci</em> is nonzero
</blockquote>
So, actually <em>both</em> <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> are only constants of the type
<tt>regex_constants::match_flag_type</tt>, and no bitmask elements.
</p>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The proposed resolution is written against N3126 and considered as a further improvement
of the fixes suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.
</p>


<p><b>Proposed resolution:</b></p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
<blockquote>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
Matching a regular expression against a sequence of characters [first,last) proceeds according to the
rules of the grammar specified for the regular expression object, modified according to the effects listed in
Table 136 for any bitmask elements set. <ins>Type <tt>regex_constants::match_flag_type</tt> also defines the 
constants <tt>regex_constants::match_default</tt> and <tt>regex_constants::format_default</tt>.</ins>
</blockquote>





<hr>
<h3><a name="1452"></a>1452. [FCD] "target sequence" is not defined</h3>
<p><b>Section:</b> 28.10.3 [re.results.acc] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.acc">active issues</a> in [re.results.acc].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.acc">issues</a> in [re.results.acc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-125</b></p>

The term "target sequence" is not defined (28.10.3 [re.results.acc] p. 2).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Replace "target sequence" with "string being searched/matched"
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<p>
The proposed resolution looks incomplete to me, there are more normative
usages of the term <em>target sequence</em> in clause 28, e.g.
28.12.2 [re.tokiter] p. 7.
</p>



<p><b>Proposed resolution:</b></p>
Wording changes are against N3126. They are intended not to conflict with the wording changes
suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.
<p/>
Change 28.10.3 [re.results.acc] p. 2 as indicated:
<blockquote><pre>
difference_type position(size_type sub = 0) const;
</pre><blockquote>
2 <em>Returns</em>: The distance from the start of the <del>target sequence</del><ins>string being matched</ins> to <tt>(*this)[sub].first</tt>.
</blockquote></blockquote>





<hr>
<h3><a name="1453"></a>1453. [FCD] Default constructed match_results behavior for certain operations </h3>
<p><b>Section:</b> 28.10.3 [re.results.acc] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.acc">active issues</a> in [re.results.acc].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.acc">issues</a> in [re.results.acc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-126</b></p>

It's unclear how match_results should behave if it has
been default-constructed. The sub_match objects
returned by operator[], prefix and suffix cannot point to the
end of the sequence that was searched if no search was
done. The iterators held by unmatched sub_match objects
might be singular.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Add to match_results::operator[],
match_results::prefix and match_results::suffix:<BR/>
Requires: !empty()
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.





<hr>
<h3><a name="1455"></a>1455. [FCD] C language compatibility for atomics</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1454">1454</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-22, GB-128</b></p>
<p>
WG14 currently plans to introduce atomic facilities that are
intended to be compatible with the facilities of clause 29.
They should be compatible.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make sure the headers in clause 29 are defined in
a way that is compatible with the planned C
standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1456"></a>1456. [FCD] Missing fixed-size atomic_ typedefs</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>

Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as atomic_int_least8_t for int_least8_t, and
atomic_uint_fast64_t for uint_fast64_t. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs int8_t, int16_t, and so forth.

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Add the following entries to table 143:

<blockquote>
<table border="1">
<caption>Table 143 &mdash; Atomics for standard typedef types</caption>
<tr>
<th>atomic typedef name</th>
<th><tt>&lt;cstdint&gt;</tt> typedef name</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t</tt></ins></td>
<td><ins><tt>int8_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t</tt></ins></td>
<td><ins><tt>int16_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t</tt></ins></td>
<td><ins><tt>int32_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t</tt></ins></td>
<td><ins><tt>int64_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t</tt></ins></td>
<td><ins><tt>uint8_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t</tt></ins></td>
<td><ins><tt>uint16_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t</tt></ins></td>
<td><ins><tt>uint32_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t</tt></ins></td>
<td><ins><tt>uint64_t</tt> (optional)</ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1457"></a>1457. [FCD] Splitting lock-free properties</h3>
<p><b>Section:</b> 29.2 [atomics.syn] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-130</b></p>

The synopsis for the <tt>&lt;atomic&gt;</tt> header lists the macros
<tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> and <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>.
<p>
The <tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> macro has been replaced with a set of macros 
for each integral type, as listed in 29.4 [atomics.lockfree].
</p>


<p><i>[
2010-10-26: Daniel adds:
]</i></p>


<p>
The proposed resolution below is against the FCD working draft. After application
of the editorial issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US144">US-144</a>
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US146">US-146</a> the remaining difference
against the working draft is the usage of <em>implementation-defined</em> instead of <em>unspecified</em>, effectively
resulting in this delta:

<blockquote><pre>
// 29.4, lock-free property
#define ATOMIC_CHAR_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>
</p>

<p>
It is my understanding that the intended wording should be <em>unspecified</em> as for <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
but if this is right, we need to use the same wording in 29.4 [atomics.lockfree], which consequently uses
the term <em>implementation-defined</em>. I recommend to keep 29.2 [atomics.syn] as it currently is and to
fix 29.4 [atomics.lockfree] instead as indicated (against N3126):
</p>
<p>
New proposed resolution:
</p>
<p>
Change 29.4 [atomics.lockfree] as indicated:
<blockquote><pre>
#define ATOMIC_CHAR_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
</pre></blockquote>
</p>
<p><b>Proposed resolution:</b></p>
Against FCD, N3092:
<p>
In [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis replace as indicated:
</p>
<blockquote><pre>
// 29.4, lock-free property
<del>#define ATOMIC_INTEGRAL_LOCK_FREE <em>unspecified</em></del>
<ins>#define ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_INT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>






<hr>
<h3><a name="1459"></a>1459. [FCD] Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>

29.4 [atomics.lockfree] p.8 states:
<p><blockquote>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</blockquote></p>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<p><blockquote>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</blockquote></p>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 29.4 [atomics.lockfree] p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 29.4 [atomics.lockfree] p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
<PRE>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</PRE>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 1.9 [intro.execution] p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 29.4 [atomics.lockfree] p.8, then the execution above is not
permited. Is that really intended?

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1460"></a>1460. [FCD] Missing lock-free property for type <tt>bool</tt> should be added</h3>
<p><b>Section:</b> 29.4 [atomics.lockfree] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-154</b></p>

There is no <tt>ATOMIC_BOOL_LOCK_FREE</tt> macro.


<p><b>Proposed resolution:</b></p>
Add <tt>ATOMIC_BOOL_LOCK_FREE</tt> to 29.4 [atomics.lockfree] and to 29.2 [atomics.syn]:
<p>
<blockquote><pre>
[..]
<ins>#define ATOMIC_BOOL_LOCK_FREE <em>unspecified</em></ins>
#define ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
[..]
</pre></blockquote>
</p>





<hr>
<h3><a name="1461"></a>1461. [FCD] Rename all <tt>ATOMIC_*</tt> macros as <tt>STD_ATOMIC_*</tt></h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-1</b></p>

All <tt>ATOMIC_</tt>... macros should be prefixed with <tt>STD_</tt> as
in <tt>STD_ATOMIC_</tt>... to indicate they are <tt>STD</tt> macros as
other standard macros. The rationale that they all seem too long seems weak.


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change sub-clause 29.2 [atomics.syn] as indicated:
<p>
<blockquote><pre>
[..]
// <em>29.4, lock-free property</em>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>

// <em>29.6, operations on atomic types</em>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
[..]
</pre></blockquote>
</p>
</li>
<li>
Change 29.4 [atomics.lockfree] p. 1 as indicated:
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_ADDRESS_LOCK_FREE <em>implementation-defined</em>
</pre><blockquote>
1 The <tt><ins>STD_</ins>ATOMIC_..._LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, [..]
</blockquote></blockquote>
</li>
<li>
Change 29.6 [atomics.types.operations] p. 5 as indicated:
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
</pre><blockquote>
5 <em>Remarks</em>: A macro that expands to a token sequence suitable for initializing an atomic variable of
a type that is initializion-compatible with value. Concurrent access to the variable being initialized,
even via an atomic operation, constitutes a data race. [ <em>Example:</em>
<blockquote><pre>
atomic_int v = <ins>STD_</ins>ATOMIC_VAR_INIT(5);
</pre></blockquote>
&mdash; <em>end example</em> ]
</blockquote></blockquote>
</li>
<li>
Change 29.7 [atomics.flag] p. 1+4 as indicated:
<blockquote><pre>
namespace std {
  [..]
  #define <ins>STD_</ins>ATOMIC_FLAG_INIT <em>see below</em>
}
</pre><blockquote>
[..]
4 The macro <tt><ins>STD_</ins>ATOMIC_FLAG_INIT</tt> shall be defined in such a way that it can be used to initialize an object of
type <tt>atomic_flag</tt> to the clear state. For a static-duration object, that initialization shall be static. It is
unspecified whether an unitialized <tt>atomic_flag</tt> object has an initial state of set or clear. [ <em>Example:</em>
<blockquote><pre>
atomic_flag guard = <ins>STD_</ins>ATOMIC_FLAG_INIT;
</pre></blockquote>
&mdash; <em>end example</em> ]
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1462"></a>1462. [FCD] Ambiguous value assignment to <tt>atomic_bool</tt></h3>
<p><b>Section:</b> 29.5.1 [atomics.types.integral] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.integral">active issues</a> in [atomics.types.integral].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1463">1463</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-132, US-157</b></p>

The <tt>atomic_<em>itype</em></tt> types and <tt>atomic_address</tt> have two
overloads of <tt>operator=</tt>; one is <tt>volatile</tt> qualified, and the
other is not. <tt>atomic_bool</tt> only has the <tt>volatile</tt> qualified
version:
<pre><blockquote>
bool operator=(bool) volatile;
</blockquote></pre>
On a non-<tt>volatile</tt>-qualified object this is ambiguous with
the deleted copy-assignment operator
<pre><blockquote>
atomic_bool&amp; operator=(atomic_bool const&amp;) = delete;
</blockquote></pre>
due to the need for a single standard conversion in each
case when assigning a bool to an <tt>atomic_bool</tt> as in:
<pre><blockquote>
atomic_bool b;
b = true;
</blockquote></pre>
The conversions are: 
<pre><blockquote>
atomic_bool&amp; &rarr; atomic_bool volatile&amp;
</blockquote></pre>
 vs 
<pre><blockquote>
bool &rarr; atomic_bool
</blockquote></pre>

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue
by replacing <tt>atomic_bool</tt> by <tt>atomic&lt;bool&gt;</tt>.
</blockquote>


<p><b>Proposed resolution:</b></p>
Change 29.5.1 [atomics.types.integral] as indicated:

<blockquote><pre>
namespace std {
  typedef struct atomic_bool {
    [..]
    bool operator=(bool) volatile;
    <ins>bool operator=(bool);</ins>
  } atomic_bool;
  [..]
}
</pre></blockquote>





<hr>
<h3><a name="1464"></a>1464. [FCD] Underspecified typedefs for atomic integral types</h3>
<p><b>Section:</b> 29.5.1 [atomics.types.integral] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.integral">active issues</a> in [atomics.types.integral].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-160</b></p>

The last sentence of 29.5.1 [atomics.types.integral] p.1 says:
<blockquote><p>
Table 143 shows typedefs to atomic integral classes and the corresponding <tt>&lt;cstdint&gt;</tt> typedefs.
</p></blockquote>
That's nice, but nothing says these are supposed to be part of the implementation, and
they are not listed in the synopsis.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>Remove Table 143 &mdash; Atomics for standard typedef types.
<p>
</p>
</li>
<li>Change 29.5.1 [atomics.types.integral] p.1 as indicated:
<blockquote><p>
1 The name <tt>atomic_<em>itype</em></tt> and the functions operating on it in the preceding synopsis are placeholders for a
set of classes and functions. Throughout the preceding synopsis, <tt>atomic_<em>itype</em></tt> should be replaced by each
of the class names in Table 142 and integral should be replaced by the integral type corresponding to the
class name. <del>Table 143 shows typedefs to atomic integral classes and the corresponding <tt>&lt;cstdint&gt;</tt> typedefs.</del>
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="1465"></a>1465. [FCD] Missing arithmetic operators for <tt>atomic_address</tt></h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.address">active issues</a> in [atomics.types.address].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-161</b></p>

<tt>atomic_address</tt> has <tt>operator+=</tt> and <tt>operator-=</tt>, but no
<tt>operator++</tt> or <tt>operator--</tt>. The template specialization
<tt>atomic&lt;Ty*&gt;</tt> has all of them.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
replacing <tt>atomic_address</tt> by <tt>atomic&lt;void*&gt;</tt>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Change 29.5.2 [atomics.types.address], class <tt>atomic_address</tt> synopsis, as indicated:
<blockquote><pre>
namespace std {
  typedef struct atomic_address {
    [..]
    void* operator=(const void*) volatile;
    void* operator=(const void*);
    <ins>void* operator++(int) volatile;</ins>
    <ins>void* operator++(int);</ins>
    <ins>void* operator--(int) volatile;</ins>
    <ins>void* operator--(int);</ins>
    <ins>void* operator++() volatile;</ins>
    <ins>void* operator++();</ins>
    <ins>void* operator--() volatile;</ins>
    <ins>void* operator--();</ins>
    void* operator+=(ptrdiff_t) volatile;
    void* operator+=(ptrdiff_t);
    void* operator-=(ptrdiff_t) volatile;
    void* operator-=(ptrdiff_t);
  } atomic_address;
  [..]
}
</pre></blockquote>
</p>






<hr>
<h3><a name="1466"></a>1466. [FCD] Silent <tt>const</tt> breakage by <tt>compare_exchange_*</tt> member functions</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.address">active issues</a> in [atomics.types.address].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-162</b></p>

The <tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> member functions that take
<tt>const void*</tt> arguments lead to a silent removal of <tt>const</tt>, because the <tt>load</tt> 
member function and other acessors return the stored value as a <tt>void*</tt>.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> 
would solve this issue by replacing <tt>atomic_address</tt> by <tt>atomic&lt;void*&gt;</tt>.
</blockquote>


<p><b>Proposed resolution:</b></p>
Change 29.5.2 [atomics.types.address], class <tt>atomic_address</tt> synopsis, as indicated:

<blockquote><pre>
namespace std {
  typedef struct atomic_address {
    [..]
    <del>bool compare_exchange_weak(const void*&, const void*,
      memory_order, memory_order) volatile;</del>
    <del>bool compare_exchange_weak(const void*&, const void*,
      memory_order, memory_order);</del>
    <del>bool compare_exchange_strong(const void*&, const void*,
      memory_order, memory_order) volatile;</del>
    <del>bool compare_exchange_strong(const void*&, const void*,
      memory_order, memory_order);</del>
    <del>bool compare_exchange_weak(const void*&, const void*,
      memory_order = memory_order_seq_cst) volatile;</del>
    <del>bool compare_exchange_weak(const void*&, const void*,
      memory_order = memory_order_seq_cst);</del>
    <del>bool compare_exchange_strong(const void*&, const void*,
      memory_order = memory_order_seq_cst) volatile;</del>
    <del>bool compare_exchange_strong(const void*&, const void*,
      memory_order = memory_order_seq_cst);</del>
    [..]
  } atomic_address;
  [..]
}
</pre></blockquote>





<hr>
<h3><a name="1467"></a>1467. [FCD] Deriving <tt>atomic&lt;T*&gt;</tt> from <tt>atomic_address</tt> breaks type safety</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.address">active issues</a> in [atomics.types.address].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-163</b></p>

Requiring <tt>atomic&lt;T*&gt;</tt> to be derived from <tt>atomic_address</tt> breaks type safety:
<blockquote><pre>
atomic&lt;double*&gt; ip;
char ch;
atomic_store(&amp;ip, &amp;ch);
*ip.load() = 3.14159;
</pre></blockquote>
The last line overwrites <tt>ch</tt> with a value of type <tt>double</tt>.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
Resolving this issue will also solve 1469<a href="lwg-active.html#1469">1469</a>
</p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
removing <tt>atomic_address</tt>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.5.3 [atomics.types.generic], class template specialization <tt>atomic&lt;T*&gt;</tt> synopsis, as indicated:
<blockquote><pre>
namespace std {
  template &lt;class T&gt; struct atomic&lt;T*&gt; <del>: atomic_address</del> {
    [..]
  };
  [..]
}
</pre></blockquote>
</li>
<li>Change 29.5.3 [atomics.types.generic] p. 4 as indicated:
<p><blockquote>
4 There are pointer partial specializations on the <tt>atomic</tt> class template. <del>These specializations shall be publicly
derived from <tt>atomic_address</tt>.</del> The unit of addition/subtraction for these specializations shall be the size
of the referenced type. These specializations shall have trivial default constructors and trivial destructors.
</blockquote></p>
</li>
</ol>






<hr>
<h3><a name="1468"></a>1468. [FCD] <tt>atomic_address::compare_exchange_*</tt> member functions should match <tt>atomic_compare_exchange_*</tt> free functions</h3>
<p><b>Section:</b> 29.5.2 [atomics.types.address] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.address">active issues</a> in [atomics.types.address].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.address">issues</a> in [atomics.types.address].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-164</b></p>

<tt>atomic_address</tt> has member functions <tt>compare_exchange_weak</tt> and
<tt>compare_exchange_strong</tt> that take arguments of type <tt>const void*</tt>, 
in addition to the <tt>void*</tt> versions. If these member functions survive, 
there should be corresponding free functions.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue 
differently by removing the overloads with <tt>const void*</tt> arguments, because they break type-safety.
</blockquote>


<p><b>Proposed resolution:</b></p>
Extend the synopsis around <tt>atomic_address</tt> in 29.5.2 [atomics.types.address]
as indicated:
<blockquote><pre>
namespace std {
  [..]
  bool atomic_compare_exchange_weak(volatile atomic_address*, void**, void*);
  bool atomic_compare_exchange_weak(atomic_address*, void**, void*);
  bool atomic_compare_exchange_strong(volatile atomic_address*, void**, void*);
  bool atomic_compare_exchange_strong(atomic_address*, void**, void*);
  bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_weak_explicit(atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, void**, void*,
    memory_order, memory_order);
  bool atomic_compare_exchange_strong_explicit(atomic_address*, void**, void*,
    memory_order, memory_order);
  <ins>bool atomic_compare_exchange_weak(volatile atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_weak(atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_strong(volatile atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_strong(atomic_address*, const void**, const void*);</ins>
  <ins>bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_weak_explicit(atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  <ins>bool atomic_compare_exchange_strong_explicit(atomic_address*, const void**, const void*,
    memory_order, memory_order);</ins>
  [..]
}
</pre></blockquote>






<hr>
<h3><a name="1469"></a>1469. [FCD] <tt>atomic&lt;T*&gt;</tt> inheritance from <tt>atomic_address</tt> breaks type safety</h3>
<p><b>Section:</b> 29.5.3 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-133</b></p>

The free functions that operate on <tt>atomic_address</tt> can be
used to store a pointer to an unrelated type in an <tt>atomic&lt;T*&gt;</tt> 
without a cast. e.g.
<blockquote><pre>
int i;
atomic&lt;int*&gt; ai(&amp;i);
string s;
atomic_store(&amp;ai,&amp;s);
</pre></blockquote>
Overload the <tt>atomic_store</tt>, <tt>atomic_exchange</tt> and
<tt>atomic_compare_exchange_[weak/strong]</tt> operations for 
<tt>atomic&lt;T*&gt;</tt> to allow storing only pointers to <tt>T</tt>.

<p><i>[
2010-10-27 Daniel adds:
]</i></p>


<blockquote>
<p>
Resolving this issue will also solve 1467<a href="lwg-active.html#1467">1467</a>
</p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue by
removing <tt>atomic_address</tt>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Add the following overloads to 29.5.3 [atomics.types.generic], the synopsis around the specialization
<tt>atomic&lt;T*&gt;</tt>, as indicated:
<blockquote><pre>
namespace std {
  [..]
  template &lt;class T&gt; struct atomic&lt;T*&gt; : atomic_address {
    [..]
  };

  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store(atomic&lt;T*&gt;&amp;,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store(atomic&lt;T*&gt;&amp;,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store_explicit(atomic&lt;T*&gt;&amp;,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>void atomic_store_explicit(atomic&lt;T*&gt;&amp;,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange(atomic&lt;T*&gt;&amp;,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange(atomic&lt;T*&gt;&amp;,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_exchange_explicit(atomic&lt;T*&gt;&amp;,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,T**,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak(atomic&lt;T*&gt;&amp;,void**,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak_explicit(atomic&lt;T*&gt;&amp;,T**,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_weak_explicit(atomic&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,T**,T*);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong(atomic&lt;T*&gt;&amp;,void**,void*) = delete;</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong_explicit(atomic&lt;T*&gt;&amp;,T**,T*,memory_order);</ins>
  <ins>template&lt;typename T&gt;</ins>
  <ins>T* atomic_compare_exchange_strong_explicit(atomic&lt;T*&gt;&amp;,void**,void*,memory_order) = delete;</ins>

}
</pre></blockquote>
</p>





<hr>
<h3><a name="1471"></a>1471. [FCD] Default constructor of atomics needs specification</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-168</b></p>

29.6 [atomics.types.operations] around p. 4: The definition of the default constructor needs exposition.


<p><b>Proposed resolution:</b></p>
Insert a new general prototype description following the current 29.6 [atomics.types.operations] p. 3 as indicated:
<p>
</p>
<blockquote>
3 [<em>Note</em>: Many operations are volatile-qualified. The volatile as device register semantics have not changed
in the standard. This qualification means that volatility is preserved when applying these operations to
volatile objects. It does not mean that operations on non-volatile objects become volatile. Thus, volatile
qualified operations on non-volatile objects may be merged under some conditions. &mdash; <em>end note</em>]
</blockquote>
<blockquote><pre>
<ins>A::A() = default;</ins>
</pre><blockquote>
<ins>? <em>Effects</em>: Leaves the atomic object in an uninitialized state.
[<em>Note</em>: These semantics ensure compatiblity with <tt>C</tt>. &mdash; <em>end note</em>]</ins>
</blockquote></blockquote>
<blockquote><pre>
constexpr A::A(C desired);
[..]
</pre></blockquote>





<hr>
<h3><a name="1472"></a>1472. [FCD] Incorrect semantics of <tt>atomic_init</tt></h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-171</b></p>

As of 29.6 [atomics.types.operations] p. 7:
<p/>
The <tt>atomic_init</tt> definition "Non-atomically assigns the
value" is not quite correct, as the <tt>atomic_init</tt> purpose is
initialization.


<p><b>Proposed resolution:</b></p>
Change  29.6 [atomics.types.operations] p. 7 as indicated:
<blockquote><pre>
void atomic_init(volatile A *object, C desired);
void atomic_init(A *object, C desired);
</pre><blockquote>
7 <em>Effects</em>: <del>Non-atomically assigns the value desired to <tt>*object</tt></del><ins>Initializes <tt>*object</tt> with value
<tt>desired</tt></ins>. Concurrent access from another thread, even via an atomic operation, constitutes a data race.
<ins>[<em>Note</em>: This function should only be applied to objects that have been default constructed. These semantics ensure
compatibility with <tt>C</tt>. &mdash; <em>end note</em>]</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1473"></a>1473. [FCD] Incomplete memory order specifications</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-172</b></p>

As of 29.6 [atomics.types.operations] p. 9, 13, 17, 20:
<p/>
The order specifications are incomplete because the non-<tt>_explicit</tt>
functions do not have such parameters.
<p/>
Add a new sentence: "If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>." Or perhaps: "The non-_explicit
non-member functions shall affect memory as though they were _explicit with
<tt>memory_order_seq_cst</tt>."



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.6 [atomics.types.operations] p. 9 as indicated:
<blockquote><pre>
void atomic_store(volatile A* object, C desired);
void atomic_store(A* object, C desired);
void atomic_store_explicit(volatile A *object, C desired, memory_order order);
void atomic_store_explicit(A* object, C desired, memory_order order);
void A::store(C desired, memory_order order = memory_order_seq_cst) volatile;
void A::store(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote>
8 <em>Requires</em>: The order argument shall not be <tt>memory_order_consume</tt>, <tt>memory_order_acquire</tt>, nor
<tt>memory_order_acq_rel</tt>.
<p/>
9 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by this with the value of <tt>desired</tt>.
Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
</blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 13 as indicated:
<blockquote><pre>
C atomic_load(const volatile A* object);
C atomic_load(const A* object);
C atomic_load_explicit(const volatile A* object, memory_order);
C atomic_load_explicit(const A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) const volatile;
C A::load(memory_order order = memory_order_seq_cst) const;
</pre><blockquote>
12 <em>Requires</em>: The order argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
<p/>
13 <em>Effects</em>: Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
<p/>
14 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt>.
</blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 17 as indicated:
<blockquote><pre>
C atomic_exchange(volatile A* object, C desired);
C atomic_exchange(A* object, C desired);
C atomic_exchange_explicit(volatile A* object, C desired, memory_order);
C atomic_exchange_explicit(A* object, C desired, memory_order);
C A::exchange(C desired, memory_order order = memory_order_seq_cst) volatile;
C A::exchange(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote>
17 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by <tt>this</tt> with <tt>desired</tt>. Memory
is affected according to the value of <tt>order</tt>. These operations are atomic read-modify-write operations
(1.10). <ins>If the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins>
<p/>
18 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt> immediately before the effects.
</blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 20 as indicated:
<blockquote><pre>
bool atomic_compare_exchange_weak(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_weak(A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(A* object, C * expected, C desired);
bool atomic_compare_exchange_weak_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_weak_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
</pre><blockquote>
19 <em>Requires</em>: The <tt>failure</tt> argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
The <tt>failure</tt> argument shall be no stronger than the success argument.
<p/>
20 <em>Effects</em>: Atomically, compares the contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt> for equality
with that in <tt>expected</tt>, and if true, replaces the contents of the memory pointed to by <tt>object</tt> or by
<tt>this</tt> with that in <tt>desired</tt>, and if false, updates the contents of the memory in expected with the
contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true, memory
is affected according to the value of <tt>success</tt>, and if the comparison is false, memory is affected
according to the value of <tt>failure</tt>. When only one <tt>memory_order</tt> argument is supplied, the value of
<tt>success</tt> is <tt>order</tt>, and the value of <tt>failure</tt> is <tt>order</tt> except that a value of 
<tt>memory_order_acq_rel</tt> shall be replaced by the value <tt>memory_order_acquire</tt> and a value of 
<tt>memory_order_release</tt> shall be replaced by the value <tt>memory_order_relaxed</tt>. <ins>If 
the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins> If the operation returns <tt>true</tt>, 
these operations are atomic read-modify-write operations (1.10). Otherwise, these operations are atomic load operations.
<p/>
[..]
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1474"></a>1474. [FCD] weak compare-and-exchange confusion</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1470">1470</a>, <a href="lwg-closed.html#1475">1475</a>, <a href="lwg-closed.html#1476">1476</a>, <a href="lwg-closed.html#1477">1477</a></p>
<p><b>Discussion:</b></p>



<p><b>Addresses US-175, US-165, CH-23, GB-135</b></p>

29.6 [atomics.types.operations] p. 23: The first sentence is grammatically incorrect.

<p><i>[
2010-10-28 Daniel adds:
]</i></p>

<p>
Proposed resolution of duplicate issue 1475<a href="lwg-closed.html#1475">1475</a>:
</p>
Change 29.6 [atomics.types.operations] p. 23 as indicated:
<blockquote>
23 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>The weak 
compare-and-exchange operations may fail spuriously, that is, return false while leaving the contents of memory 
pointed to by <tt>expected</tt> unchanged.</ins>. [ <em>Note</em>: This spurious failure enables implementation of 
compare-and-exchange on a broader class of machines, e.g., loadlocked store-conditional machines. A consequence of 
spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</blockquote>


<p><b>Proposed resolution:</b></p>
Change 29.6 [atomics.types.operations] p. 23 as indicated:
<blockquote>
23 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>The weak
compare-and-exchange operations may fail spuriously. That is, it may return false while leaving the contents of 
memory pointed to by <tt>expected</tt> the same as it was before the operation</ins>. [ <em>Note</em>: This spurious
failure enables implementation of compare-and-exchange on a broader class of machines, e.g., loadlocked
store-conditional machines. A consequence of spurious failure is that nearly all uses of weak
compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</blockquote>





<hr>
<h3><a name="1478"></a>1478. [FCD] Clarify race conditions in atomics initialization</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-136</b></p>

GB requests normative clarification in 29.6 [atomics.types.operations] p.4 that
concurrent access constitutes a race, as already done on p.6 and p.7.

<p><i>[
Resolution proposed in ballot comment:
]</i></p>


<blockquote>
Initialisation of atomics:
<p/>
We believe the intent is that for any atomics there is a distinguished
initialisation write, but that this need not happens-before all the
other operations on that atomic - specifically so that the
initialisation write might be non-atomic and hence give rise to a data
race, and hence undefined behaviour, in examples such as this (from
Hans):
<blockquote><pre>
atomic&lt;atomic&lt;int&gt; *&gt; p
f()                      |
{ atomic&lt;int&gt;x;          | W_na x
  p.store(&ampx,mo_rlx); | W_rlx p=&amp;x
}                        |
</pre></blockquote>
(where na is nonatomic and rlx is relaxed). We suspect also that no
other mixed atomic/nonatomic access to the same location is intended
to be permitted. Either way, a note would probably help.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1479"></a>1479. [FCD] Fence functions should be <tt>extern "C"</tt></h3>
<p><b>Section:</b> 29.8 [atomics.fences] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.fences">active issues</a> in [atomics.fences].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.fences">issues</a> in [atomics.fences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-179</b></p>

The fence functions (29.8 [atomics.fences] p.5 + p.6) should be <tt>extern "C"</tt>, for <tt>C</tt> compatibility.


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.2 [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis as indicated:
<blockquote><pre>
namespace std {
  [..]
  // <em>29.8, fences</em>
  <ins>extern "C"</ins> void atomic_thread_fence(memory_order);
  <ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
}
</pre></blockquote>
</li>
<li>Change 29.8 [atomics.fences], p. 5 and p. 6 as indicated:
<blockquote><pre>
<ins>extern "C"</ins> void atomic_thread_fence(memory_order);
</pre><blockquote>
5 <em>Effects</em>: depending on the value of <tt>order</tt>, this operation: [..]
</blockquote></blockquote>
<blockquote><pre>
<ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
</pre><blockquote>
6 <em>Effects</em>: equivalent to <tt>atomic_thread_fence(order)</tt>, except that synchronizes with relationships are
established only between a thread and a signal handler executed in the same thread.
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1480"></a>1480. [FCD] Atomic fences don't have <em>synchronizes with</em> relation</h3>
<p><b>Section:</b> 29.8 [atomics.fences] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-28</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.fences">active issues</a> in [atomics.fences].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.fences">issues</a> in [atomics.fences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-137</b></p>

Thread fence not only establish synchronizes with relationships,
there are semantics of fences that are expressed not in
terms of <em>synchronizes with</em> relationships (for example see 29.3 [atomics.order] p.5).
These semantics also need to apply to the use of
<tt>atomic_signal_fence</tt> in a restricted way.


<p><b>Proposed resolution:</b></p>
Change 29.8 [atomics.fences] p. 6 as indicated:
<blockquote><pre>
void atomic_signal_fence(memory_order);  
</pre><blockquote>
6 <em>Effects</em>: equivalent to <tt>atomic_thread_fence(order)</tt>, except that <del>synchronizes 
with relationships</del><ins>the resulting ordering constraints</ins> are established only between a 
thread and a signal handler executed in the same thread.
</blockquote></blockquote>





<hr>
<h3><a name="1481"></a>1481. [FCD] Missing Lockable requirements</h3>
<p><b>Section:</b> 30.2 [thread.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-138</b></p>

The FCD combines the requirements for lockable objects
with those for the standard mutex objects. These should
be separate. This is LWG issue 1268<a href="lwg-active.html#1268">1268</a>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
See attached Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> addresses
this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a>.





<hr>
<h3><a name="1482"></a>1482. [FCD] Timeout operations are under-specified</h3>
<p><b>Section:</b> 30.2.4 [thread.req.timing] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.req.timing">issues</a> in [thread.req.timing].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-181</b></p>

The timeout operations are under-specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Define precise semantics for <tt>timeout_until</tt> and <tt>timeout_for</tt>. See 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> page 193 - Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3128.html">n3128</a>.





<hr>
<h3><a name="1484"></a>1484. [FCD] Need way to join a thread with a timeout</h3>
<p><b>Section:</b> 30.3.1 [thread.thread.class] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-183</b></p>

There is no way to join a thread with a timeout.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Add <tt>join_for</tt> and <tt>join_until</tt>. Or decide one should
never join a thread with a timeout since <tt>pthread_join</tt> doesn't have a 
timeout version.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1485"></a>1485. [FCD] Unclear <tt>thread::id</tt> specification</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-184</b></p>

It is unclear when a <tt>thread::id</tt> ceases to be meaningful.
The sentence "The library may reuse the value of a
<tt>thread::id</tt> of a terminated thread that can no longer be
joined." implies that some terminated threads can be
joined. It says nothing about detached threads.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Require a unique <tt>thread::id</tt> for every thread that is
(1) detached and not terminated or (2) has an associated <tt>std::thread</tt> 
object.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1486"></a>1486. [FCD] Value of <tt>this_thread::get_id()</tt> underspecified for detached thread</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-24</b></p>

What would be the value <tt>this_thread::get_id()</tt> when called from a detached thread?

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add some text to clarify that get_id() still returns
the same value even after detaching.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1487"></a>1487. [FCD] Clock related operations exception specifications conflict</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-25</b></p>

Clock related operations are currently not required not to
throw. So "Throws: Nothing." is not always true.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Either require clock related operations not to throw
(in 20.10) or change the Throws clauses in 30.3.2.
Also possibly add a note that <tt>abs_time</tt> in the past
or negative <tt>rel_time</tt> is allowed.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1488"></a>1488. [FCD] Improve interoperability between
the C++0x and C1x threads APIs</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex">active issues</a> in [thread.mutex].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-185</b></p>

Cooperate with WG14 to improve interoperability between
the <tt>C++0x</tt> and <tt>C1x</tt> threads APIs. In particular, <tt>C1x</tt>
mutexes should be conveniently usable with a <tt>C++0x</tt>
<tt>lock_guard</tt>. Performance overheads for this combination
should be considered.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Remove <tt>C++0x</tt> <tt>timed_mutex</tt> and
<tt>timed_recursive_mutex</tt> if that facilitates
development of more compatible APIs.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1489"></a>1489. [FCD] <tt>unlock</tt> functions and unlock
mutex requirements are inconsistent</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex">active issues</a> in [thread.mutex].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-26</b></p>

Specifications of <tt>unlock</tt> member functions and <tt>unlock</tt>
mutex requirements are inconsistent wrt to exceptions and
pre- and postconditions.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
<tt>unlock</tt> should specifiy the precondition that the
current thread "owns the lock", this will make calls
without holding the locks "undefined behavior".
<tt>unlock</tt> in  [mutex.requirements] should either be
<tt>noexcept(true)</tt> or be allowed to throw
<tt>system_error</tt> like <tt>unique_lock::unlock</tt>, or the latter
should be <tt>nothrow(true)</tt> and have the precondition
<tt>owns == true</tt>.
Furthermore <tt>unique_lock</tt>'s postcondition is wrong
in the case of a recursive mutex where <tt>owns</tt>
might stay true, when it is not the last <tt>unlock</tt>
needed to be called.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1490"></a>1490. [FCD] Mutex requirements too stringent</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-27</b></p>

The mutex requirements force <tt>try_lock</tt> to be
<tt>noexcept(true)</tt>. However, where they are used by the
generic algorithms, those relax this requirement and say
that <tt>try_lock</tt> may throw. This means the requirement is
too stringent, also a non-throwing <tt>try_lock</tt> does not allow
for a diagnostic such as <tt>system_error</tt> that <tt>lock()</tt> 
will give us.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
delete p18, adjust 30.4.4 p1 and p4 accordingly
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a>.





<hr>
<h3><a name="1491"></a>1491. [FCD] <tt>try_lock</tt> does not guarantee forward progress</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-186</b></p>

<tt>try_lock</tt> does not provide a guarantee of forward progress
because it is allowed to spuriously fail.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
The standard mutex types must not fail spuriously
in <tt>try_lock</tt>. See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> page 205 - Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<blockquote>
Paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3152.html">n3152</a> addresses
this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3152.html">n3152</a>.





<hr>
<h3><a name="1492"></a>1492. [FCD] Mutex requirements should not be bound to threads</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-188</b></p>

Mutex requirements should not be bound to threads

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
See Appendix 1 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> - Additional Details, p. 208.
</blockquote>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a> would solve this issue.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3130.html">n3130</a>.





<hr>
<h3><a name="1493"></a>1493. [FCD] Add <tt>mutex</tt>, <tt>recursive_mutex</tt>, <tt>is_locked</tt> function</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-189</b></p>

<tt>mutex</tt> and <tt>recursive_mutex</tt> should have an <tt>is_locked()</tt>
member function. <tt>is_locked</tt> allows a user to test a lock
without acquiring it and can be used to implement a lightweight
<tt>try_try_lock</tt>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Add a member function:
<PRE>
bool is_locked() const;
</PRE>
to <tt>std::mutex</tt> and <tt>std::recursive_mutex</tt>. These
functions return true if the current thread would
not be able to obtain a mutex. These functions do
not synchronize with anything (and, thus, can
avoid a memory fence).
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1494"></a>1494. [FCD] Term "are serialized" not defined</h3>
<p><b>Section:</b> 30.4.5.2 [thread.once.callonce] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-190</b></p>

The term "are serialized" is never defined (30.4.5.2 [thread.once.callonce] p. 2).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Remove the sentence with "are serialized" from
paragraph 2. Add "Calls to <tt>call_once</tt> on the same
<tt>once_flag</tt> object shall not introduce data races
(17.6.4.8)." to paragraph 3.
</p>

<p><i>[
2010-11-01 Daniel translates NB comment into wording
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 30.4.5.2 [thread.once.callonce] p.2+3 as indicated:
<blockquote><pre>
template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args);
</pre><blockquote>
[..]
<p/>
2 <em>Effects</em>: <del>Calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object are serialized.</del>
If there has been a prior effective call to <tt>call_once</tt> on the same <tt>once_flag object</tt>, 
the call to <tt>call_once</tt> returns without invoking <tt>func</tt>. If there has been no prior 
effective call to <tt>call_once</tt> on the same <tt>once_flag</tt> object,
<tt>INVOKE(decay_copy( std::forward&lt;Callable&gt;(func)), decay_copy(std::forward&lt;Args&gt;(args))...)</tt>
is executed. The call to <tt>call_once</tt> is effective if and only if 
<tt>INVOKE(decay_copy( std::forward&lt;Callable&gt;(func)), decay_copy(std::forward&lt;Args&gt;(args))...)</tt> 
returns without throwing an exception. If an exception is thrown it is propagated to the caller.
<p/>
3 <em>Synchronization</em>: The completion of an effective call to <tt>call_once</tt> on a <tt>once_flag</tt> 
object synchronizes with (1.10) all subsequent calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object.
<ins>Calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object shall not introduce data races ([res.on.data.races]).</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1495"></a>1495. [FCD] Condition variable <tt>wait_for</tt> return insufficient</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition">active issues</a> in [thread.condition].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-191</b></p>

The condition variable <tt>wait_for</tt> returning <tt>cv_status</tt> is insufficient.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Return a duration of timeout remaining instead.
See Appendix 1 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> - Additional Details, p. 211
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1496"></a>1496. [FCD] <tt>condition_variable</tt> not implementable</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition.condvar">active issues</a> in [thread.condition.condvar].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-28</b></p>

Requiring wait_until makes it impossible to implement
condition_variable correctly using respective objects
provided by the operating system (i.e. implementing the
native_handle() function) on many platforms (e.g. POSIX,
Windows, MacOS X) or using the same object as for the
condition variable proposed for C.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Remove the <tt>wait_until</tt> functions or make them at least conditionally supported.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1499"></a>1499. [FCD] Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.condition">active issues</a> in [thread.condition].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

Condition variables preclude a wakeup optimization.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1501"></a>1501. [FCD] spec for managing associated asynchronous
state has problems</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures">active issues</a> in [futures].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-194</b></p>

The specification for managing associated asynchronous
state is confusing, sometimes omitted, and redundantly
specified.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Define terms-of-art for releasing, making ready,
and abandoning an associated asynchronous
state. Use those terms where appropriate. See
Appendix 1 - Additional Details
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1502"></a>1502. [FCD] Specification of [futures.state]</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.state">active issues</a> in [futures.state].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-195</b></p>

The intent and meaning of the paragraph is not apparent.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1503"></a>1503. [FCD] "associated asynchronous state" must go</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.state">active issues</a> in [futures.state].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-35</b></p>

The term "associated asynchronous state" is long, ugly
and misleading terminology. When introduced we agreed
upon that we should come up with a better name. Here it
is: "liaison state". Since the state is hidden and provides
synchronization of a future with its corresponding promise,
we believe "liaison state" is a much better and shorter
name (liaison ~ (typically hidden) relationship)

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change all occurrences of "associated
asynchronous state" to "liaison state".
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1504"></a>1504. [FCD] Term "are serialized" is not defined</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-196</b></p>

The term "are serialized" is not defined (30.6.5 [futures.promise] p. 21, 25).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replace "are serialized" with "shall not introduce a data race (17.6.4.8)".
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1505"></a>1505. [FCD] Synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-197</b></p>

There is no defined synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt> (30.6.5 [futures.promise] p. 21, 25).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replace "[Note: and they synchronize and
serialize with other functions through the referred
associated asynchronous state. --end note]" with
the normative "They synchronize with (1.10) any
operation on a future object with the same
associated asynchronous state marked ready."
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1507"></a>1507. [FCD] <tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-199</b></p>

<tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements. Specifying synchronization
for these member functions requires coordinating with the
words in 30.6.5/21 and 25, which give synchronization
requirements for <tt>promise::set_value</tt> and
<tt>promise::set_exception</tt> (30.6.5 [futures.promise] p. 26 ff., p. 29 ff.).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change 30.6.5/21 to mention
set_value_at_thread_exit and
set_exception_at_thread_exit; with this text,
replace 30.6.5/25 and add two new paragraphs,
after 30.6.5/28 and 30.6.5/31.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1508"></a>1508. [FCD] Rename <tt>packaged_task::operator bool()</tt></h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-201</b></p>
<p>
<tt>packaged_task</tt> provides <tt>operator bool()</tt> to check whether
an object has an associated asynchronous state. The various <tt>future</tt> 
types provide a member function <tt>valid()</tt> that does the same thing. 
The names of these members should be the same.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replaced the name <tt>packaged_task::operator bool()</tt> with <tt>packaged_task::valid()</tt> in the synopsis
(30.6.10 [futures.task]/2) and the member function specification (before 30.6.10.1 [futures.task.members]/15).
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposed wording changes into a proper proposed resolution
and verified that no other places implicitly take advantage of <tt>packaged_task</tt> 
conversion to bool.
]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.10 [futures.task]/2, class template <tt>packaged_task</tt> synopsis as indicated:
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
class packaged_task&lt;R(ArgTypes...)&gt; {
public:
  typedef R result_type;
  [..]
  <del>explicit operator</del> bool <ins>valid</ins>() const;
  [..]
};
</pre></blockquote>
</li>
<li>Change 30.6.10 [futures.task] before p. 15 as indicated:
<blockquote><pre>
<del>explicit operator</del> bool <ins>valid</ins>() const;
</pre><blockquote>
15 <em>Returns</em>: true only if <tt>*this</tt> has an associated asynchronous state.
<p/>
16 <em>Throws</em>: nothing.
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1509"></a>1509. [FCD] No restriction on calling <tt>future::get</tt> more than once</h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.atomic_future">active issues</a> in [futures.atomic_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-202</b></p>
<p>
The note in this paragraph says "unlike <tt>future</tt>, calling <tt>get</tt>
more than once on the same <tt>atomic_future</tt> object is well
defined and produces the result again." There is nothing
in <tt>future</tt> that says anything negative about calling <tt>get</tt>
more than once.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Remove this note, or add words to the
requirements for future that reflect what this note
says.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1510"></a>1510. [FCD] Should be undefined behaviour to call <tt>atomic_future</tt> operations unless <tt>valid()</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.atomic_future">active issues</a> in [futures.atomic_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-203</b></p>
<p>
Both <tt>future</tt> and <tt>shared_future</tt> specify that calling most
member functions on an object for which <tt>valid() == false</tt>
produces undefined behavior. There is no such statement
for <tt>atomic_future</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a new paragraph after 30.6.8 [futures.atomic_future]/2 with the same words as
30.6.7 [futures.shared_future]/3.
</p>

<p><i>[
2010-11-02 Daniel translates proposed changes into specific deltas and comments:
]</i></p>


<blockquote>
While applying the wording, I notice that 30.6.7 [futures.shared_future]/3 does
speak of the move-assignment operator, and <em>not</em> of the copy-assignment operator.
<tt>atomic_future</tt> obviously needs this to be true for the copy-assignment operator,
but I strongly assume that <tt>shared_future</tt> needs to mention both special member
assignment operators in this paragraph. To keep this consistent, the following P/R also
provides wording to fix the corresponding location for <tt>shared_future</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.7 [futures.shared_future]/3 as indicated:
<blockquote>
3 The effect of calling any member function other than the destructor<ins>, the 
copy-assignment operator</ins>, the move-assignment operator, or <tt>valid()</tt> 
on a <tt>shared_future</tt> object for which <tt>valid() == false</tt> is undefined.
</blockquote>
</li>
<li>Following 30.6.8 [futures.atomic_future]/2, add a new paragraph:
<blockquote>
<ins>? The effect of calling any member function other than the destructor, the copy-assignment operator, or <tt>valid()</tt>
on a <tt>atomic_future</tt> object for which <tt>valid() == false</tt> is undefined.</ins>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1511"></a>1511. [FCD] Synchronize the move-constructor for <tt>atomic_future</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.atomic_future">active issues</a> in [futures.atomic_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-204</b></p>
<p>
According to the definition of <tt>atomic_future</tt>, all members
of <tt>atomic_future</tt> are synchronizing except constructors.
However, it would probably be appropriate for a move
constructor to be synchronizing on the source object. If
not, the postconditions on paragraphs 7-8, might not be
satisfied. This may be applicable if a collection of futures
are being doled out to a set of threads that process their
value.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Make the move constructor for atomic future lock
the source
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1512"></a>1512. [FCD] Conflict in spec: block or join?</h3>
<p><b>Section:</b> 30.6.9 [futures.async] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-205</b></p>
<p>
30.6.9 [futures.async] p. 3: The third sentence says 
"If the invocation is not deferred, a call to a waiting function 
on an asynchronous return object that shares the associated asynchronous state
created by this <tt>async</tt> call shall block until the associated
thread has completed." The next sentence says "If the
invocation is not deferred, the <tt>join()</tt> on the created
thread..." Blocking until a thread completes is not
necessarily a join.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Decide whether the requirement is to block until
finished or to call join, and rewrite to match.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1513"></a>1513. [FCD] 'launch' enum too restrictive</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-02</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures">active issues</a> in [futures].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-36</b></p>

Providing only three different possible values for the enum
<tt>launch</tt> and saying that <tt>launch::any</tt> means either
<tt>launch::sync</tt> or <tt>launch::async</tt> is very restricting. This
hinders future implementors to provide clever
infrastructures that can simply by used by a call to
<tt>async(launch::any,...)</tt>. Also there is no hook for an
implementation to provide additional alternatives to <tt>launch</tt>
enumeration and no useful means to combine those (i.e.
interpret them like flags). We believe something like
<tt>async(launch::sync | launch::async, ...)</tt> should be allowed
and can become especially useful if one could say also
something like <tt>async(launch::any &amp; ~launch::sync, ....)</tt>
respectively. This flexibility might limit the features usable
in the function called through <tt>async()</tt>, but it will allow a
path to effortless profit from improved hardware/software
without complicating the programming model when just
using <tt>async(launch::any,...)</tt>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Change in 30.6.1 [futures.overview] 'enum class launch' to allow
further implementation defined values and provide
the following bit-operators on the launch values
(<tt>operator|</tt>, <tt>operator&amp;</tt>, <tt>operator~</tt> delivering a
<tt>launch</tt> value).
<p/>
Note: a possible implementation might use an
unsigned value to represent the <tt>launch</tt> enums,
but we shouldn't limit the standard to just 32 or 64
available bits in that case and also should keep
the launch enums in their own enum namespace.
<p/>
Change [future.async] p3 according to the
changes to <tt>enum launch</tt>. change --<tt>launch::any</tt> to
"the implementation may choose any of the
policies it provides." Note: this can mean that an
implementation may restrict the called function to
take all required information by copy in case it will
be called in a different address space, or even, on
a different processor type. To ensure that a call is
either performed like <tt>launch::async</tt> or
<tt>launch::sync</tt> describe one should call
<tt>async(launch::sync|launch::async,...)</tt>
</p>

<p><i>[
2010-11-02 Daniel comments:
]</i></p>


<blockquote>
The new paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3113.html">n3113</a> provides concrete wording.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3113.html">n3113</a>.





<hr>
<h3><a name="1514"></a>1514. [FCD] <tt>packaged_task</tt> constructors need review</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-207</b></p>

The constructor that takes R(*)(ArgTypes...) is not
needed; the constructor that takes a callable type works
for this argument type. More generally, the constructors
for packaged_task should parallel those for function.

<p><i>[
US-207 Suggested Resolution:
]</i></p>


<blockquote>
Review the constructors for packaged_task and
provide the same ones as function, except where
inappropriate.
</blockquote>

<p><i>[
2010-10-22 Howard provides wording, as requested by the LWG in Rapperswil.
]</i></p>




<p><b>Proposed resolution:</b></p>
Alter the list of constructors in both [futures.task] and in [futures.task.members] as indicated:

<blockquote>
<pre><del>template &lt;class F&gt;
explicit packaged_task(F f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F f);
explicit packaged_task(R(*f)(ArgTypes...));</del>
template &lt;class F&gt;
explicit packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
</blockquote>





<hr>
<h3><a name="1515"></a>1515. [FCD] <tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-208</b></p>

<p>
<tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Figure out what the synchronization requirements
should be and write them.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1521"></a>1521. Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.1 [container.requirements.general] p. 8:
</p>
<blockquote>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</blockquote>





<hr>
<h3><a name="1522"></a>1522. <tt>conj</tt> specification is now nonsense</h3>
<p><b>Section:</b> 26.4.9 [cmplx.over] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-11-02</p>
<p><b>View all other</b> <a href="lwg-index.html#cmplx.over">issues</a> in [cmplx.over].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Pittsburgh, we accepted the resolution of library issue 1137<a href="lwg-defects.html#1137">1137</a>, to add
a sentence 3 to [cmplx.over]:
</p>
<blockquote>
All the specified overloads shall have a return type which is the nested
<tt>value_type</tt> of the effectively cast arguments."
</blockquote>
<p>
This was already true for four of the six functions except <tt>conj</tt> and
<tt>proj</tt>. It is not completely unreasonable to make <tt>proj</tt> return
the real value only, but the IEC specification does call for an imaginary part
of -0 in some circumstances. The people who care about these distinctions really
care, and it <em>is</em> required by an international standard.
</p>
<p>
Making <tt>conj</tt> return just the real part breaks it horribly, however. It is
well understood in mathematics that <tt>conj(re + i*im)</tt> is <tt>(re - i*im)</tt>,
and it is widely used. The accepted new definition makes <tt>conj</tt> useful only
for pure real operations. This botch <em>absolutely must</em> be fixed.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Remove the recently added paragraph 3 from [cmplx.over]:
</p>
<blockquote>
<del>3 All the specified overloads shall have a return type which is the nested 
<tt>value_type</tt> of the effectively cast arguments.</del>
</blockquote>





<hr>
<h3><a name="2000"></a>2000. Missing definition of <tt>packaged_task</tt> specialization of <tt>uses_allocator</tt></h3>
<p><b>Section:</b> 30.6.10.2 [futures.task.nonmembers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-08-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[futures.task.nonmembers]/3 says:
<blockquote><pre>
   template &lt;class R, class Alloc>
     struct uses_allocator&lt;packaged_task&lt;R>, Alloc>;
</pre></blockquote>

This is a declaration, but should be a definition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change [futures.task.nonmembers]/3:
</p>

<blockquote><pre>
   template &lt;class R, class Alloc>
     struct uses_allocator&lt;packaged_task&lt;R>, Alloc><del>;</del>
        <ins>: true_type {};</ins>
</pre></blockquote>





<hr>
<h3><a name="2001"></a>2001. Class template <tt>basic_regex</tt> uses non existent <tt>string_type</tt></h3>
<p><b>Section:</b> 28.8.3 [re.regex.assign] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Volker Lukas <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In working draft N3126, subclause 28.8.3 [re.regex.assign], paragraphs 12, 13 and 19, 
the name <tt>string_type</tt> is used. This is presumably a typedef for <tt>basic_string&lt;value_type&gt;</tt>, where 
<tt>value_type</tt> is the character type used by <tt>basic_regex</tt>. The <tt>basic_regex</tt> 
template however defines no such typedef, and neither does the <tt>&lt;regex&gt;</tt> 
header or the <tt>&lt;initializer_list&gt;</tt> header included by <tt>&lt;regex&gt;</tt>.
</p>

<p><i>[
2010-11-03 Daniel comments and suggests alternative wording:
]</i></p>

<blockquote>
The proposed resolution needs to use <tt>basic_string&lt;<strong>charT</strong>&gt;</tt> instead of <tt>basic_string&lt;char&gt;</tt>
</blockquote>

<p>Proposed Resolution:</p>

Make the following changes to [re.regex.assign]:<p/>

<blockquote>
<pre>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
12 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr), f)</tt>. 
</blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
13 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr, len), f)</tt>.
</blockquote>

<pre>
[..]

template &lt;class InputIterator&gt; 
  basic_regex&amp; assign(InputIterator first, InputIterator last, 
                          flag_type f = regex_constants::ECMAScript);
</pre>

<blockquote>
18 <i>Requires</i>: The type <tt>InputIterator</tt> shall satisfy the requirements for an Input Iterator (24.2.3).
</blockquote>

<blockquote>
19 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(first, last), f)</tt>.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Make the following changes to [re.regex.assign]:</p>

<blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
12 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(ptr), f)</tt>. 
</blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
13 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(ptr, len), f)</tt>.
</blockquote>

<pre>
[..]

template &lt;class InputIterator&gt; 
  basic_regex&amp; assign(InputIterator first, InputIterator last, 
                          flag_type f = regex_constants::ECMAScript);
</pre>

<blockquote>
18 <i>Requires</i>: The type <tt>InputIterator</tt> shall satisfy the requirements for an Input Iterator (24.2.3).
</blockquote>

<blockquote>
19 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(first, last), f)</tt>.
</blockquote>

</blockquote>






<hr>
<h3><a name="2002"></a>2002. Class template <tt>match_results</tt> does not specify the semantics of <tt>operator==</tt></h3>
<p><b>Section:</b> 28.10.7 [re.results.nonmember] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-10-24 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <em>Returns</em> element of <tt>operator==</tt> says:
</p>

<blockquote>
<tt>true</tt> only if the two objects refer to the same match
</blockquote>

<p>
It is not really clear what this means: The current specification would allow for an
implementation to return <tt>true</tt>, only if the address values of <tt>m1</tt> and
<tt>m2</tt> are the same. While this approach is unproblematic in terms of used operations 
this is also a bit unsatisfactory. With identity equality alone there seems to be no convincing
reason to provide this operator at all. It could for example also refer to an comparison based
on iterator values. In this case a user should better know that this will be done, because 
there is no guarantee at all that inter-container comparison of iterators 
is a feasible operation. This was a clear outcome of the resolution provided in 
<a href= "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a> 
for LWG issue <a href= "http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#446">446</a>.
It could also mean that a character-based comparison of the individual <tt>sub_match</tt>
elements should be done - this would be equivalent to applying <tt>operator==</tt> to
the subexpressions, prefix and suffix.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Apply the proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>
</p>





<hr>
<h3><a name="2003"></a>2003. String exception inconsistency in erase.</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jose Daniel Garcia Sanchez <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 21.4.1 [string.require]p3 states:
</p>
<blockquote>
No <tt>erase()</tt> or <tt>pop_back()</tt> member function shall throw
any exceptions.
</blockquote>
<p>
However in 21.4.6.5 [string::erase] p2 the first version of <tt>erase</tt> has
</p>
<blockquote>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos > size()</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Update [string.require]p/3:
</p>
<blockquote>
3 No <del><tt>erase()</tt> or</del> <tt>pop_back()</tt> member function
shall throw any exceptions.
</blockquote>





<hr>
<h3><a name="2004"></a>2004. <tt>duration::operator*</tt> has template parameters in funny order</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [time] and [time.duration.nonmember] we have:
</p>
<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>
<p>
Everywhere else, we always have <tt>&lt;rep, period></tt> in that order for a given
type. But here, we have <tt>Period</tt> and <tt>Rep2</tt> in reverse order for
<tt>&lt;Rep2, Period></tt>. This is probably of little importance, since the
template parameters are seldom spelled out for a function like this. But changing it
now will eliminate a potential source of future errors and confusion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signature in [time] and [time.duration.nonmember] to:
</p>
<blockquote><pre>
template &lt;class Rep1, class <del>Period</del><ins>Rep2</ins>, class <del>Rep2</del><ins>Period</ins>>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>





<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.6.1.3 [map.modifiers], 23.6.2.2 [multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-10-31</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
now has an added Remarks paragraph:
</p>
<blockquote>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
</p>
<p>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
</p>

<p>
Proposed resolution:
</p>

<p>
<ol>
<li>Change 23.6.1.3 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
<li>Change 23.6.2.2 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
</ol>
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Add a new Remarks element after 23.6.1.3 [map.modifiers] p. 1:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
<li>Change 23.6.2.2 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2006"></a>2006. <tt>emplace</tt> broken for associative containers</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2010-10-18 <b>Last modified:</b> 2010-11-02</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current definition of <tt>emplace(args)</tt> for associative containers as
described in Table 99 is:
<blockquote>
<p>
<i>Requires</i>: <tt>T</tt> shall be constructible from <tt>args</tt>.
</p>
<p>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element
in the container with key equivalent to the key of <tt>t</tt>.  The <tt>bool</tt>
component of the returned <tt>pair</tt> is <tt>true</tt> if and only if the
insertion takes place, and the iterator component of the <tt>pair</tt>
points to the element with key equivalent to the key of <tt>t</tt>.
</p>
</blockquote>
</p>
<p>
There is similar language in Table 100 for unordered associative containers.
</p>
<p>
The first issue is editorial: <tt>T</tt> should be <tt>value_type</tt> throughout
both tables.
</p>
<p>
The major issue is that, if the container is <tt>map</tt>, <tt>multimap</tt>,
<tt>unordered_map</tt>, or <tt>unordered_multimap</tt>, then the only way to
construct an object of <tt>value_type</tt> is to supply exactly two arguments
for <tt>Key</tt> and <tt>Value</tt>, a <tt>pair&lt;Key,Value&gt;</tt>, or a
<tt>piecewise_construct_t</tt> followed by two <tt>tuple</tt>s.  The original
<tt>emplace()</tt> proposal would have allowed you to specify a <tt>Key</tt>
value followed by any number of constructor arguments for <tt>Value</tt>.
When we removed the variadic constructor to <tt>pair</tt>, this ability went
away.  I don't think that was deliberate.
</p>
<p>
Fixing this is non-trivial, I think. I think that <tt>emplace()</tt> for <tt>map</tt>
and <tt>multimap</tt> need several overloads: one for each overloaded constructor in
<tt>pair&lt;Key,Value&gt;</tt>, and one for the <tt>emplace(Key, valueargs...)</tt> case.
And it probably needs some SFINAE meta-programming to ensure that the last case
doesn't override any of the other ones.  Alternatively, one could say that
there are exactly two cases: <tt>emplace(args)</tt> where <tt>pair&lt;Key,Value&gt;</tt>
is constructible from <tt>args</tt>, and <tt>emplace(args)</tt> where <tt>Key</tt> is
constructible form the first <tt>arg</tt> and <tt>Value</tt> is constructible from the
rest.
</p>
<p>
Alternatively, the status quo is to use <tt>piecewise_construct_t</tt> if you want to
construct an object.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2007"></a>2007. Incorrect specification of return value for <tt>map&lt;&gt;::at()</tt></h3>
<p><b>Section:</b> 23.6.1.2 [map.access] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-01 <b>Last modified:</b> 2010-11-02</p>
<p><b>View all other</b> <a href="lwg-index.html#map.access">issues</a> in [map.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [map.access]/9, the <i>Returns</i> clause for <tt>map&lt;Key, T&gt;::at(x)</tt> says 
that it returns "a reference to the element whose key is equivalent to <tt>x</tt>." That can't be right. 
The signature for <tt>at()</tt> says that its return type is <tt>T</tt>, but the elements 
of <tt>map&lt;Key, T&gt;</tt> have type <tt>pair&lt;const K, T&gt;</tt>.  (I checked [unord.map.elem] 
and found that its specification of <tt>at()</tt> is correct. This is a problem for <tt>map</tt> only.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the wording in [map.access]/9 so it's identical to what we already say for <tt>operator[]</tt>, 
which is unambiguous and correct.
</p>
<blockquote>
<i>Returns</i>: A reference to the <del>element whose key is equivalent</del><ins><tt>mapped_type</tt> 
corresponding</ins> to <tt>x</tt><ins> in <tt>*this</tt></ins>.
</blockquote>





<hr>
<h3><a name="2008"></a>2008. Conflicting Error Conditions for <tt>packaged_task::operator()</tt></h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2010-06-21 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Throws clause for <tt>packaged_task::operator()</tt> says that it throws "a
<tt>future_error</tt> exception object if there is no associated asynchronous
state or the stored task has already been invoked." However, the Error
Conditions clause does not define an error condition when the stored task has
already been invoked, only when the associated state is already ready (i.e. the
invocation has completed).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first bullet item in 30.6.10.1 [futures.task.members] /22:
</p>

<blockquote><pre>
void operator()(ArgTypes... args);
</pre>
<blockquote>
<p>
20 ...
</p>
<p>
21 ...
</p>
<p>
22 <i>Error conditions:</i>
</p>
<ul>
<li>
<tt>promise_already_satisfied</tt> if <del>the associated asynchronous state is
already ready</del> <ins><tt>operator()</tt> has already been called</ins>.
</li>
<li>
<tt>no_state</tt> if <tt>*this</tt> has no associated asynchronous state.
</li>
</ul>
</blockquote>
</blockquote>





<hr>
<h3><a name="2009"></a>2009. Reporting out-of-bound values on numeric string conversions</h3>
<p><b>Section:</b> 21.5 [string.conversions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The functions (<tt>w</tt>)<tt>stoi</tt> and (<tt>w</tt>)<tt>stof</tt>
are specified in terms of calling C library APIs for potentially wider
types.  The integer and floating-point versions have subtly different
behaviour when reading values that are too large to convert.  The
floating point case will throw <tt>out_of_bound</tt> if the read value
is too large to convert to the wider type used in the implementation,
but behaviour is undefined if the converted value cannot narrow to a
float.  The integer case will throw <tt>out_of_bounds</tt> if the
converted value cannot be represented in the narrower type, but throws
<tt>invalid_argument</tt>, rather than <tt>out_of_bounds</tt>, if the
conversion to the wider type fails due to overflow.
</p>

<p>
Suggest that the Throws clause for both specifications should be
consistent, supporting the same set of fail-modes with the matching set
of exceptions.
</p>



<p><b>Proposed resolution:</b></p>
<p>
21.5p3 [string.conversions]
</p>

<blockquote><pre>
int stoi(const string&amp; str, size_t *idx = 0, int base = 10);
long stol(const string&amp; str, size_t *idx = 0, int base = 10);
unsigned long stoul(const string&amp; str, size_t *idx = 0, int base = 10);
long long stoll(const string&amp; str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const string&amp; str, size_t *idx = 0, int base = 10);
</pre>

<blockquote>
<p>
...
</p>
<p>
3 <i>Throws:</i> <tt>invalid_argument</tt> if <tt>strtol</tt>,
<tt>strtoul</tt>, <tt>strtoll</tt>, or <tt>strtoull</tt> reports that no
conversion could be performed. Throws <tt>out_of_range</tt> if
<ins><tt>strtol</tt>, <tt>strtoul</tt>, <tt>strtoll</tt> or
<tt>strtoull</tt> sets <tt>errno</tt> to <tt>ERANGE</tt>, or if</ins>
the converted value is outside the range of representable values for the
return type.
</p>
</blockquote>
</blockquote>

<p>
21.5p6 [string.conversions]
</p>

<blockquote><pre>
float stof(const string&amp; str, size_t *idx = 0);
double stod(const string&amp; str, size_t *idx = 0);
long double stold(const string&amp; str, size_t *idx = 0);
</pre>

<blockquote>
<p>
...
</p>
<p>
6 <i>Throws:</i> <tt>invalid_argument</tt> if <tt>strtod</tt> or
<tt>strtold</tt> reports that no conversion could be performed. Throws
<tt>out_of_range</tt> if <tt>strtod</tt> or <tt>strtold</tt> sets
<tt>errno</tt> to <tt>ERANGE</tt> <ins> or if the converted value is
outside the range of representable values for the return type</ins>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="2010"></a>2010. <tt>is_* traits</tt> for binding operations can't be meaningfully specialized</h3>
<p><b>Section:</b> 20.8.10.1.1 [func.bind.isbind] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.10.1.1 [func.bind.isbind] says for <tt>is_bind_expression</tt>:
</p>

<blockquote>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</blockquote>

<p>
But it also says:
</p>

<blockquote>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2011"></a>2011. unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string&gt; 
#include &lt;iostream&gt; 
#include &lt;iomanip&gt; 

int 
main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]/5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote>
<i>Effects:</i> Behaves as a formatted output function (27.7.2.6.1 [ostream.formatted.reqmts]). After constructing a <tt>sentry</tt>
object, if this object returns <tt>true</tt> when converted to a value of type
<tt>bool</tt>, determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where
<tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then
calls <tt>os.width(0)</tt>.
</blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]/5: 
</p>

<blockquote>
<p>
[...] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2012"></a>2012. Associative maps should insert <tt>pair</tt>, not <tt>tuple</tt></h3>
<p><b>Section:</b> 23.6 [associative] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-10-29 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something strange in the paragraphs 23.6.1.3 [map.modifiers] and 23.6.2.2 [multimap.modifiers]:
they both talk about <tt>tuple&lt;const key_type, mapped_type&gt;</tt> but I think they
should be talking about <tt>pair&lt;const key_type, mapped_type&gt;</tt> because, among
other reasons, a <tt>tuple</tt> is not convertible to a <tt>pair</tt>. If I replace <tt>tuple</tt>
with <tt>pair</tt> everything makes sense to me.

The proposed resolution is obvious. 
</p>

<p><i>[
2010-11-07 Daniel comments
]</i></p>


<p>
This is by far not the only necessary fix within both sub-clauses. For details see the 2010-10-29 comment in 
2005<a href="lwg-active.html#2005">2005</a>.
</p>


<p><b>Proposed resolution:</b></p>
Apply the resolution proposed by the 2010-10-29 comment in 2005<a href="lwg-active.html#2005">2005</a>.





</body>
</html>
