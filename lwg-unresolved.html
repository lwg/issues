<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2011-07-11 at 20:07:52 UTC</p>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a 
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>&#xB1HUGE_VALF</code>,
<code>&#xB1HUGE_VAL</code> and <code>&#xB1HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Some concern that this is changing the specification for an existing C++03 function, but it was 
pointed out that this was underspecified as resolved by issue 23.  This is clean-up for that 
issue in turn. Some concern that we are trying to solve the same problem in both clause 22 and 27.
</p>
<p>
Bill: There's a change here as to whether val is stored to in an error case.
</p>
<p>
Pablo: Don't think this changes whether val is stored to or not, but changes the value that is stored.
</p>
<p>
Bill: Remembers having skirmishes with customers and testers as to whether val is stored to, and the resolution was not to store in error cases.
</p>
<p>
Howard: Believes since C++03 we made a change to always store in overflow.
</p>
<p>
Everyone took some time to review the issue.
</p>
<p>
Pablo: C++98 definitely did not store any value during an error condition.
</p>
<p>
Dietmar: Depends on the question of what is considered an error, and whether overflow is an error or not, which was the crux of LWG 23.
</p>
<p>
Pablo: Yes, but given the "zero, if the conversion function fails to convert the entire field", we are requiring every error condition to store.
</p>
<p>
Bill: When did this happen?
</p>
<p>
Alisdair: One of the last two or three meetings.
</p>
<p>
Dietmar: To store a value in case of failure is a very bad idea.
</p>
<p>
Move to Open, needs more study.
</p>
</blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2011-04-24</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.4.2 [unord.map.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.5.2 [unord.multimap.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 [unord.set.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 [unord.multiset.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.6.12 [specialized.algorithms]/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consider to await the paper.
</p>





<hr>
<h3><a name="1214"></a>1214. Insufficient/inconsistent key immutability requirements for  associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-20 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Scott Meyers' mentions on a recent posting on <a
href="http://groups.google.de/group/comp.std.c++/msg/6f9160fc428bcbea">c.s.c++</a>
some arguments that point to an incomplete resolution
of <a href="lwg-defects.html#103">103</a> and to an inconsistency of requirements on keys in ordered and
unordered associative
containers:
</p>

<blockquote>
<p>
1) <a href="lwg-defects.html#103">103</a> introduced the term immutable without defining it in a unique manner in
23.2.4 [associative.reqmts]/5:
</p>

<blockquote><p>
[..] Keys in an associative container are immutable.
</p></blockquote>

<p>
According to conventional dictionaries immutable is an unconditional way of
saying that something cannot be changed. So without any further explicit
allowance a user <em>always</em> runs into undefined behavior if (s)he attempts
to modify such a key. IMO this was not the intend of the committee to resolve
<a href="lwg-defects.html#103">103</a> in that way because the comments suggest an interpretation that
should give any user the freedom to modify the key in an <em>explicit</em> way
<em>provided</em> it would not affect the sort order in that container.
</p>

<p>
2) Another observation was that surprisingly no similar 'safety guards'
exists against unintentional key changes for the unordered associative
containers, specifically there is no such requirement as in
23.2.4 [associative.reqmts]/6 that "both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
iterators". But the need for such protection against unintentional
changes as well as the constraints in which manner any explicit
changes may be performed are both missing and necessary, because
such changes could potentially change the <em>equivalence</em> of keys that
is measured by the <tt>hasher</tt> and <tt>key_equal</tt>.
</p>

<p>
I suggest to fix the unconditional wording involved with "immutable keys"
by at least adding a hint for the reader that users <em>may</em> perform such
changes in an explicit manner <em>and</em> to perform similar wording changes
as <a href="lwg-defects.html#103">103</a> did for the ordered associative containers also for the unordered
containers.
</p>
</blockquote>

<p><i>[
2010-03-27 Daniel provides wording.
]</i></p>


<blockquote><p>
This update attempts to provide normative wording that harmonizes the key and
function object constraints of associative and unordered containers.
</p></blockquote>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We're uncomfortable with the first agenda item, and we can live with the second agenda 
item being applied before or after Madrid. 
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 23.2.4 [associative.reqmts]/2 as indicated: <i>[This ensures that
associative containers make better clear what this "arbitrary" type is, as the
unordered containers do in 23.2.5 [unord.req]/3]</i>
</p>

<blockquote><p>
2 Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that induces a strict weak ordering (25.4) on elements
of <tt>Key</tt>. In addition, <tt>map</tt> and <tt>multimap</tt> associate an
arbitrary <ins><em>mapped type</em></ins><del>type</del> <tt>T</tt> with the
<tt>Key</tt>. The object of type <tt>Compare</tt> is called the <em>comparison
object</em> of a container.
</p></blockquote>
</li>

<li>
<p>
Change 23.2.4 [associative.reqmts]/5 as indicated: <i>[This removes the
too strong requirement that keys must not be changed at all and brings this line
in sync with 23.2.5 [unord.req]/7. We take care about the real
constraints by the remaining suggested changes. The rationale provided by LWG
<a href="lwg-defects.html#103">103</a> didn't really argue why that addition is necessary, and I
believe the remaining additions make it clear that any user changes have strong
restrictions]</i>:
</p>

<blockquote><p>
5 For <tt>set</tt> and <tt>multiset</tt> the value type is the same as the key
type. For <tt>map</tt> and <tt>multimap</tt> it is equal to <tt>pair&lt;const
Key, T&gt;</tt>. <del>Keys in an associative container are immutable.</del>
</p></blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/3+4 as indicated: <i>[The current sentence of
p.4 has doesn't say something really new and this whole subclause misses to
define the concepts of the container-specific hasher <i>object</i> and predicate
<i>object</i>. We introduce the term <em>key equality predicate</em> which is
already used in the requirements table. This change does not really correct part
of this issue, but is recommended to better clarify the nomenclature and the
difference between the function objects and the function object <em>types</em>,
which is important, because both can potentially be stateful.]</i>
</p>

<blockquote>
<p>
3 Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object type <tt>Hash</tt> that meets the <tt>Hash</tt> requirements
(20.2.4) and acts as a hash function for argument values of type <tt>Key</tt>,
and by a binary predicate <tt>Pred</tt> that induces an equivalence relation on
values of type <tt>Key</tt>. Additionally, <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> associate an arbitrary <em>mapped type</em>
<tt>T</tt> with the <tt>Key</tt>.
</p>

<p>
4 <ins>The container's object of type <tt>Hash</tt> - denoted by
<tt>hash</tt> - is called the <em>hash function</em> of the container.
The container's object of type <tt>Pred</tt> - denoted by
<tt>pred</tt> - is called the <em>key equality predicate</em> of the
container.</ins><del>A hash function is a function object that takes a single
argument of type <tt>Key</tt> and returns a value of type
<tt>std::size_t</tt></del>.
</p>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/5 as indicated: <i>[This adds a similar
safe-guard as the last sentence of 23.2.4 [associative.reqmts]/3]</i>
</p>

<blockquote><p>
5 Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered
equivalent if the container's <ins>key equality
predicate</ins><del><tt>key_equal</tt> function object</del> returns
<tt>true</tt> when passed those values. If <tt>k1</tt> and <tt>k2</tt> are
equivalent, the <ins>container's</ins> hash function shall return the same value
for both. [<i>Note:</i> thus, when an unordered associative container is
instantiated with a non-default <tt>Pred</tt> parameter it usually needs a
non-default <tt>Hash</tt> parameter as well. &mdash; <i>end note</i>] <ins>For
any two keys <tt>k1</tt> and <tt>k2</tt> in the same container, calling
<tt>pred(k1, k2)</tt> shall always return the same value. For any key <tt>k</tt>
in a container, calling <tt>hash(k)</tt> shall always return the same
value.</ins>
</p></blockquote>
</li>

<li>
<p>
After 23.2.5 [unord.req]/7 add the following new paragraph: <i>[This
ensures the same level of compile-time protection that we already require for
associative containers. It is necessary for similar reasons, because any change
in the stored key which would change it's equality relation to others or would
change it's hash value such that it would no longer fall in the same bucket,
would break the container invariants]</i>
</p>

<blockquote>
<p>
7 For <tt>unordered_set</tt> and <tt>unordered_multiset</tt> the value type is
the same as the key type. For <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> it is <tt>std::pair&lt;const Key, T&gt;</tt>.
</p>
<p>
<ins>For unordered containers where the value type is the same as the key type,
both <tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It is
unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type. [<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have
identical semantics in this case, and <tt>iterator</tt> is convertible to
<tt>const_iterator</tt>. Users can avoid violating the One Definition Rule by
always using <tt>const_iterator</tt> in their function parameter lists. &mdash;
<i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1330"></a>1330. Move container requirements into requirements tables</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Abstract:
</p>
<p>
In general, it seems that in a couple of places container behavior is
not described in requirement tables although it is a general behavior.
</p>

<p>
History:
</p>

<p>
Issue <a href="lwg-defects.html#676">676</a> added move semantics to unordered containers.
For the added insert functions the Editor requested to put their
semantic description into a requirements table rather than describing
them for each container individually. The text however was taken from
the associative containers, where we also have the semantics for each
container described. Also, <a href="lwg-defects.html#1034">1034</a> is to some extend
requesting a clarification of the requirement tables and it turned out
that in other places we have the same problem (e.g. we have no general
requirement for type pointer and const_pointer although each container
has them with issue <a href="lwg-defects.html#1306">1306</a>).
</p>

<p>
From my personal list of functions in requirement tables
and containers, the following types/functions are missing in
requirement tables:
</p>

<ul>
<li>
<tt>pointer</tt>, <tt>const_pointer</tt> in Table 91 (container requirements)
</li>
<li>
<p>
all copy constructors, copy constructors with allocator,
 assignment operators, and insert operators
 with move semantics for associative and unordered containers
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;)
ContType c1(c2&amp;&amp;,alloc)
c1 = c2&amp;&amp;
c.insert(val&amp;&amp;)
c.insert(pos,val&amp;&amp;)
</pre></blockquote>
</li>
</ul>

<p>
As a special case, we lack the following requirements for all sequence
containers BUT array (so special wording or a new container category is
required):
</p>

<ul>
<li>
<p>
constructor with only a size argument
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>
</li>
<li>
<p>
copy constructor with allocator and move semantics
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;,alloc)
</pre></blockquote>
</li>
<li>
<p>
all constructors that insert multiple elements with additional allocator
</p>
<blockquote><pre>
ContType c(num, val,alloc)
ContType c(beg, end,alloc)
ContType c(initlist,alloc)
</pre></blockquote>
</li>
<li>
<p>
all resize functiuons:
</p>
<blockquote><pre>
c.resize(num)
c.resize(num,val)
</pre></blockquote>
</li>
</ul>

<p>
Note that we also might have to add additional requirements on other
places for sequence containers because having an allocator requires
additional statements for the treatment of the allocators. E.g. swap for
containers with allocators is not specified in any requirement table.
</p>

<p>
And finally, if we have the requirements in the requirements tables, we
can remove the corresponding descriptions for the individual container.
However, note that sequence container requirements have NO complexity
column, so that we still need container specific descriptions for the
functions listed there.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
While there is consensus that further cleaning up the container requirement
tables would be a good thing, there is no feeling that this <em>must</em>
be done in time for 0x.  The issue remains open, but Deferred.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1450"></a>1450. [FCD] Contradiction in regex_constants</h3>
<p><b>Section:</b> 28.5.2 [re.matchflag] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-127</b></p>

<p>
The Bitmask Type requirements in 17.5.2.1.3 [bitmask.types] p.3 say that
all elements on a bitmask type have distinct values, but
28.5.2 [re.matchflag] defines <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> as elements of the
bitmask type <tt>regex_constants::match_flag_type</tt>, both with
value 0. This is a contradiction.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
One of the bitmask elements should be removed
from the declaration and should be defined
separately, in the same manner as
<tt>ios_base::adjustfield</tt>, <tt>ios_base::basefield</tt> and
<tt>ios_base::floatfield</tt> are defined by 27.5.3.1.2 [ios::fmtflags] p.2
and Table 120. These are constants of a bitmask
type, but are not distinct elements, they have
more than one value set in the bitmask.
<tt>regex_constants::format_default</tt> should be
specified as a constant with the same value as
<tt>regex_constants::match_default</tt>.
</p></blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>

<p>
Strictly speaking, a bitmask type cannot have any element of value 0 at all, because
any such value would contradict the requirement expressed in 17.5.2.1.3 [bitmask.types] p. 3:
</p>
<blockquote><p>
for any pair <em>Ci</em> and <em>Cj</em>, <em>Ci</em> &amp; <em>Ci</em> is nonzero
</p></blockquote>
<p>
So, actually <em>both</em> <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> are only constants of the type
<tt>regex_constants::match_flag_type</tt>, and no bitmask elements.
</p>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The proposed resolution is written against N3126 and considered as a further improvement
of the fixes suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
</p>
<blockquote><p>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
Matching a regular expression against a sequence of characters [first,last) proceeds according to the
rules of the grammar specified for the regular expression object, modified according to the effects listed in
Table 136 for any bitmask elements set. <ins>Type <tt>regex_constants::match_flag_type</tt> also defines the 
constants <tt>regex_constants::match_default</tt> and <tt>regex_constants::format_default</tt>.</ins>
</p></blockquote>





<hr>
<h3><a name="1521"></a>1521. Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>

<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>Deferred</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.1 [container.requirements.general] p. 8:
</p>
<blockquote><p>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</p></blockquote>





<hr>
<h3><a name="1526"></a>1526. [FCD] C++ should not impose thread safety requirements on C99 library implementations</h3>
<p><b>Section:</b> 17.6.5.9 [res.on.data.races] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2011-03-24 <b>Last modified:</b> 2011-04-23</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-111</b></p>

<p>Section 17.6.5.9 [res.on.data.races], Data Race Avoidance, requires the C++ Standard Library to avoid data races 
that might otherwise result from two threads making calls to C++ Standard Library functions on 
distinct objects. The C standard library is part of the C++ Standard Library and some C++ Standary library 
functions (parts of the Localization library, as well as Numeric Conversions in 21.5), are specified 
to make use of the C standard library. Therefore, the C++ standard indirectly imposes a requirement 
on the thread safety of the C standard library. However, since the C standard does not address the 
concept of thread safety conforming C implementations exist that do no provide such guarantees. 
This conflict needs to be reconciled.</p>

<p>Suggested resolution by national body comment:</p>

<blockquote><p>
remove the requirement to make use of <tt>strtol()</tt> and <tt>sprintf()</tt> since these functions depend on the 
global C locale and thus cannot be made thread safe.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Deferred</p>



<p><b>Rationale:</b></p><p>No consensus to make a change at this time</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2003"></a>2003. String exception inconsistency in erase.</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jos&eacute; Daniel Garc&iacute;a S&aacute;nchez <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 21.4.1 [string.require]p3 states:
</p>
<blockquote><p>
No <tt>erase()</tt> or <tt>pop_back()</tt> member function shall throw
any exceptions.
</p></blockquote>
<p>
However in 21.4.6.5 [string::erase] p2 the first version of <tt>erase</tt> has
</p>
<blockquote><p>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos > size()</tt>.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Beman: Don't want to just change this, can we just say "unless otherwise specified"?
<p/>
Alisdair: Leave open, but update proposed resolution to say something like "unless otherwise specified".
<p/>
General agreement that it should be corrected but not a stop-ship.
<p/>
Action: Update proposed wording for issue 2003 as above, but leave Open. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update [string.require]p/3:
</p>
<blockquote><p>
3 No <del><tt>erase()</tt> or</del> <tt>pop_back()</tt> member function
shall throw any exceptions.
</p></blockquote>





<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.4.4.4 [map.modifiers], 23.4.5.3 [multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
</p>
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
<p>
now has an added Remarks paragraph:
</p>
<blockquote><p>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</p></blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
<p/>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
<p/>
Proposed resolution:
</p>

<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We need <tt>is_convertible</tt>, not <tt>is_constructible</tt>, both in ordered and unordered containers. 
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Add a new Remarks element after 23.4.4.4 [map.modifiers] p. 1:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2010"></a>2010. <tt>is_* traits</tt> for binding operations can't be meaningfully specialized</h3>
<p><b>Section:</b> 20.8.9.1.1 [func.bind.isbind] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2011-05-19</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.9.1.1 [func.bind.isbind] says for <tt>is_bind_expression</tt>:
</p>

<blockquote><p>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</p></blockquote>

<p>
But it also says:
</p>

<blockquote><p>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</p></blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>


<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Alisdair recognises this is clearly a bug introduced by some wording he
wrote, the sole purpose of this metafunction is as a customization point
for users to write their own <tt>bind</tt>-expression types that participate
in the standard library <tt>bind</tt> protocol.  The consensus was that this
should be fixed in Madrid, moved to Open.
</p>

<p><i>[2011-05-13 Jonathan Wakely comments and provides proposed wording]</i></p>


<p>
The requirements are that <tt>is_bind_expression&lt;T&gt;::value</tt> is true when <tt>T</tt>
is a type returned from <tt>bind</tt>, false for any other type, except when
there's a specialization involving a user-defined type (N.B. 17.6.4.2.1 [namespace.std] 
means we don't need to say e.g. <tt>is_bind_expression&lt;string&gt;</tt> is false.)
<p/>
The obvious way to meet the requirements is for the primary template
to derive from <tt>integral_constant&lt;bool, false&gt;</tt> and for implementations
to provide specializations for the unspecified types returned from
<tt>bind</tt>.  User-defined specializations can do whatever they like, as long
as <tt>is_bind_expression::value</tt> is sane. There's no reason to forbid
users from defining <tt>is_bind_expression&lt;<i>user_defined_type</i>&gt;::value=false</tt>
if that's what they want to do.
<p/>
Similar reasoning applies to <tt>is_placeholder</tt>, but a further issue is
that 20.8.9.1.1 [func.bind.isbind] contains wording for <tt>is_placeholder</tt> but
contains no definition of it and the sub-clause name only refers to
<tt>is_bind_expression</tt>. The wording below proposes splitting paragraphs 3
and 4 of 20.8.9.1.1 [func.bind.isbind] into a new sub-clause covering
<tt>is_placeholder</tt>.
<p/>
If the template specializations added by the proposed wording are too
vague then they could be preceded by "for exposition only" comments
</p>

<p><i>[2011-05-18 Daniel comments and provides some refinements to the P&#47;R]</i></p>


<p>
Both <tt>bind</tt>-related type traits should take advantage of the
UnaryTypeTrait requirements. Additionally, the updated wording does not
imply that the implementation provides several specializations. Wording was 
used similar to the specification of the <tt>uses_allocator</tt> type trait 
(which unfortunately is not expressed in terms of BinaryTypeTrait requirements).
</p>

<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Change 20.8.9.1.1 [func.bind.isbind] to:</p>

<blockquote><pre>
namespace std {
  template&lt;class T&gt; struct is_bind_expression<ins>; <i>// see below</i></ins>
    <del>: integral_constant&lt;bool, <i>see below</i>&gt; { };</del>
}
</pre><blockquote><p>
-1- <tt>is_bind_expression</tt> can be used to detect function objects generated by <tt>bind</tt>. <tt>bind</tt> 
uses <tt>is_bind_expression</tt> to detect subexpressions. <del>Users may specialize this template to indicate 
that a type should be treated as a subexpression in a <tt>bind</tt> call.</del>
<p/>
-2- <del>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall 
be publicly derived from <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from 
<tt>integral_constant&lt;bool, false&gt;</tt></del><ins>Instantiations of the <tt>is_bind_expression</tt> template
shall meet the UnaryTypeTrait requirements ([meta.rqmts]). The implementation shall provide a definition
that has a BaseCharacteristic of <tt>true_type</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, otherwise 
it shall have a BaseCharacteristic of <tt>false_type</tt>. A program may specialize this template for a user-defined 
type <tt>T</tt> to have a BaseCharacteristic of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated 
as a subexpression in a <tt>bind</tt> call.</ins>.
<p/>
<del>-3- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders. Users may specialize this template to indicate 
a placeholder type.</del>
<p/>
<del>-4- If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt> shall be 
publicly derived from <tt>integral_constant&lt;int, J&gt;</tt>, otherwise from <tt>integral_constant&lt;int, 0&gt;</tt>.</del>
</p></blockquote></blockquote>
</li>
<li><p>Insert a new sub-clause immediately following sub-clause 20.8.9.1.1 [func.bind.isbind], the suggested
sub-clause tag is [func.bind.isplace]:
</p>
<h3><ins>20.8.9.1.?  Class template <tt>is_placeholder</tt>  [func.bind.isplace]</ins></h3> 
<blockquote><pre>
<ins>namespace std {
  template&lt;class T&gt; struct is_placeholder; <i>// see below</i>
}</ins>
</pre><blockquote><p>
<ins>-?- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders.</ins>
<p/>
<ins>-?- Instantiations of the <tt>is_placeholder</tt> template shall meet the UnaryTypeTrait requirements ([meta.rqmts]). 
The implementation shall provide a definition that has a BaseCharacteristic of <tt>integral_constant&lt;int, J&gt;</tt> 
if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, otherwise it shall have a BaseCharacteristic of 
<tt>integral_constant&lt;int, 0&gt;</tt>. A program may specialize this template for a user-defined type <tt>T</tt> 
to have a BaseCharacteristic of <tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> 
to indicate that <tt>T</tt> should be treated as a placeholder type.</ins>
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2011"></a>2011. Unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2011-06-25</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]&#47;5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
<i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]). After constructing 
a <tt>sentry</tt> object, if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, 
determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]&#47;5: 
</p>

<blockquote>
<p>
[&hellip;] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>

<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Consensus that all known implementations are consistent, and disagree with the
standard. Preference is to fix the standard before implementations start trying
to conform to the current spec, as the current implementations have the preferred
form. Howard volunteered to drught for Madrid, move to Open.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel Kr&uuml;gler volunteered to provide wording, interacting with Dietmar and
Bill. 
</p>

<p><i>[2011-06-24 Daniel comments and provides wording]</i></p>


<p>
The same problem applies to the output provided by <tt>const char*</tt> and similar
character sequences as of 27.7.3.6.4 [ostream.inserters.character] p. 5. and even for
single character output (!) as described in 27.7.3.6.4 [ostream.inserters.character] p. 1,
just consider the character value '-' where '-' is the sign character. In this case
Table 91 &mdash; "Fill padding" requires to pad after the sign, i.e. the output
for the program
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   char c = '-'; 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(2) &lt;&lt; c &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
According to the current wording this program should output "<tt>-*</tt>", but
all tested implementations output "<tt>*-</tt>" instead.

<p/>
I suggest to replace the reference to 22.4.2.2.2 [facet.num.put.virtuals] in all three places. 
It is not very complicated to describe the padding rules for simple character sequences "inline". 
A similar approach is used as for the <tt>money_put</tt> functions.
</p>



<p><b>Proposed resolution:</b></p>
<p>
The new wording refers to the FDIS numbering.
</p>
<ol>
<li><p>Change 21.4.8.9 [string.io]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
-5- <i>Effects</i>: Behaves as a formatted output function ([ostream.formatted.reqmts]). After constructing a sentry object,
if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, determines padding as <del>described
in [facet.num.put.virtuals],</del><ins>follows: A <tt>charT</tt> character sequence is produced, initially consisting of 
the elements defined by the range <tt>[str.begin(), str.end())</tt>. If <tt>str.size()</tt> is less than <tt>os.width()</tt>, 
then enough copies of <tt>os.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>os.width()</tt> 
characters. If <tt>(os.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters 
are placed after the character sequence; otherwise, they are placed before the character sequence. T</ins><del>t</del>hen 
inserts the resulting sequence of characters <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where 
<tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;1 as indicated (An additional editorial
fix is suggested for the first prototype declaration):</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c<del>}</del><ins>)</ins>;
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         unsigned char c);
</pre><blockquote><p>
-1- <i>Effects</i>: Behaves like a formatted inserter (as described in [ostream.formatted.reqmts]) of <tt>out</tt>. 
After a sentry object is constructed it inserts characters. In case <tt>c</tt> has type <tt>char</tt> and the 
character type of the stream is not <tt>char</tt>, then the character to be inserted is <tt>out.widen(c)</tt>; 
otherwise the character is <tt>c</tt>. Padding is determined as <del>described in [facet.num.put.virtuals]</del><ins>follows: 
A character sequence is produced, initially consisting of the insertion character. If <tt>out.width()</tt> is greater
than one, then enough copies of <tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of 
<tt>out.width()</tt> characters. If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, 
the fill characters are placed after the insertion character; otherwise, they are placed before the insertion 
character</ins>. <del><tt>width(0)</tt> is called.</del> The insertion character and any required padding are 
inserted into <tt>out</tt><ins>; then calls <tt>os.width(0)</tt></ins>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote><p>
[&hellip;]
<p/>
-5- Padding is determined as <del>described in [facet.num.put.virtuals]. The <tt>n</tt> characters starting at <tt>s</tt> 
are widened using <tt>out.widen</tt> ([basic.ios.members])</del><ins>follows: A character sequence is produced, initially 
consisting of the elements defined by the <tt>n</tt> characters starting at <tt>s</tt> widened using 
<tt>out.widen</tt> ([basic.ios.members]). If <tt>n</tt> is less than <tt>out.width()</tt>, then enough copies of 
<tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>out.width()</tt> characters. 
If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters are 
placed after the character sequence; otherwise, they are placed before the character sequence</ins>. The 
widened characters and any required padding are inserted into <tt>out</tt>. Calls <tt>width(0)</tt>.
</p></blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2012"></a>2012. Associative maps should insert <tt>pair</tt>, not <tt>tuple</tt></h3>
<p><b>Section:</b> 23.4 [associative] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-10-29 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something strange in the paragraphs 23.4.4.4 [map.modifiers] and 23.4.5.3 [multimap.modifiers]:
they both talk about <tt>tuple&lt;const key_type, mapped_type&gt;</tt> but I think they
should be talking about <tt>pair&lt;const key_type, mapped_type&gt;</tt> because, among
other reasons, a <tt>tuple</tt> is not convertible to a <tt>pair</tt>. If I replace <tt>tuple</tt>
with <tt>pair</tt> everything makes sense to me.
<p/>
The proposed resolution is obvious. 
</p>

<p><i>[
2010-11-07 Daniel comments
]</i></p>


<p>
This is by far not the only necessary fix within both sub-clauses. For details see the 2010-10-29 comment in 
<a href="lwg-active.html#2005">2005</a>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Paolo: Don't think we can do it now.
<p/>
Daniel K: Agrees. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply the resolution proposed by the 2010-10-29 comment in <a href="lwg-active.html#2005">2005</a>.
</p>





<hr>
<h3><a name="2013"></a>2013. Do library implementers have the freedom to add <tt>constexpr</tt>?</h3>
<p><b>Section:</b> 17.6.5.6 [constexpr.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-12 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that a particular function is not tagged as constexpr in the standard,
but that, in some particular implementation, it is possible to write it within
the constexpr constraints. If an implementer tags such a function as constexpr,
is that a violation of the standard or is it a conforming extension?</p>

<p>There are two questions to consider. First, is this allowed under the
as-if rule? Second, if it does not fall under as-if, is there
(and should there be) any special license granted to implementers
to do this anyway, sort of the way we allow elision of copy constructors
even though it is detectable by users?</p>

<p>I believe that this does not fall under "as-if", so implementers
probably don't have that freedom today. I suggest changing the WP
to grant it. Even if we decide otherwise, however, I suggest that
we make it explicit.</p>



<p><b>Proposed resolution:</b></p>
<p><i>In 17.6.4.6 [constexpr.functions], change paragraph 1 to:</i></p>

<blockquote><p>
<ins>This standard explicitly requires that certain standard library functions
are <tt>constexpr</tt> [dcl.constexpr].
Additionally, an implementation may declare any function to be <tt>constexpr</tt>
if that function's definition satisfies the necessary constraints.</ins>
Within any header that provides any non-defining declarations of <tt>constexpr</tt>
functions or constructors an implementation shall provide corresponding definitions. 
</p></blockquote>






<hr>
<h3><a name="2015"></a>2015. Incorrect pre-conditions for some type traits</h3>
<p><b>Section:</b> 20.9.4 [meta.unary] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2010-11-08 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to N3126&nbsp;&#x2011;&nbsp;3.9/9,</p>

<p>&quot;Scalar types, trivial class types (Clause 9), arrays of such types
and <i>cv</i>&#x2011;qualified versions of these types (3.9.3) are collectively
called <i>trivial types</i>.&quot;</p>

<p>Thus, an array (possibly of unknown bound) can be trivial type, non&#x2011;trivial type, 
or an array type whose triviality cannot be determined because its element type is incomplete.</p>

<p>According to N3126&nbsp;&#x2011;&nbsp;Table 45, preconditions for <tt>std::is_trivial</tt> are
defined as follows:</p>

<p>&quot;<tt>T</tt> shall be a complete type, (possibly <i>cv</i>-qualified) <tt>void</tt>, 
or an array of unknown bound&quot;</p>

<p>It seems that &quot;an array of unknown bound&quot; should be changed to &quot;an
array of unknown bound of a complete element type&quot;. Preconditions for
some other templates (e.g., <tt>std::is_trivially_copyable</tt>,
<tt>std::is_standard_layout</tt>, <tt>std::is_pod</tt>, and <tt>std::is_literal_type</tt>) should
be changed similarly.</p>

<p>On the other hand, some preconditions look too restrictive. For
example, <tt>std::is_empty</tt> and <tt>std::is_polymorphic</tt> might accept any
incomplete non&#x2011;class type.</p>

<p><i>[2011-02-18: Daniel provides wording proposal]</i></p>


<p>
While reviewing the individual preconditions I could find three different groups of
either too weakening or too strengthening constraints:
</p>
<ol>
<li><pre>is_empty/is_polymorphic/is_abstract/has_virtual_destructor:</pre>

<p>These traits can only apply for <em>non&#x2011;union class types</em>, otherwise the result must
always be false</p>
</li>

<li><pre>is_base_of:</pre>

<p>Similar to the previous bullet, but the current wording comes already near to that ideal,
it only misses to add the <em>non&#x2011;union</em> aspect.</p>
</li>

<li><pre>is_trivial/is_trivially_copyable/is_standard_layout/is_pod/is_literal_type:</pre>

<p>These traits always require that <tt>std::remove_all_extents&lt;T&gt;::type</tt> to be <tt><i>cv</i> void</tt> or 
a complete type.</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the pre-conditions of the following type traits in 20.9.4.3 [meta.unary.prop], Table 48 &mdash; Type property predicates:
</p>

<blockquote>
<table border="1">
<caption>Table 48 &mdash; Type property predicates</caption>
<tr>
<th>Template</th>
<th>Condition</th>
<th>Preconditions</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_trivial;</tt></td>
<td><tt>T</tt> is a trivial type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_trivially_copyable;</tt></td>
<td><tt>T</tt> is a trivially copyable<br/>
type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_standard_layout;</tt></td>
<td><tt>T</tt> is a standard-layout<br/>
type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_pod;</tt></td>
<td><tt>T</tt> is a POD type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_literal_type;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_empty;</tt></td>
<td><tt>T</tt> is a class type, but not a<br/>
union type, with no<br/>
non-static data members<br/>
other than bit-fields of<br/>
length 0, no virtual<br/>
member functions, no<br/>
virtual base classes, and<br/>
no base class B for which<br/>
<tt>is_empty&lt;B&gt;::value</tt> is<br/>
false.</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
(possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_polymorphic;</tt></td>
<td><tt>T</tt> is a polymorphic<br/>
class (10.3)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
type, (possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_abstract;</tt></td>
<td><tt>T</tt> is an abstract<br/>
class (10.4)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
type, (possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct has_virtual_destructor;</tt></td>
<td><tt>T</tt> has a virtual<br/>
destructor (12.4)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
(possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
Modify the pre-conditions of the following type traits in 20.9.6 [meta.rel], Table 50 &mdash; Type relationship predicates:
</p>

<blockquote>
<table border="1">
<caption>Table 50 &mdash; Type relationship predicates</caption>
<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class Base, class<br/>
Derived&gt;<br/>
struct is_base_of;</tt></td>
<td><tt>Base</tt> is a base class of<br/>
<tt>Derived</tt> (10) without<br/>
regard to cv-qualifiers<br/>
or <tt>Base</tt> and <tt>Derived</tt><br/>
are not unions and<br/>
name the same class<br/>
type without regard to<br/>
cv-qualifiers</td>
<td>If <tt>Base</tt> and <tt>Derived</tt> are<br/>
<ins>non&#x2011;union</ins> class types<br/>
and are different types<br/>
(ignoring possible cv-qualifiers)<br/>
then <tt>Derived</tt> shall be a complete<br/>
type. [ <i>Note</i>: Base classes that<br/>
are private, protected, or<br/>
ambigious are, nonetheless, base<br/>
classes. &mdash; <i>end note</i> ]</td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2016"></a>2016. <tt>Allocators</tt> must be no-throw <i>swappable</i></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-11-17 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Batavia meeting it turned out that there is a definition
hole for types satisfying the <tt>Allocators</tt> requirements: The problem
became obvious when it was discussed whether all <tt>swap</tt> functions 
of <tt>Containers</tt> with internal data handles can be safely tagged
with <tt>noexcept</tt> or not. While it is correct that the implicit
<tt>swap</tt> function of an allocator is required to be a no-throw
operation (because move/copy-constructors and assignment operators are
required to be no-throw functions), there are no such requirements
for specialized <tt>swap</tt> overloads for a particular allocator.
<p/>
But this requirement is essential because the <tt>Containers</tt> are
required to support <i>swappable</i> <tt>Allocators</tt>, when the value
<tt>allocator_traits&lt;&gt;::propagate_on_container_swap</tt> evaluates
to <tt>true</tt>.
</p>
<p><i>[2011-02-10 Alberto, Daniel, and Pablo collaborated on the proposed wording]</i></p>

<p>
The proposed resolution (based on N3225) attempts to solve the following problems:
</p>
<ol>
<li>Table 44 &mdash; Allocator requirements, expression rows 
<tt>X::propagate_on_container_copy_assignment</tt>, <tt>X::propagate_on_container_move_assignment</tt>, and
<tt>X::propagate_on_container_swap</tt> only describe operations, but no requirements. In fact, if and only
if these compile-time predicates evaluate to <tt>true</tt>, the <em>additional</em> requirements
<tt>CopyAssignable</tt>,  no-throw <tt>MoveAssignable</tt>, and no-throw lvalue <tt>Swappable</tt>, 
respectively, are imposed on the allocator types.</li>
<li>23.2.1 [container.requirements.general] p. 9 misses to refer to the correct swap conditions: The current wording does not relate to
17.6.3.2 [swappable.requirements] as it should and omits to mention that lvalues shall be swapped. Additional there is one
situation described twice in p. 8 and p. 9 (undefined behaviour unless <tt>a.get_allocator() == b.get_allocator()</tt>
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value == true</tt>), which should be cleaned up.</li>
</ol>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Adapt the following three rows from Table 44 &mdash; Allocator requirements:
</p>

<blockquote>
<table border="1">
<caption>Table 44 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td><tt>X::propagate_on_container_copy_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be copied<br/> 
when the client container is copy-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_move_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be moved<br/>
when the client container is move-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_swap</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be swapped<br/>
when the client container is swapped. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

</table>
</blockquote>


</li>

<li>
<p>Following 17.6.3.5 [allocator.requirements] p. 3 insert a new normative paragraph:</p>

<blockquote><p>
<ins>Note B: If <tt>X::propagate_on_container_copy_assignment::value</tt> is true, <tt>X</tt> shall 
satisfy the <tt>CopyAssignable</tt> requirements (Table 39  [copyassignable]). 
If <tt>X::propagate_on_container_move_assignment::value</tt> is true, <tt>X</tt> shall satisfy the 
<tt>MoveAssignable</tt> requirements (Table 38  [moveassignable]) and the move operation
shall not throw exceptions. If <tt>X::propagate_on_container_swap::value</tt> is true, lvalues of 
<tt>X</tt> shall be swappable (17.6.3.2 [swappable.requirements]) and the <tt>swap</tt> operation 
shall not throw exceptions.</ins>
</p></blockquote>
</li>

<li>
<p>Modify 23.2.1 [container.requirements.general] p. 8 and p. 9 as indicated:</p>

<blockquote><p>
8 - [..] The allocator may be replaced only via assignment or <tt>swap()</tt>. Allocator replacement is 
performed by copy assignment, move assignment, or swapping of the allocator only if 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</tt>,
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt>, 
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true 
within the implementation of the corresponding container operation. <del>The behavior of a call to 
a container's <tt>swap</tt> function is undefined unless the objects being swapped have allocators that compare 
equal or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true</del>. In all 
container types defined in this Clause, the member <tt>get_allocator()</tt> returns a copy of the allocator 
used to construct the container or, if that allocator has been replaced, a copy of the most recent replacement.
<p/>
9 - The expression <tt>a.swap(b)</tt>, for containers <tt>a</tt> and <tt>b</tt> of a standard container type 
other than <tt>array</tt>, shall exchange the values of <tt>a</tt> and <tt>b</tt> without invoking any move, 
copy, or swap operations on the individual container elements. <ins>Lvalues of a</ins><del>A</del>ny <tt>Compare</tt>, 
<tt>Pred</tt>, or <tt>Hash</tt> object<del>s</del> belonging to <tt>a</tt> and <tt>b</tt> shall be swappable 
and shall be exchanged by <del>unqualified calls to non-member</del> <ins>calling</ins> <tt>swap</tt> 
<ins>as described in 17.6.3.2 [swappable.requirements]</ins>. If <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> 
is <tt>true</tt>, then <ins>lvalues of <tt>allocator_type</tt> shall be swappable and</ins> the allocators of <tt>a</tt> and 
<tt>b</tt> shall also be exchanged using <ins>a</ins> <del>an unqualified call to non-member</del> 
<tt>swap</tt> <ins>call</ins> <ins>as described in 17.6.3.2 [swappable.requirements]</ins>. Otherwise, 
<del>they</del><ins>the allocators</ins> shall not be swapped, and the behavior is undefined unless
<tt>a.get_allocator() == b.get_allocator()</tt>. Every iterator referring to an element in one container before
the swap shall refer to the same element in the other container after the swap. It is unspecified whether an
iterator with value <tt>a.end()</tt> before the swap will have value <tt>b.end()</tt> after the swap.
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2018"></a>2018. <tt>regex_traits::isctype</tt> Returns clause is wrong</h3>
<p><b>Section:</b> 28.7 [re.traits] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-05-10</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>28.7 [re.traits] p. 12 says:</p>

<blockquote><p>
returns true if <tt>f</tt> bitwise or&#39;ed with the result of calling
<tt>lookup_classname</tt> with an iterator pair that designates the character
sequence &quot;w&quot; is not equal to <tt>0</tt> and <tt>c == '_'</tt>
</p></blockquote>

<p>
If the bitmask value corresponding to &quot;w&quot; has a non-zero value (which
it must do) then the bitwise or with any value is also non-zero, and
so <tt>isctype('_', f)</tt> returns true for any <tt>f</tt>. Obviously this is wrong,
since <tt>'_'</tt> is not in every <tt>ctype</tt> category.
</p>

<p>
There&#39;s a similar problem with the following phrases discussing the
&quot;blank&quot; char class.
</p>

<p><i>[2011-05-06: Jonathan Wakely comments and provides suggested wording]</i></p>


<p>
DR <a href="lwg-defects.html#2019">2019</a> added <tt>isblank</tt> support to <tt>&lt;locale&gt;</tt> which simplifies the
definition of <tt>regex_traits::isctype</tt> by removing the special case for the "blank" class.
<p/>
My suggestion for 2018 is to add a new table replacing the lists of
recognized names in the Remarks clause of <tt>regex_traits::lookup_classname</tt>. 
I then refer to that table in the Returns clause of <tt>regex_traits::isctype</tt> 
to expand on the "in an unspecified manner" wording which is too vague. The conversion 
can now be described using the "is set" term defined by 17.5.2.1.3 [bitmask.types] and
the new table to convey the intented relationship between e.g.
[[:digit:]] and <tt>ctype_base::digit</tt>, which is not actually stated in the
FDIS.
<p/>
The effects of <tt>isctype</tt> can then most easily be described in code,
given an "exposition only" function prototype to do the not-quite-so-unspecified conversion 
from <tt>char_class_type</tt> to <tt>ctype_base::mask</tt>.
<p/>
The core of LWG 2018 is the "bitwise or'ed" wording which gives the
wrong result, always evaluating to true for all values of <tt>f</tt>. That is
replaced by the condition <tt>(f&amp;x) == x</tt> where <tt>x</tt> is the result of calling
<tt>lookup_classname</tt> with "w".  I believe that's necessary, because the
"w" class could be implemented by an internal "underscore" class i.e.
<tt>x = _Alnum|_Underscore</tt> in which case <tt>(f&amp;x) != 0</tt> would give the wrong
result when <tt>f==_Alnum</tt>.
<p/>
The proposed resolution also makes use of <tt>ctype::widen</tt> which addresses
the problem that the current wording only talks about "w" and '_' which assumes 
<tt>charT</tt> is char.  There's still room for improvement here:
the regex grammar in 28.13 [re.grammar] says that the class names in the
table should always be recognized, implying that e.g. U"digit" should
be recognized by <tt>regex_traits&lt;char32_t&gt;</tt>, but the specification of
<tt>regex_traits::lookup_classname</tt> doesn't cover that, only mentioning
<tt>char</tt> and <tt>wchar_t</tt>.  Maybe the table should not distinguish narrow and
wide strings, but should just have one column and add wording to say
that <tt>regex_traits</tt> widens the name as if by using <tt>use_facet&lt;ctype&lt;charT&gt;&gt;::widen()</tt>.
<p/>
Another possible improvement would be to allow additional
implementation-defined extensions in <tt>isctype</tt>. An implementation is
allowed to support additional class names in <tt>lookup_classname</tt>, e.g.
[[:octdigit:]] for [0-7] or [[:bindigit:]] for [01], but the current
definition of isctype provides no way to use them unless <tt>ctype_base::mask</tt> 
also supports them.
</p>

<p><i>[2011-05-10: Alberto and Daniel perform minor fixes in the P&#47;R]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify 28.7 [re.traits] p. 10 as indicated:</p>
<blockquote><pre>
template &lt;class ForwardIterator&gt;
  char_class_type lookup_classname(
    ForwardIterator first, ForwardIterator last, bool icase = false) const;
</pre><blockquote><p>
-9- <i>Returns</i>: an unspecified value that represents the character classification named by the character
sequence designated by the iterator range [<tt>first</tt>,<tt>last</tt>). If the parameter <tt>icase</tt> is true then the
returned mask identifies the character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being matched.(footnote 335) The value returned shall
be independent of the case of the characters in the character sequence. If the name is not recognized
then returns a value that compares equal to 0.
<p/>
-10- <i>Remarks</i>: For <tt>regex_traits&lt;char&gt;</tt>, at least the <del>names "d", "w", "s", "alnum", "alpha", "blank",
"cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper" and "xdigit"</del><ins>narrow character
names in Table X</ins> shall be recognized. For <tt>regex_traits&lt;wchar_t&gt;</tt>, at least the <del>names L"d", L"w", 
L"s", L"alnum", L"alpha", L"blank", L"cntrl", L"digit", L"graph", L"lower", L"print", L"punct", L"space", L"upper" and 
L"xdigit"</del><ins>wide character names in Table X</ins> shall be recognized.
</p></blockquote></blockquote>
</li>

<li><p>Modify 28.7 [re.traits] p. 12 as indicated:</p>
<blockquote><pre>
bool isctype(charT c, char_class_type f) const;
</pre><blockquote><p>
-11- <i>Effects</i>: Determines if the character <tt>c</tt> is a member of the character classification represented by <tt>f</tt>.
<p/>
-12- <i>Returns</i>: Converts <tt>f</tt> into a value <tt>m</tt> of type <tt>std::ctype_base::mask</tt> in an unspecified manner, <del>and
returns true if <tt>use_facet&lt;ctype&lt;charT&gt; &gt;(getloc()).is(m, c)</tt> is true. Otherwise returns true
if <tt>f</tt> bitwise or'ed with the result of calling <tt>lookup_classname</tt> with an iterator pair that designates
the character sequence "w" is not equal to <tt>0</tt> and <tt>c == '_'</tt>, or if <tt>f</tt> bitwise or'ed with the result of
calling <tt>lookup_classname</tt> with an iterator pair that designates the character sequence "blank" is not
equal to <tt>0</tt> and <tt>c</tt> is one of an implementation-defined subset of the characters for which 
<tt>isspace(c, getloc())</tt> returns true, otherwise returns false.</del><ins>except that when <tt>f</tt> represents 
membership of a character class named in Table X, the corresponding <tt>ctype_base::mask</tt> value shall be set in <tt>m</tt>. 
Given the function prototype</ins>
</p><blockquote><pre>
<ins>template&lt;class C&gt;
   ctype_base::mask convert(typename regex_traits&lt;C&gt;::char_class_type);</ins>
</pre></blockquote>
<p><ins>the result is determined as if by</ins>
</p><blockquote><pre><ins>
ctype_base::mask m = convert&lt;charT&gt;(f);
const ctype&lt;charT&gt;&amp; ct = use_facet&lt;ctype&lt;charT&gt; &gt;(getloc());
if (ct.is(m, c))
  return true;
charT w[1] = { ct.widen('w') };
char_class_type x = lookup_classname(w, w+1);
if ((f&amp;x) == x &amp;&amp; c == ct.widen('_'))
  return true;
return false;
</ins></pre></blockquote>
<p><ins>[<i>Example</i>:</ins>
</p><blockquote><pre><ins>
regex_traits&lt;char&gt; t;
string d("d");
string u("upper");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert&lt;char&gt;(f); // m == ctype_base::digit|ctype_base::upper
</ins></pre></blockquote>
<p><ins>&mdash; <i>end example</i>]</ins></p>
<p><ins>[<i>Example</i>:</ins>
</p><blockquote><pre><ins>
regex_traits&lt;char&gt; t;
string w("w");
regex_traits&lt;char&gt;::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f); // returns true
t.isctype('_', f); // returns true
t.isctype(' ', f); // returns false
</ins></pre></blockquote>
<p><ins>&mdash; <i>end example</i>]</ins>
</p></blockquote></blockquote>
</li>

<li><p>At the end of [re.traits] add a new Table X &mdash; Character class names and corresponding ctype masks:</p>

<blockquote>
<table border="1">
<caption>Table X &mdash; Character class names and corresponding ctype masks</caption>

<tr>
<th>Narrow character name</th>
<th>Wide character name</th>
<th>Corresponding <tt>ctype_base::mask</tt> value</th>
</tr>
 
<tr>
<td><tt>"alnum"</tt></td>
<td><tt>L"alnum"</tt></td>
<td><tt>ctype_base::alnum</tt></td>
</tr>

<tr>
<td><tt>"alpha"</tt></td>
<td><tt>L"alpha"</tt></td>
<td><tt>ctype_base::alpha</tt></td>
</tr>

<tr>
<td><tt>"blank"</tt></td>
<td><tt>L"blank"</tt></td>
<td><tt>ctype_base::blank</tt></td>
</tr>

<tr>
<td><tt>"cntrl"</tt></td>
<td><tt>L"cntrl"</tt></td>
<td><tt>ctype_base::cntrl</tt></td>
</tr>

<tr>
<td><tt>"digit"</tt></td>
<td><tt>L"digit"</tt></td>
<td><tt>ctype_base::digit</tt></td>
</tr>

<tr>
<td><tt>"d"</tt></td>
<td><tt>L"d"</tt></td>
<td><tt>ctype_base::digit</tt></td>
</tr>

<tr>
<td><tt>"graph"</tt></td>
<td><tt>L"graph"</tt></td>
<td><tt>ctype_base::graph</tt></td>
</tr>

<tr>
<td><tt>"lower"</tt></td>
<td><tt>L"lower"</tt></td>
<td><tt>ctype_base::lower</tt></td>
</tr>

<tr>
<td><tt>"print"</tt></td>
<td><tt>L"print"</tt></td>
<td><tt>ctype_base::print</tt></td>
</tr>

<tr>
<td><tt>"punct"</tt></td>
<td><tt>L"punct"</tt></td>
<td><tt>ctype_base::punct</tt></td>
</tr>

<tr>
<td><tt>"space"</tt></td>
<td><tt>L"space"</tt></td>
<td><tt>ctype_base::space</tt></td>
</tr>

<tr>
<td><tt>"s"</tt></td>
<td><tt>L"s"</tt></td>
<td><tt>ctype_base::space</tt></td>
</tr>

<tr>
<td><tt>"upper"</tt></td>
<td><tt>L"upper"</tt></td>
<td><tt>ctype_base::upper</tt></td>
</tr>

<tr>
<td><tt>"w"</tt></td>
<td><tt>L"w"</tt></td>
<td><tt>ctype_base::alnum</tt></td>
</tr>

<tr>
<td><tt>"xdigit"</tt></td>
<td><tt>L"xdigit"</tt></td>
<td><tt>ctype_base::xdigit</tt></td>
</tr>

</table>
</blockquote> 
</li>
</ol>





<hr>
<h3><a name="2021"></a>2021. Further incorrect usages of <tt>result_of</tt></h3>
<p><b>Section:</b> 20.8.9.1.2 [func.bind.bind], 30.6.1 [futures.overview], 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-07 <b>Last modified:</b> 2011-06-13</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="lwg-defects.html#2017">2017</a> points out some incorrect usages of <tt>result_of</tt> in the
declaration of the function call operator overload of <tt>reference_wrapper</tt>,
but there are more such specification defects:
</p>
<ol>
<li>According to 20.8.9.1.2 [func.bind.bind] p. 3: 
<blockquote><p>
[..] The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt>INVOKE(fd, v1, v2, ..., vN, result_of&lt;FD cv (V1, V2, ..., VN)&gt;::type)</tt> [..]
</p></blockquote>
<p>
but <tt>fd</tt> is defined as &quot;an lvalue of type <tt>FD</tt> constructed from <tt>std::forward&lt;F&gt;(f)</tt>&quot;. This means that
the above usage must refer to <tt>result_of&lt;FD cv <strong>&amp;</strong> (V1, V2, ..., VN)&gt;</tt> instead.
</p>
</li>
<li><p>
Similar in 20.8.9.1.2 [func.bind.bind] p. 10 bullet 2 we have:
</p>
<blockquote><p>
if the value of <tt>is_bind_expression&lt;TiD&gt;::value</tt> is true, the argument is <tt>tid(std::forward&lt;Uj&gt;(uj)...)</tt>
and its type <tt>Vi</tt> is <tt>result_of&lt;TiD cv (Uj...)&gt;::type</tt>
</p></blockquote>
<p>
Again, <tt>tid</tt> is defined as &quot;lvalue of type <tt>TiD</tt> constructed from <tt>std::forward&lt;Ti&gt;(ti)</tt>&quot;. This means that
the above usage must refer to <tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj...)&gt;</tt> instead. We also have similar defect as in
<a href="lwg-defects.html#2017">2017</a> in regard to the argument types, this leads us to the further corrected form 
<tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj<strong>&amp;&amp;</strong>...)&gt;</tt>. This is not the end: Since the <tt>Vi</tt>
are similar sensitive to the argument problem, the last part must say: 
<p/>
&quot;[..] its type <tt>Vi</tt> is <tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj<strong>&amp;&amp;</strong>...)&gt;::type <strong>&amp;&amp;</strong>&quot;</tt>
<p/>
(The bound arguments <tt>Vi</tt> can never be <tt>void</tt> types, therefore we don't need 
to use the more defensive <tt>std::add_rvalue_reference</tt> type trait)
</p>
</li>
<li><p>The function template <tt>async</tt> is declared as follows (the other overload has the same problem):</p>
<blockquote><pre>
template &lt;class F, class... Args&gt;
future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;
async(F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote><p>
This usage has the some same problems as we have found in <tt>reference_wrapper</tt> (<a href="lwg-defects.html#2017">2017</a>) and more: According to
the specification in 30.6.8 [futures.async] the effective result type is that of the call of
</p><blockquote><pre>
INVOKE(decay_copy(std::forward&lt;F&gt;(f)), decay_copy(std::forward&lt;Args&gt;(args))...)
</pre></blockquote><p>
First, <tt>decay_copy</tt> potentially modifies the effective types to <tt>decay&lt;F&gt;::type</tt> and <tt>decay&lt;Args&gt;::type...</tt>.
Second, the current specification is not really clear, what the value category of callable type or the arguments shall be: According
to the second bullet of 30.6.8 [futures.async] p. 3:
</p>
<blockquote><p>
Invocation of the deferred function evaluates <tt>INVOKE(g, xyz)</tt> where <tt>g</tt> is the stored value of 
<tt>decay_copy(std::forward&lt;F&gt;(f))</tt> and <tt>xyz</tt> is the stored copy of 
<tt>decay_copy(std::forward&lt;Args&gt;(args))...</tt>.
</p></blockquote><p>
This seems to imply that lvalues are provided in contrast to the direct call expression of 30.6.8 [futures.async] p. 2
which implies rvalues instead. The specification needs to be clarified.
</p>
</li>
</ol>

<p><i>[2011-06-13: Daniel comments and refines the proposed wording changes]</i></p>


<p>The feedback obtained following message c++std-lib-30745  and follow-ups point to the intention, that 
the implied provision of lvalues due to named variables in <tt>async</tt> should be provided as rvalues to support
move-only types, but the functor type should be forwarded as lvalue in <tt>bind</tt>.
<p/>
If <tt>bind</tt> were newly invented, the value strategy could be improved, because now we have a preference of
<i>ref</i> <tt>&amp;</tt> qualified function call operator overloads. But such a change seems to be too late now.
User-code that needs to bind a callable object with an <i>ref</i> <tt>&amp;&amp;</tt> qualified function call
operator (or conversion function to function pointer) needs to use a corresponding wrapper similar to <tt>reference_wrapper</tt>
that forwards the reference as rvalue-reference instead.
<p/>
The wording has been adapted to honor these observations and to fit to FDIS numbering as well.</p>


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the FDIS.
</p>
<ol>
<li>
<p>Change 20.8.9.1.2 [func.bind.bind] p. 3 as indicated:</p>

<blockquote><pre>
template&lt;class F, class... BoundArgs&gt;
  <i>unspecified</i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</pre><blockquote><p>
-2- <i>Requires</i>: <tt>is_constructible&lt;FD, F&gt;::value</tt> shall be true. For each <tt>Ti</tt> in <tt>BoundArgs</tt>, 
<tt>is_constructible&lt;TiD, Ti&gt;::value</tt> shall be true. <tt><i>INVOKE</i>(fd, w1, w2, ..., wN)</tt> (20.8.2) shall 
be a valid expression for some values <tt>w1</tt>, <tt>w2</tt>, ..., <tt>wN</tt>, where <tt>N == sizeof...(bound_args)</tt>.
<p/>
-3- <i>Returns</i>: A forwarding call wrapper <tt>g</tt> with a weak result type (20.8.2). The effect of 
<tt>g(u1, u2, ..., uM)</tt> shall be <tt>INVOKE(fd, <ins>std::forward&lt;V1&gt;(</ins>v1<ins>)</ins>, 
<ins>std::forward&lt;V2&gt;(</ins>v2<ins>)</ins>, ..., <ins>std::forward&lt;VN&gt;(</ins>vN<ins>)</ins>, 
result_of&lt;FD <i>cv</i> <ins>&amp;</ins> (V1, V2, ..., VN)&gt;::type)</tt>, where <i>cv</i> represents 
the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments <tt>v1</tt>, 
<tt>v2</tt>, ..., <tt>vN</tt> are determined as specified below. [&hellip;]
</p></blockquote></blockquote>

</li>

<li>
<p>Change 20.8.9.1.2 [func.bind.bind] p. 7 as indicated:</p>

<blockquote><pre>
template&lt;class R, class F, class... BoundArgs&gt;
   <i>unspecified</i> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</pre><blockquote><p>
-6- <i>Requires</i>: <tt>is_constructible&lt;FD, F&gt;::value</tt> shall be true. For each <tt>Ti</tt> in <tt>BoundArgs</tt>, 
<tt>is_constructible&lt;TiD, Ti&gt;::value</tt> shall be true. <tt><i>INVOKE</i>(fd, w1, w2, ..., wN)</tt> shall be a valid 
expression for some values <tt>w1</tt>, <tt>w2</tt>, ..., <tt>wN</tt>, where <tt>N == sizeof...(bound_args)</tt>.
<p/>
-7- <i>Returns</i>: A forwarding call wrapper <tt>g</tt> with a nested type <tt>result_type</tt> defined as a synonym for
<tt>R</tt>. The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt>INVOKE(fd, <ins>std::forward&lt;V1&gt;(</ins>v1<ins>)</ins>, 
<ins>std::forward&lt;V2&gt;(</ins>v2<ins>)</ins>, ..., <ins>std::forward&lt;VN&gt;(</ins>vN<ins>)</ins>, R)</tt>, where 
the values and types of the bound arguments <tt>v1</tt>, <tt>v2</tt>, ..., <tt>vN</tt> are determined as specified below. [&hellip;]
</p></blockquote></blockquote>

</li>

<li>
<p>Change 20.8.9.1.2 [func.bind.bind] p. 10 as indicated:</p>

<blockquote><p>
-10- The values of the <i>bound arguments</i> <tt>v1</tt>, <tt>v2</tt>, ..., <tt>vN</tt> and their corresponding types <tt>V1</tt>, 
<tt>V2</tt>, ..., <tt>VN</tt> depend on the types <tt>TiD</tt> derived from the call to bind and the <i>cv</i>-qualifiers 
<i>cv</i> of the call wrapper <tt>g</tt> as follows:</p>
<ul>
<li>if <tt>TiD</tt> is <tt>reference_wrapper&lt;T&gt;</tt>, the argument is <tt>tid.get()</tt> and its type <tt>Vi</tt> 
is <tt>T&amp;</tt>;</li>
<li>if the value of <tt>is_bind_expression&lt;TiD&gt;::value</tt> is <tt>true</tt>, the argument is 
<tt>tid(std::forward&lt;Uj&gt;(uj)...)</tt> and its type <tt>Vi</tt> is 
<tt>result_of&lt;TiD <i>cv</i> <ins>&amp;</ins> (Uj<ins>&amp;&amp;</ins>...)&gt;::type<ins>&amp;&amp;</ins></tt>;</li>
<li>if the value <tt>j</tt> of <tt>is_placeholder&lt;TiD&gt;::value</tt> is not zero, the argument is 
<tt>std::forward&lt;Uj&gt;(uj)</tt> and its type <tt>Vi</tt> is <tt>Uj&amp;&amp;</tt>;</li>
<li>otherwise, the value is <tt>tid</tt> and its type <tt>Vi</tt> is <tt>TiD <i>cv</i> &amp;</tt>.</li>
</ul>
</blockquote>

</li>

<li>
<p>
This resolution assumes that the wording of 30.6.8 [futures.async] is intended to provide rvalues
as arguments of <tt>INVOKE</tt>.
</p>

<p>
Change the function signatures in header <tt>&lt;future&gt;</tt> synopsis 30.6.1 [futures.overview] p. 1
and in 30.6.8 [futures.async] p. 1 as indicated:
</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type</ins>...)&gt;::type&gt;
async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args>
future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type</ins>...)&gt;::type&gt;
async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>
</li>

<li>
<p>Change 30.6.8 [futures.async] as indicated: (Remark: There is also a tiny editorial correction 
in p. 4 that completes one <tt>::</tt> scope specifier)
</p>

<blockquote><p>
-3- <i>Effects</i>: [&hellip;]
</p>
<ul>
<li>[&hellip;]</li>
<li>if <tt>policy &amp; launch::deferred</tt> is non-zero &mdash; Stores <tt><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</tt> 
and <tt><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</tt> in the shared state. These copies of <tt>f</tt> and 
<tt>args</tt> constitute a <i>deferred function</i>. Invocation of the deferred function evaluates 
<tt><i>INVOKE</i>(<ins>std::move(</ins>g<ins>)</ins>, <ins>std::move(</ins>xyz<ins>)</ins>)</tt>
where <tt>g</tt> is the stored value of <tt><i>DECAY_COPY</i>(std::forward&lt;F&gt;(f))</tt> and <tt>xyz</tt> is the 
stored copy of <tt><i>DECAY_COPY</i>(std::forward&lt;Args&gt;(args))...</tt>. The shared state is not made ready 
until the function has completed. The first call to a non-timed waiting function (30.6.4) on an asynchronous
return object referring to this shared state shall invoke the deferred function in the thread that
called the waiting function. Once evaluation of <tt><i>INVOKE</i>(<ins>std::move(</ins>g<ins>)</ins>, 
<ins>std::move(</ins>xyz<ins>)</ins>)</tt> begins, the function is no longer considered deferred. [ <i>Note</i>: If 
this policy is specified together with other policies, such as when using a <tt>policy</tt> value of 
<tt>launch::async | launch::deferred</tt>, implementations should defer invocation or the selection of 
the policy when no more concurrency can be effectively exploited. &mdash; <i>end note</i> ]</li>
</ul>
</blockquote>

<blockquote><p>
-4- <i>Returns</i>: an object of type 
<tt>future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type</ins>...)&gt;:<ins>:</ins>type&gt;</tt> 
that refers to the associated asynchronous state created by this call to <tt>async</tt>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2033"></a>2033. Preconditions of <tt>reserve</tt>, <tt>shrink_to_fit</tt>, and <tt>resize</tt> functions</h3>
<p><b>Section:</b> 23.3.6.3 [vector.capacity], 23.3.3.3 [deque.capacity] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2011-02-20 <b>Last modified:</b> 2011-06-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have several questions with regard to the working paper N3225 (C++0x working draft):
</p>
<ol>
<li><p>
Where the working draft specifies preconditions for <tt>shrink_to_fit</tt>
member function of <tt>std::vector</tt> and <tt>std::deque</tt>?
</p></li>
<li><p>
Where the working draft specifies preconditions for '<tt>void reserve(size_type n)</tt>' 
member function of <tt>std::vector</tt>?
</p></li>
<li><p>
Does a call to '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> require
the element type to be <tt>DefaultConstructible</tt>? If yes, why such
requirement is not listed in the <i>Requires</i> paragraph?
</p></li>
<li><p>
Does a call to '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> require
the element type to be <tt>MoveAssignable</tt> because the call <tt>erase(begin() + sz, end())</tt> 
mentioned in the <i>Effects</i> paragraph would require the element type to be <tt>MoveAssignable</tt>?
</p></li>
<li><p>
Why <tt>CopyInsertable</tt> requirement is used for '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> 
instead of <tt>MoveInsertable</tt> requirement?
</p></li>
</ol>

<p><i>[2011-06-12: Daniel comments and provides wording]</i></p>

<p>According to my understanding of the mental model of vector (and to some parts for deque) the 
some requirements are missing in the standard as response to above questions:</p>
<ol>
<li>The preconditions of <tt>shrink_to_fit</tt> for both <tt>std::vector</tt> and <tt>std::deque</tt>
should impose the <tt>MoveInsertable</tt> requirements. The reason for this is, that these containers
can host move-only types. For a container type <tt>X</tt> the C++03 idiom <tt>X(*this).swap(*this)</tt>
imposes the <tt>CopyInsertable</tt> requirements which would make the function call ill-formed,
which looks like an unacceptable restriction to me. Assuming the committee decides to support the
move-only case, further wording has to be added for the situation where such a move-only type could
throw an exception, because this can leave the object in an unspecified state. This seems consistent
with the requirements of <tt>reserve</tt>, which seems like a very similar function to me (for
<tt>vector</tt>). And this brings us smoothly to the following bullet:
</li>

<li><p>I agree that we are currently missing to specify the preconditions of the <tt>reserve</tt> function.
My interpretation of the mental model of this function is that it should work for move-only types, which
seems to be supported by the wording used in 23.3.6.3 [vector.capacity] p2:
</p>
<blockquote><p>
[&hellip;] If an exception is thrown other than by the move constructor of a non-CopyInsertable type, 
there are no effects.
</p></blockquote>
<p>
Given this statement, the appropriate requirement is <tt>MoveInsertable</tt> into the <tt>vector</tt>.
</p>
</li>

<li>I agree that <tt>vector::resize(size_type)</tt> misses to list the <tt>DefaultConstructible</tt>
requirements.
</li>

<li>Unfortunately the current specification in terms of <tt>erase</tt> implies the <tt>MoveAssignable</tt>
requirements. I don't think that this implication is intended. This function requires "append" and 
"pop-back" effects, respectively, where the former can be realized in terms of <tt>MoveInsertable</tt> 
requirements. The same fix in regard to using <tt>pop_back</tt> instead of <tt>erase</tt> is necessary 
for the two argument overload of <tt>resize</tt> as well (no <tt>MoveAssignable</tt> is required).
</li>

<li>The <tt>CopyInsertable</tt> requirement is incorrect and should be <tt>MoveInsertable</tt> instead.</li>
</ol>

<p>In addition to above mentioned items, the proposed resolution adds a linear complexity bound for 
<tt>shrink_to_fit</tt> and attempts to resolve the related issue <a href="lwg-active.html#2066">2066</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Edit 23.3.3.3 [deque.capacity] as indicated [Remark: The suggested change of p4 is
not redundant, because <tt>CopyInsertable</tt> is not necessarily a refinement of <tt>MoveInsertable</tt>
in contrast to the fact that <tt>CopyConstructible</tt> is a refinement of <tt>MoveConstructible</tt>]:</p>

<blockquote><pre>
void resize(size_type sz);
</pre><blockquote><p>
-1- <i>Effects</i>: If <tt>sz &lt;= size()</tt>, equivalent to <del><tt>erase(begin() + sz, 
end());</tt></del><ins>calling <tt>pop_back()</tt> <tt>size() - sz</tt> times</ins>. If 
<tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> value-initialized elements to the sequence.
<p/>
-2- Requires: <tt>T</tt> shall be <ins><tt>MoveInsertable</tt> into <tt>*this</tt> and</ins> <tt>DefaultConstructible</tt>.
</p></blockquote></blockquote>

<blockquote><pre>
void resize(size_type sz, const T&amp; c);
</pre><blockquote><p>
-3- <i>Effects</i>: <ins>If <tt>sz &lt;= size()</tt>, equivalent to calling <tt>pop_back()</tt> 
<tt>size() - sz</tt> times. If <tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> copies of <tt>c</tt> 
to the sequence.</ins>
</p><blockquote><pre>
<del>if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size())
  erase(begin()+sz, end());
else
  ; <i>// do nothing</i></del>
</pre></blockquote>
<p>
-4- <i>Requires</i>: <tt>T</tt> shall be <ins><tt>MoveInsertable</tt> into <tt>*this</tt> and</ins> 
<tt>CopyInsertable</tt> into <tt>*this</tt>.
</p></blockquote></blockquote>

<blockquote><pre>
void shrink_to_fit();
</pre><blockquote><p>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Takes at most linear time in the size of the sequence.</ins>
<p/>
-5- <i>Remarks</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce memory use <ins>but does
not change the size of the sequence</ins>. [ <i>Note</i>: The request is non-binding to allow latitude 
for implementation-specific optimizations. &mdash; <i>end note</i> ]
</p></blockquote></blockquote>
</li>

<li><p>Edit 23.3.6.3 [vector.capacity] as indicated including edits that also resolve <a href="lwg-active.html#2066">2066</a> 
[Remark: The combined listing of <tt>MoveInsertable</tt> and <tt>CopyInsertable</tt> before p12 is not redundant, 
because <tt>CopyInsertable</tt> is not necessarily a refinement of <tt>MoveInsertable</tt> in contrast to the 
fact that <tt>CopyConstructible</tt> is a refinement of <tt>MoveConstructible</tt>]:</p>

<p>[&hellip;]</p>

<blockquote><pre>
void reserve(size_type n);
</pre><blockquote><p>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.</ins>
<p/>
-2- <i>Effects</i>: A directive that informs a vector of a planned change in size, so that it can manage the storage
allocation accordingly. After <tt>reserve()</tt>, <tt>capacity()</tt> is greater or equal to the argument of reserve if
reallocation happens; and equal to the previous value of <tt>capacity()</tt> otherwise. Reallocation happens
at this point if and only if the current capacity is less than the argument of <tt>reserve()</tt>. If an exception
is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> type, there are no effects.
<p/>
-3- <i>Complexity</i>: It does not change the size of the sequence and takes at most linear time in the size of
the sequence.
<p/>
-4- <i>Throws</i>: <tt>length_error</tt> if <tt>n &gt; max_size()</tt>.[footnote 266]
<p/>
-5- <i>Remarks</i>: Reallocation invalidates all the references, pointers, and iterators referring to the elements
in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after
a call to <tt>reserve()</tt> until the time when an insertion would make the size of the vector greater than
the value of <tt>capacity()</tt>.
</p></blockquote></blockquote>

<blockquote><pre>
void shrink_to_fit();
</pre><blockquote><p>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Takes at most linear time in the size of the sequence.</ins>
<p/>
-6- <i>Remarks</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[ <i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end note</i> ]
<ins>If an exception is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there 
are no effects.</ins>
</p></blockquote></blockquote>

<p>[&hellip;]</p>

<blockquote><pre>
void resize(size_type sz);
</pre><blockquote><p>
-9- <i>Effects</i>: If <tt>sz &lt;= size()</tt>, equivalent to <del><tt>erase(begin() + sz, end());</tt></del><ins>calling 
<tt>pop_back()</tt> <tt>size() - sz</tt> times</ins>. If <tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> 
value-initialized elements to the sequence.
<p/>
-10- <i>Requires</i>: <tt>T</tt> shall be <tt><del>Copy</del><ins>Move</ins>Insertable</tt> into <tt>*this</tt> 
<ins>and <tt>DefaultConstructible</tt></ins>.
<p/>
<ins>-??- <i>Remarks</i>: If an exception is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> 
<tt>T</tt> there are no effects.</ins>
</p></blockquote></blockquote>

<blockquote><pre>
void resize(size_type sz, const T&amp; c);
</pre><blockquote><p>
-11- <i>Effects</i>: <ins>If <tt>sz &lt;= size()</tt>, equivalent to calling <tt>pop_back()</tt> 
<tt>size() - sz</tt> times. If <tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> copies of <tt>c</tt> 
to the sequence.</ins>
</p><blockquote><pre>
<del>if (sz &gt; size())
  insert(end(), sz-size(), c);
else if (sz &lt; size())
  erase(begin()+sz, end());
else
  ; <i>// do nothing</i></del>
</pre></blockquote><p>
<ins>-??- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt> and 
<tt>CopyInsertable</tt> into <tt>*this</tt>.</ins>
<p/>
-12- <i><del>Requires</del><ins>Remarks</ins></i>: If an exception is thrown other than by the move constructor of a 
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.
</p></blockquote></blockquote>

</li>

</ol>





<hr>
<h3><a name="2035"></a>2035. Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-06-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="lwg-active.html#2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.2.1 [iterator.requirements.general] and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="lwg-defects.html#2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.2.1 [iterator.requirements.general] to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.5 [unord.req] on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>17.6.3.2 [swappable.requirements] p. 5:</p>

<blockquote><p>
5 A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>17.6.3.5 [allocator.requirements], Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>20.6.3.2 [pointer.traits.functions]:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>21.4.3 [string.iterators] p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote>
</li>

<li><p>22.4.5.1.2 [locale.time.get.virtuals] p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.1 [container.requirements.general] p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(24.2.1 [iterator.requirements.general])</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.3 [sequence.reqmts] p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 [associative.reqmts] p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.5 [unord.req] p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.2.1 [iterator.requirements.general] p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
5 Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.2.2 [iterator.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.2.3 [input.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.2.4 [output.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.2.5 [forward.iterators], as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.2.6 [bidirectional.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2038"></a>2038. Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-04-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 17.6.3.2 [swappable.requirements] there is a mention of "dereferenceable object"; in 
17.6.3.5 [allocator.requirements] the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.6.3.2 [pointer.traits.functions] refers to a 
"dereferenceable pointer"; in 22.4.5.1.2 [locale.time.get.virtuals]&#47;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="lwg-active.html#2035">2035</a> solves this
issue as well.</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2040"></a>2040. Missing type traits related to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 20.9 [meta] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-03-03 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>
was suggested, it concentrated on constructions, assignments, and destructions, but overlooked 
to complement the single remaining compiler-support trait</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_convertible;
</pre></blockquote>

<p>with the no-throw and triviality related aspects as it had been done with the other
expression-based traits. Specifically, the current specification misses to add the
following traits:
</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_nothrow_convertible;
template &lt;class From, class To&gt; struct is_trivially_convertible;
</pre></blockquote>

<p>In particular the lack of <tt>is_nothrow_convertible</tt> is severly restricting. This
was recently recognized when the proposal for <tt>decay_copy</tt> was prepared by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3255.html">n3255</a>.
There does not exist a portable means to define the correct conditional <tt>noexcept</tt>
specification for the <tt>decay_copy</tt> function template, which is declared as:</p>

<blockquote><pre>
template &lt;class T&gt; 
typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v) noexcept(<i>???</i>);
</pre></blockquote>

<p>The semantics of <tt>decay_copy</tt> bases on an implicit conversion which again
influences the overload set of functions that are viable here. In most circumstances
this will have the same effect as comparing against the trait 
<tt>std::is_nothrow_move_constructible</tt>, but there is no guarantee for that being
the right answer. It is possible to construct examples, where this would lead
to the false result, e.g.</p>

<blockquote><pre>
struct S {
  S(const S&amp;) noexcept(false);
 
  template&lt;class T&gt;
  explicit S(T&amp;&amp;) noexcept(true);
};
</pre></blockquote>

<p><tt>std::is_nothrow_move_constructible</tt> will properly honor the explicit template
constructor because of the direct-initialization context which is part of the
<tt>std::is_constructible</tt> definition and will in this case select it, such that
<tt>std::is_nothrow_move_constructible&lt;S&gt;::value == true</tt>, but if we had
the traits <tt>is_nothrow_convertible</tt>, <tt>is_nothrow_convertible&lt;S, S&gt;::value</tt>
would evaluate to <tt>false</tt>, because it would use the copy-initialization context
that is part of the <tt>is_convertible</tt> definition, excluding any explicit
constructors and giving the opposite result.</p>

<p>The <tt>decay_copy</tt> example is surely not one of the most convincing examples, but
<tt>is_nothrow_convertible</tt> has several use-cases, and can e.g. be used to express
whether calling the following implicit conversion function could throw an exception or not:</p>

<blockquote><pre>
template&lt;class T, class U&gt;
T implicit_cast(U&amp;&amp; u) noexcept(is_nothrow_convertible&lt;U, T&gt;::value) 
{
  return std::forward&lt;U&gt;(u);
}
</pre></blockquote>

<p>Therefore I suggest to add the missing trait <tt>is_nothrow_convertible</tt> and for
completeness also the missing trait <tt>is_trivially_convertible</tt> to 20.9 [meta].</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel K: This is a new feature so out of scope.
<p/>
Pablo: Any objections to moving 2040 to Open?
<p/>
No objections. 
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Ammend the following declarations to the header <tt>&lt;type_traits&gt;</tt> synopsis
in 20.9.2 [meta.type.synop]:</p>

<blockquote><pre>
namespace std {
  &hellip;
  // 20.9.6, type relations:
  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;
  <ins>template &lt;class From, class To&gt; struct is_trivially_convertible;</ins>
  <ins>template &lt;class From, class To&gt; struct is_nothrow_convertible;</ins>

  &hellip;
}
</pre></blockquote>
</li>

<li><p>Modify Table 51 &mdash; &quot;Type relationship predicates&quot; as indicated. The removal of the
remaining traces of the trait <tt>is_explicitly_convertible</tt> is an editorial
step, it was removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html">n3047</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 51 &mdash; Type relationship predicates</caption>

<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

<tr>
<td><tt>template &lt;class From, class To&gt;<br/>
struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound, or<br/>
(possibly cv-qualified) <tt>void</tt><br/>
types.</td>
</tr>

<tr>
<td><del><tt>template &lt;class From, class To&gt;<br/>
struct is_explicitly_convertible;</tt></del></td>
<td><del><tt>is_constructible&lt;To, From&gt;::value</tt></del></td>
<td><del>a synonym for a two-argument<br/>
version of <tt>is_constructible</tt>.<br/>
An implementation may define it<br/>
as an alias template.</del></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_trivially_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
to call no operation that is<br/>
not trivial ([basic.types], [special]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_nothrow_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
not to throw any<br/>
exceptions ([expr.unary.noexcept]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2043"></a>2043. <tt>std{in,out,err}</tt> should be usable as field names</h3>
<p><b>Section:</b> 27.9.2 [c.files] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2011-03-23 <b>Last modified:</b> 2011-04-18</p>
<p><b>View all other</b> <a href="lwg-index.html#c.files">issues</a> in [c.files].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
People often define structs and classes with fields named <tt>stdin</tt>,
<tt>stdout</tt>, or <tt>stderr</tt>. According to 27.9.2 [c.files], 
though, these are macros.
<p/>
glibc defines them to themselves, allowing their non-portable use as
field names, while the Mac OS X libc defines them to either <tt>__stdoutp</tt>
or <tt>(&amp;__sF[1])</tt>, etc depending on <tt>__DARWIN_UNIX03</tt>. It's possible to
allow their use while, as far as I can see, only requiring minor
changes to various libc's, so C++1x should allow it.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>In 27.9.2 [c.files] add "stderr", "stdin", and "stdout" to a new Values section in Table
134 &mdash; Header <tt>&lt;cstdio&gt;</tt> synopsis:</p>

<blockquote>
<table border="1">
<caption>134 &mdash; Header <tt>&lt;cstdio&gt;</tt> synopsis</caption>

<tr>
<th colspan="6" style="text-align:center;">Type Name(s)</th>
</tr>

<tr>
<th colspan="6" style="text-align:left;">Macros:</th>
</tr>

<tr>
<td><tt>BUFSIZ</tt></td>
<td><tt>FOPEN_MAX</tt></td>
<td><tt>SEEK_CUR</tt></td>
<td><tt>TMP_MAX</tt></td>
<td><tt>_IONBF</tt></td>
<td><tt>stdout</tt></td>
</tr>

<tr>
<td><tt>EOF</tt></td>
<td><tt>L_tmpnam</tt></td>
<td><tt>SEEK_END</tt></td>
<td><tt>_IOFBF</tt></td>
<td><tt>stderr</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>FILENAME_MAX</tt></td>
<td><tt>NULL &lt;cstdio&gt;</tt></td>
<td><tt>SEEK_SET</tt></td>
<td><tt>_IOLBF</tt></td>
<td><tt>stdin</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<th style="text-align:left;">Types:</th>
<td><tt>FILE</tt></td>
<td><tt>fpos_t</tt></td>
<td><tt>size_t &lt;cstdio&gt;</tt></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>

<tr>
<th colspan="6" style="text-align:left;">Functions:</th>
</tr>

<tr>
<td colspan="6" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<th colspan="6" style="text-align:left;"><ins>Values:</ins></th>
</tr>

<tr>
<td><ins><tt>stderr</tt></ins></td>
<td><ins><tt>stdin</tt></ins></td>
<td><ins><tt>stdout</tt></ins></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Add a new paragraph after paragraph 2 as indicated:</p>

<blockquote><p>
2 Calls to the function <tt>tmpnam</tt> with an argument of <tt>NULL</tt> may 
introduce a data race (17.6.5.9) with other calls to <tt>tmpnam</tt> with an 
argument of <tt>NULL</tt>.<br/>
See also: ISO C 7.9, Amendment 1 4.6.2.
<p/>
<ins>? The macros <tt>stderr</tt>, <tt>stdin</tt>, and <tt>stdout</tt> shall 
expand to <tt>stderr</tt>, <tt>stdin</tt>, and <tt>stdout</tt>, respectively. 
[<i>Note:</i> This allows uses of <tt>#ifdef</tt> to detect their presence, 
while allowing code in other scopes to use them as identifiers. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>

<li><p>In C.2 [diff.library] add "stderr", "stdin", and "stdout" to 
Table 150 &mdash; Standard values:</p>

<blockquote>
<table border="1">
<caption>Table 150 &mdash; Standard values</caption>

<tr>
<td><tt>CHAR_BIT</tt></td>
<td><tt>FLT_DIG</tt></td>
<td><tt>INT_MIN</tt></td>
<td><tt>MB_LEN_MAX</tt></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><tt>SHRT_MIN</tt></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stderr</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stdin</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><ins><tt>stdout</tt></ins></td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
<td><tt>UCHAR_MAX</tt></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2044"></a>2044. No definition of "Stable" for copy algorithms</h3>
<p><b>Section:</b> 17.6.5.7 [algorithm.stable] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2011-03-24 <b>Last modified:</b> 2011-04-19</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
17.6.5.7 [algorithm.stable] specified the meaning of "stable" when applied to 
the different types of algorithms. The second bullet says:
</p>
<blockquote><p>
&mdash; For the <i>remove</i> algorithms the relative order of the elements that are not removed is preserved.
</p></blockquote>

<p>
There is no description of what "stable" means for copy algorithms, even though the term is 
applied to <tt>copy_if</tt> (and perhaps others now or in the future). Thus, <tt>copy_if</tt> 
is using the term without a precise definition.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>In 17.6.5.7 [algorithm.stable] p. 1 change as indicated:</p>

<blockquote><p>
When the requirements for an algorithm state that it is stable without further elaboration, it means:
</p>
<ul>
<li>For the <i>sort</i> algorithms the relative order of equivalent elements is preserved.</li>
<li>For the <i>remove</i> <ins>and <i>copy</i></ins> algorithms the relative order of the elements that are 
not removed is preserved.</li>
<li>For the <i>merge</i> algorithms, for equivalent elements in the original two ranges, the elements from the
first range precede the elements from the second range.</li>
</ul>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2045"></a>2045. <tt>forward_list::merge</tt> and <tt>forward_list::splice_after</tt> with unequal allocators</h3>
<p><b>Section:</b> 23.3.4.6 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2011-03-24 <b>Last modified:</b> 2011-04-20</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
See also: <a href="lwg-defects.html#1215">1215</a>
</p>

<p>
<tt>list::merge</tt> and <tt>list::splice</tt> have the requirement that the two lists being merged or 
spliced must use the same allocator. Otherwise, moving list nodes from one container to the other would 
corrupt the data structure. The same requirement is needed for <tt>forward_list::merge</tt> and 
<tt>forward_list::splice_after</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>In 23.3.4.6 [forwardlist.ops] p. 1 change as indicated:</p>

<blockquote><pre>
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp; x);
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x);
</pre><p>
1 - <i>Requires</i>: <tt>position</tt> is <tt>before_begin()</tt> or is a dereferenceable 
iterator in the range [<tt>begin()</tt>,<tt>end()</tt>). <ins><tt>get_allocator() == x.get_allocator()</tt>.</ins> 
<tt>&amp;x != this</tt>.
</p></blockquote>

</li>

<li><p>In 23.3.4.6 [forwardlist.ops] p. 5 change as indicated:</p>

<blockquote><pre>
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
</pre><p>
5 - <i>Requires</i>: <tt>position</tt> is <tt>before_begin()</tt> or is a dereferenceable 
iterator in the range [<tt>begin()</tt>,<tt>end()</tt>). The iterator following <tt>i</tt> is a 
dereferenceable iterator in <tt>x</tt>. <ins><tt>get_allocator() == x.get_allocator()</tt>.</ins>
</p></blockquote>

</li>

<li><p>In 23.3.4.6 [forwardlist.ops] p. 9 change as indicated:</p>

<blockquote><pre>
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp; x, 
                  const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x, 
                  const_iterator first, const_iterator last);
</pre><p>
9 - <i>Requires</i>: <tt>position</tt> is <tt>before_begin()</tt> or is a dereferenceable 
iterator in the range [<tt>begin()</tt>,<tt>end()</tt>). (<tt>first</tt>,<tt>last</tt>) is a valid range 
in <tt>x</tt>, and all iterators in the range (<tt>first</tt>,<tt>last</tt>) are dereferenceable.
<tt>position</tt> is not an iterator in the range (<tt>first</tt>,<tt>last</tt>). 
<ins><tt>get_allocator() == x.get_allocator()</tt>.</ins>
</p></blockquote>

</li>

<li><p>In 23.3.4.6 [forwardlist.ops] p. 18 change as indicated:</p>

<blockquote><pre>
void merge(forward_list&lt;T,Allocator&gt;&amp; x);
void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x);
template &lt;class Compare&gt; void merge(forward_list&lt;T,Allocator&gt;&amp; x, Compare comp);
template &lt;class Compare&gt; void merge(forward_list&lt;T,Allocator&gt;&amp;&amp; x, Compare comp);
</pre><p>
18 - <i>Requires</i>: <tt>comp</tt> defines a strict weak ordering ([alg.sorting]), and <tt>*this</tt> 
and <tt>x</tt> are both sorted according to this ordering. <ins><tt>get_allocator() == x.get_allocator()</tt>.</ins>
</p></blockquote>

</li>

</ol>






<hr>
<h3><a name="2046"></a>2046. <tt>shared_future(future&lt;R&gt;&amp;&amp;)</tt> should be allowed to throw</h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2011-04-04 <b>Last modified:</b> 2011-04-23</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Requiring the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw 
is a pessimisation of the case where a future is returned from a call to 
<tt>async(function,launch::deferred)</tt> and possible other cases.
<p/>
Such a future not dealing with multiple threads only needs to keep (a copy of) the function 
to be called it later. However, creating a <tt>shared_future</tt> from that future will require more 
infrastructure, like space for the value of type <tt>R</tt>, an <tt>exception_ptr</tt>, and a synchronized 
reference counter for the <tt>shared_future</tt>'s instances.
<p/>
Enforcing the constructor <tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> not to throw, 
implies that any implementation of <tt>future</tt> will need to pre-allocate space for <tt>shared_future</tt>'s 
infrastructure, that also requires an operating system resource for synchronization, regardless 
if is ever needed.
<p/>
All this came up when discussing D&#47;N3267 and Concurrency Working Group decided that the constructor 
<tt>shared_future(future&lt;R&gt;&amp;&amp; rhs)</tt> should be allowed to throw. 
</p>


<p><b>Proposed resolution:</b></p>

<p>Apply the proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3269.htm">n3269</a></p>






<hr>
<h3><a name="2047"></a>2047. Incorrect "mixed" move-assignment semantics of <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.7.1.2.3 [unique.ptr.single.asgn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-04-16 <b>Last modified:</b> 2011-04-20</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.asgn">issues</a> in [unique.ptr.single.asgn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>The semantics described in 20.7.1.2.3 [unique.ptr.single.asgn] p. 6</p>
<blockquote><p>
<i>Effects</i>: Transfers ownership from <tt>u</tt> to <tt>*this</tt> as if [&hellip;] followed 
by an assignment from <tt>std::forward&lt;D&gt;(u.get_deleter())</tt>.
</p></blockquote>
<p>
contradicts to the pre-conditions described in p. 4:
</p>
<blockquote><p>
<i>Requires</i>: If E is not a reference type, assignment of the deleter from an rvalue of type <tt>E</tt> shall be
well-formed and shall not throw an exception. Otherwise, <tt>E</tt> is a reference type and assignment of the
deleter from an lvalue of type <tt>E</tt> shall be well-formed and shall not throw an exception.
</p></blockquote>
<p>
Either the pre-conditions are incorrect or the semantics should be an assignment from
<tt>std::forward&lt;<span style="color:red;font-weight:bolder">E</span>&gt;(u.get_deleter())</tt>, instead.
</p>
<p>It turns out that this contradiction is due to an incorrect transcription from the proposed
resolution of <a href="lwg-defects.html#983">983</a> to the finally accepted proposal 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3073.html">n3073</a> (see
bullet 12) as confirmed by Howard Hinnant, thus the type argument provided to <tt>std::forward</tt>
must be fixed as indicated.
</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Edit 20.7.1.2.3 [unique.ptr.single.asgn] p. 6 as indicated:</p>

<blockquote><pre>
template &lt;class U, class E&gt; unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
</pre><blockquote><p>
4 - <i>Requires</i>: If <tt>E</tt> is not a reference type, assignment of the deleter from an rvalue 
of type <tt>E</tt> shall be well-formed and shall not throw an exception. Otherwise, <tt>E</tt> is a 
reference type and assignment of the deleter from an lvalue of type <tt>E</tt> shall be well-formed and 
shall not throw an exception.
<p/>
5 - <i>Remarks</i>: This operator shall not participate in overload resolution unless:</p>
<ul>
<li><tt>unique_ptr&lt;U, E&gt;::pointer</tt> is implicitly convertible to <tt>pointer</tt> and</li>
<li><tt>U</tt> is not an array type.</li>
</ul>
<p>
6 - <i>Effects</i>: Transfers ownership from <tt>u</tt> to <tt>*this</tt> as if by calling 
<tt>reset(u.release())</tt> followed by an assignment from <tt>std::forward&lt;<del>D</del><ins>E</ins>&gt;(u.get_deleter())</tt>.
<p/>
7 - <i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2048"></a>2048. Unnecessary <tt>mem_fn</tt> overloads</h3>
<p><b>Section:</b> 20.8 [function.objects], 20.8.10 [func.memfn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2011-04-23</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>mem_fn</tt> overloads for member functions are redundant and misleading
and should be removed from the post-C++11 WP.
<p/>
I believe the history of the overloads is as follows:
<p/>
In TR1 and in C++0x prior to the N2798 draft, <tt>mem_fn</tt> was specified by
a single signature:
</p>
<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);
</pre></blockquote>
<p>
and was accompanied by the remark "Implementations may implement <tt>mem_fn</tt> 
as a set of overloaded function templates." This remark predates variadic templates 
and was presumably to allow implementations to provide overloads for a limited 
number of function parameters, to meet the implementation-defined limit on numbers of
template parameters.
<p/>
N2770 "Concepts for the C++0x Standard Library: Utilities" added
separate overloads for pointers to member functions, apparently so
that function parameters would require the <tt>CopyConstructible</tt> concept
(those overloads first appeared in N2322.) The overloads failed to
account for varargs member functions (i.e. those declared with an
ellipsis in the parameter-declaration-clause) e.g.
</p>
<blockquote><pre>
struct S {
 int f(int, ...);
};
</pre></blockquote>
<p>
Syntactically such a function would be handled by the original
<tt>mem_fn(R T::* pm)</tt> signature, the only minor drawback being that there
would be no <tt>CopyConstructible</tt> requirement on the parameter list. (Core
DR 547 clarifies that partial specializations can be written to match
cv-qualified and ref-qualified functions to support the case where <tt>R T::*</tt> 
matches a pointer to member function type.)
<p/>
LWG issue <a href="lwg-defects.html#920">920</a> pointed out that additional overloads were missing for
member functions with ref-qualifiers. These were not strictly
necessary, because such functions are covered by the <tt>mem_fn(R T::* pm)</tt> signature.
<p/>
Concepts were removed from the draft and N3000 restored the original
single signature and accompanying remark.
<p/>
LWG <a href="lwg-closed.html#1230">1230</a> was opened to strike the remark again and to add an overload
for member functions (this overload was unnecessary for syntactic reasons and 
insufficient as it didn't handle member functions with cv-qualifiers and&#47;or 
ref-qualifiers.)
<p/>
<a href="lwg-defects.html#920">920</a> (and <a href="lwg-closed.html#1230">1230</a>) were resolved by restoring a full set of
(non-concept-enabled) overloads for member functions with cv-qualifiers and ref-qualifiers,
but as in the concept-enabled draft there were no overloads for member functions with 
an ellipsis in the parameter-declaration-clause. This is what is present in the FDIS.
<p/>
Following the thread beginning with message c++std-lib-30675, it is my
understanding that all the <tt>mem_fn</tt> overloads for member functions are
unnecessary and were only ever added to allow concept requirements.
I'm not aware of any reason implementations cannot implement <tt>mem_fn</tt> as
a single function template. Without concepts the overloads are
redundant, and the absence of overloads for varargs functions can be
interpreted to imply that varargs functions are not intended to work
with <tt>mem_fn</tt>. Clarifying the intent by adding overloads for varargs
functions would expand the list of 12 redundant overloads to 24, it
would be much simpler to remove the 12 redundant overloads entirely.
</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the <tt>&lt;functional&gt;</tt> synopsis 20.8 [function.objects] p. 2 as follows:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  // <i>[func.memfn], member function adaptors:</i>
  template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...));
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 20.8.10 [func.memfn] as follows:</p>

<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...));
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2049"></a>2049. <tt>is_destructible</tt> is underspecified</h3>
<p><b>Section:</b> 20.9.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2011-04-23</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>The conditions for the type trait <tt>is_destructible</tt> to be true
are described in Table 49 &mdash; Type property predicates:</p>
<blockquote><p>
For a complete type <tt>T</tt> and given<br/>
<tt>template &lt;class U&gt;
struct test { U u; };</tt>,<br/>
<tt>test&lt;T&gt;::~test()</tt> is not deleted.
</p></blockquote>

<p>This specification does not say what the result would be for function
types or for abstract types:</p>
<ol>
<li>For an abstract type <tt>X</tt> the instantiation <tt>test&lt;X&gt;</tt>
is already ill-formed, so we cannot say anything about whether the destructor
would be deleted or not.</li>
<li>In regard to function types, there exists a special rule in the core language, 14.3.1 [temp.arg.type] p. 3,
which excludes member functions to be declared via the type of the template parameter:
<blockquote><p>
If a declaration acquires a function type through a type dependent on a <i>template-parameter</i>
and this causes a declaration that does not use the syntactic form of a function declarator 
to have function type, the program is ill-formed. 
<p/>
[ <i>Example</i>:</p>
<blockquote><pre>
template&lt;class T&gt; struct A {
  static T t;
};
typedef int function();
A&lt;function&gt; a; // ill-formed: would declare A&lt;function&gt;::t
               // as a static member function
</pre></blockquote>
<p>
&mdash; <i>end example</i> ]
</p></blockquote>
which has the same consequence as for abstract types, namely that the corresponding
instantiation of <tt>test</tt> is already ill-formed and we cannot say anything
about the destructor.
</li>
</ol>
<p>To solve this problem, I suggest to specify function types as trivially and nothrowing
destructible, because above mentioned rule is very special for templates. For non-templates,
a typedef can be used to introduce a member as member function as clarified in 8.3.5 [dcl.fct]
p. 10.</p>
<p>For abstract types, two different suggestions have been brought to my attention:
Either declare them as unconditionally non-destructible or check whether the expression
</p>
<blockquote><pre>
std::declval&lt;T&amp;&gt;().~T()
</pre></blockquote>
<p>is well-formed in an unevaluated context. The first solution is very easy to specify,
but the second version has the advantage for providing more information to user-code. This 
information could be quite useful, if generic code is supposed to invoke the destructor
of a reference to a base class indirectly via a delete expression, as suggested by
Howard Hinnant:</p>
<blockquote><pre>
template &lt;class T&gt;
my_pointer&lt;T&gt;::~my_pointer() noexcept(is_nothrow_destructible&lt;T&gt;::value)
{
   delete ptr_;
}
</pre></blockquote>
<p>Additional to the <tt>is_destructible</tt> traits, its derived forms <tt>is_trivially_destructible</tt>
and <tt>is_nothrow_destructible</tt> are similarly affected, because their wording refers to "the indicated
destructor" and probably need to be adapted as well.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2050"></a>2050. Unordered associative containers do not use <tt>allocator_traits</tt> to define member types</h3>
<p><b>Section:</b> 23.5 [unord] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tom Zieberman <b>Opened:</b> 2011-04-29 <b>Last modified:</b> 2011-05-03</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>The unordered associative containers define their member types <tt>reference</tt>, 
<tt>const_reference</tt>, <tt>pointer</tt>, <tt>const_pointer</tt> in terms of 
their template parameter <tt>Allocator</tt> (via <tt>allocator_type</tt> typedef). As 
a consequence, only the allocator types, that provide sufficient typedefs, are usable 
as allocators for unordered associative containers, while other containers do not have 
this deficiency. In addition to that, the definitions of said typedefs are different 
from ones used in the other containers. This is counterintuitive and introduces a certain 
level of confusion. These issues can be fixed by defining <tt>pointer</tt> and 
<tt>const_pointer</tt> typedefs in terms of <tt>allocator_traits&lt;Allocator&gt;</tt> 
and by defining <tt>reference</tt> and <tt>const_reference</tt> in terms of 
<tt>value_type</tt> as is done in the other containers.
</p>


<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ul>
<li><p>Change 23.5.4.1 [unord.map.overview] paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
  class unordered_map
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef std::pair&lt;const Key, T&gt; value_type;
    typedef T mapped_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 23.5.5.1 [unord.multimap.overview] paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
  class unordered_multimap
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef std::pair&lt;const Key, T&gt; value_type;
    typedef T mapped_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 23.5.6.1 [unord.set.overview] paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;Key&gt; &gt;
  class unordered_set
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef Key value_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Change 23.5.7.1 [unord.multiset.overview] paragraph 3 as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Key,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Allocator = std::allocator&lt;Key&gt; &gt;
  class unordered_multiset
  {
  public:
    <i>// types</i>
    typedef Key key_type;
    typedef Key value_type;
    typedef Hash hasher;
    typedef Pred key_equal;
    typedef Allocator allocator_type;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::pointer pointer;
    typedef typename <del>allocator_type</del><ins>allocator_traits&lt;Allocator&gt;</ins>::const_pointer const_pointer;
    typedef <del>typename allocator_type::reference</del><ins>value_type&amp;</ins> reference;
    typedef <del>typename allocator_type::const_reference</del><ins>const value_type&amp;</ins> const_reference;
    typedef <i>implementation-defined</i> size_type;
    typedef <i>implementation-defined</i> difference_type;

    [&hellip;]
  };
}
</pre></blockquote>
</li>

</ul>






<hr>
<h3><a name="2051"></a>2051. Explicit <tt>tuple</tt> constructors for more than one parameter</h3>
<p><b>Section:</b> 20.4.2 [tuple.tuple], 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2011-05-01 <b>Last modified:</b> 2011-05-03</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One of my constituents wrote the following:
<p/>
-------snip------------
<p/>
So far the only use I've found for <tt>std::tuple</tt> is as an ad-hoc type to emulate
multiple return values. If the tuple ctor was made non-explicit one could
almost think C++ supported multiple return values especially when combined
with <tt>std::tie()</tt>.
</p>
<blockquote><pre>
// assume types line_segment and point
// assume function double distance(point const&amp;, point const&amp;)

std::tuple&lt;point, point&gt;
closest_points(line_segment const&amp; a, line_segment const&amp; b) {
 point ax;
 point bx;
 /* some math */

 return {ax, bx};
}


double
distance(line_segment const&amp; a, line_segment const&amp; b) {
 point ax;
 point bx;
 std::tie(ax, bx) = closest_points(a, b);

 return distance(ax, bx);
}
</pre></blockquote>
<p>
-------snap----------
<p/>
See also the messages starting from lib-29330.
<p/>
Some notes:
</p>
<ol>
<li><tt>pair</tt> allows such a return</li>
<li>a lambda with a deduced return type doesn't allow it for any type</li>
<li><tt>decltype</tt> refuses <tt>{1, 2}</tt></li>
</ol>
<p>
I would recommend making non-unary <tt>tuple</tt> constructors non-explicit.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2052"></a>2052. Mixup between <tt>mapped_type</tt> and <tt>value_type</tt> for associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2011-05-04 <b>Last modified:</b> 2011-05-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(this is basically reopening the first part of issue <a href="lwg-closed.html#2006">2006</a>, as discussed in the thread 
starting at c++std-lib-30698 )
<p/>
Section 23.2.4 [associative.reqmts]
<p/>
In Table 102, several uses of <tt>T</tt> (which means <tt>mapped_type</tt> here) should
be <tt>value_type</tt> instead. This is almost editorial. For instance:
</p>
<blockquote><pre>
a_uniq.emplace(args)
</pre><p>
<i>Requires</i>: <tt>T</tt> shall be <tt>EmplaceConstructible</tt> into <tt>X</tt> from args.
<p/>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in the
container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of
the returned pair is true if and only if the insertion takes place, and the iterator component 
of the pair points to the element with key equivalent to the key of <tt>t</tt>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2053"></a>2053. Errors in <tt>regex</tt> bitmask types</h3>
<p><b>Section:</b> 28.5 [re.const] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-05-09 <b>Last modified:</b> 2011-05-10</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">N3110</a> 
was applied to the WP some redundant "static" keywords were added and one form of initializer 
which isn't valid for enumeration types was replaced with another form of invalid initializer.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Change 28.5.1 [re.synopt] as indicated:</p>
<blockquote><pre>
namespace std {
  namespace regex_constants {
    typedef <i>T1</i> syntax_option_type;
    <del>static </del>constexpr syntax_option_type icase = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type nosubs = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type optimize = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type collate = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type ECMAScript = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type basic = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type extended = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type awk = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type grep = <i>unspecified</i> ;
    <del>static </del>constexpr syntax_option_type egrep = <i>unspecified</i> ;
  }
}
</pre></blockquote>
</li>

<li><p>Change 28.5.2 [re.matchflag] as indicated:</p>
<blockquote><pre>
namespace std {
  namespace regex_constants {
    typedef <i>T2</i> match_flag_type;
    <del>static </del>constexpr match_flag_type match_default<del> = 0</del><ins>{};</ins>
    <del>static </del>constexpr match_flag_type match_not_bol = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_not_eol = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_not_bow = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_not_eow = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_any = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_not_null = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_continuous = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type match_prev_avail = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type format_default<del> = 0</del><ins>{}</ins>;
    <del>static </del>constexpr match_flag_type format_sed = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type format_no_copy = <i>unspecified</i> ;
    <del>static </del>constexpr match_flag_type format_first_only = <i>unspecified</i> ;
  }
}
</pre></blockquote>
</li>

<li><p>Change 28.5.3 [re.err] as indicated:</p>
<blockquote><pre>
namespace std {
  namespace regex_constants {
    typedef <i>T3</i> error_type;
    <del>static </del>constexpr error_type error_collate = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_ctype = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_escape = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_backref = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_brack = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_paren = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_brace = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_badbrace = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_range = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_space = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_badrepeat = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_complexity = <i>unspecified</i> ;
    <del>static </del>constexpr error_type error_stack = <i>unspecified</i> ;
  }
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2054"></a>2054. <tt>time_point</tt> constructors need to be <tt>constexpr</tt></h3>
<p><b>Section:</b> 20.11.6 [time.point] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2011-05-13 <b>Last modified:</b> 2011-05-18</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.11.6 [time.point], <tt>time_point::min()</tt> and <tt>time_point::max()</tt> 
are listed as <tt>constexpr</tt>. However, <tt>time_point</tt> has no <tt>constexpr</tt> constructors, 
so is not a literal type, and so these functions cannot be <tt>constexpr</tt> without adding a 
<tt>constexpr</tt> constructor for implementation purposes.
<p/>
Proposed resolution: Add <tt>constexpr</tt> to the constructors of <tt>time_point</tt>. The effects of
the constructor template basically imply that the member function <tt>time_since_epoch()</tt> is
intended to be <tt>constexpr</tt> as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Alter the class template definition in 20.11.6 [time.point] as follows:</p>
<blockquote><pre>
template &lt;class Clock, class Duration = typename Clock::duration&gt;
class time_point {
  [&hellip;]
public:
  <i>// 20.11.6.1, construct:</i>
  <ins>constexpr</ins> time_point(); <i>// has value epoch</i>
  <ins>constexpr</ins> explicit time_point(const duration&amp; d); <i>// same as time_point() + d</i>
  template &lt;class Duration2&gt;
    <ins>constexpr</ins> time_point(const time_point&lt;clock, Duration2&gt;&amp; t);

  <i>// 20.11.6.2, observer:</i>
  <ins>constexpr</ins> duration time_since_epoch() const;
  [&hellip;]
};
</pre></blockquote>
</li>

<li><p>Alter the declarations in 20.11.6.1 [time.point.cons]:</p>
<blockquote><pre>
<ins>constexpr</ins> time_point();
</pre><blockquote><p>
-1- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>duration::zero()</tt>. Such a
<tt>time_point</tt> object represents the epoch.
</p></blockquote></blockquote>
<blockquote><pre>
<ins>constexpr explicit</ins> time_point(const duration&amp; d);
</pre><blockquote><p>
-2- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>d</tt>. Such a 
<tt>time_point</tt> object represents the epoch <tt>+ d</tt>.
</p></blockquote></blockquote>
<blockquote><pre>
template &lt;class Duration2&gt;
  <ins>constexpr</ins> time_point(const time_point&lt;clock, Duration2&gt;&amp; t);
</pre><blockquote><p>
-3- <i>Remarks</i>: This constructor shall not participate in overload resolution unless <tt>Duration2</tt> is implicitly
convertible to <tt>duration</tt>.
<p/>
-4- <i>Effects</i>: Constructs an object of type <tt>time_point</tt>, initializing <tt>d_</tt> with <tt>t.time_since_epoch()</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Alter the declaration in 20.11.6.2 [time.point.observer]:</p>
<blockquote><pre>
<ins>constexpr</ins> duration time_since_epoch() const;
</pre><blockquote><p>
-1- <i>Returns</i>: d_.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2055"></a>2055. <tt>std::move</tt> in <tt>std::accumulate</tt> and other algorithms</h3>
<p><b>Section:</b> 26.7 [numeric.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2011-01-01 <b>Last modified:</b> 2011-05-18</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in [numeric.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++0x draft says <tt>std::accumulate</tt> uses: <tt>acc = binary_op(acc, *i)</tt>.
<p/>
Eelis van der Weegen has pointed out, on the libstdc++ mailing list, that using 
<tt>acc = binary_op(std::move(acc), *i)</tt> can lead to massive improvements (particularly, 
it means accumulating strings is linear rather than quadratic).
<p/>
Consider the simple case, accumulating a bunch of strings of length 1 (the same argument holds for other length buffers).
For strings <tt>s</tt> and <tt>t</tt>, <tt>s+t</tt> takes time <tt>length(s)+length(t)</tt>, as you have to copy 
both <tt>s</tt> and <tt>t</tt> into a new buffer.
<p/>
So in accumulating <tt>n</tt> strings, step <tt>i</tt> adds a string of length <tt>i-1</tt> to a string of length 
1, so takes time <tt>i</tt>.
<p/>
Therefore the total time taken is: <tt>1+2+3+...+n</tt> = O(<tt>n<sup>2</sup></tt>)
<p/>
<tt>std::move(s)+t</tt>, for a "good" implementation, is amortized time <tt>length(t)</tt>, like <tt>vector</tt>, 
just copy <tt>t</tt> onto the end of the buffer. So the total time taken is:
<p/>
<tt>1+1+1+...+1</tt> (<tt>n</tt> times) = O(<tt>n</tt>). This is the same as <tt>push_back</tt> on a <tt>vector</tt>.
<p/>
I'm trying to decide if this implementation might already be allowed. I suspect it might not 
be (although I can't imagine any sensible code it would break). There are other algorithms 
which could benefit similarly (<tt>inner_product</tt>, <tt>partial_sum</tt> and 
<tt>adjacent_difference</tt> are the most obvious).
<p/>
Is there any general wording for "you can use rvalues of temporaries"?
<p/>
The reflector discussion starting with message c++std-lib-29763 came to the conclusion
that above example is not covered by the "as-if" rules and that enabling this behaviour
would seem quite useful.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2056"></a>2056. <tt>future_errc</tt> enums start with value 0 (invalid value for <tt>broken_promise</tt>)</h3>
<p><b>Section:</b> 30.6.1 [futures.overview] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2011-05-19</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.6.1 [futures.overview] <tt>enum class future_errc</tt> is defined as follows:
</p><blockquote><pre>
enum class future_errc {
  broken_promise,
  future_already_retrieved,
  promise_already_satisfied,
  no_state
};
</pre></blockquote><p>
With this declaration <tt>broken_promise</tt> has value 0, which means that
for a <tt>future_error f</tt> with this code
</p><blockquote><pre>
f.code().operator bool()
</pre></blockquote><p>
yields false, which makes no sense. 0 has to be reserved for "no error".
So, the enums defined here have to start with 1.
<p/>
Howard, Anthony, and Jonathan have no objections.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, fix 
the declaration of <tt>future_errc</tt> as follows:</p>
<blockquote><pre>
namespace std {
  enum class future_errc {
    <del>broken_promise,</del>
    future_already_retrieved<ins> = 1</ins>,
    promise_already_satisfied,
    no_state<ins>,
    broken_promise</ins>
  };
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2057"></a>2057. <tt>time_point + duration</tt> semantics should be made <tt>constexpr</tt> conforming</h3>
<p><b>Section:</b> 20.11.6.5 [time.point.nonmember] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-05-21 <b>Last modified:</b> 2011-05-21</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been observed by LWG <a href="lwg-active.html#2054">2054</a> that the specification of some <tt>time_point</tt> member functions
already imply that <tt>time_point</tt> needs to be a literal type and suggests to specify the constructors
and the member function <tt>time_since_epoch()</tt> as <tt>constexpr</tt> functions at the
minimum necessary. Adding further <tt>constexpr</tt> specifier to other operations should
clearly be allowed and should probably be done as well. But to allow for further <tt>constexpr</tt> 
functions in the future requires that their semantics is compatible to operations allowed in <tt>constexpr</tt> 
functions. This is already fine for all operations, except this binary plus operator:
</p>
<blockquote><pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
time_point&lt;Clock, typename common_type&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;::type&gt;
operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
-1- <i>Returns</i>: <tt>CT(lhs) += rhs</tt>, where <tt>CT</tt> is the type of the return value.
</p></blockquote></blockquote>
<p>
for similar reasons as those mentioned in <a href="lwg-defects.html#2020">2020</a>. The semantics should be fixed to allow
for making them <tt>constexpr</tt>. This issue should also be considered as a placeholder for a request
to make the remaining <tt>time_point</tt> operations similarly <tt>constexpr</tt> as had been done for 
<tt>duration</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>In 20.11.6.5 [time.point.nonmember], p.1 change the <i>Returns</i> element semantics as indicated:</p>
<blockquote><pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
time_point&lt;Clock, typename common_type&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;::type&gt;
operator+(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
-1- <i>Returns</i>: <tt><del>CT(lhs) += rhs</del><ins>CT(lhs.time_since_epoch() + rhs)</ins></tt>, where <tt>CT</tt> 
is the type of the return value.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2058"></a>2058. <tt>valarray</tt> and <tt>begin&#47;end</tt></h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2011-05-17 <b>Last modified:</b> 2011-05-21</p>
<p><b>View all other</b> <a href="lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was just brought to my attention that the pair of functions
<tt>begin&#47;end</tt> were added to <tt>valarray</tt> component.
Those additions strike me as counter to the long standing agreement
that <tt>valarray&lt;T&gt;</tt> is not yet another container. Valarray values
are in general supposed to be treated as a whole, and as such
has a loose specification allowing expression template techniques.
<p/>
The addition of these functions sound to me as making it much harder
(or close to impossible) to effectively use expression templates
as implementation techniques, for no clear benefits.
<p/>
My recommendation would be to drop <tt>begin&#47;end</tt> - or at least for the
<tt>const valarray&lt;T&gt;&amp;</tt> version. I strongly believe those 
are defects.
</p>
<p><i>[This issue was discussed on the library reflector starting from c++std-lib-30761.
Some of the key conclusions of this discussion were:]</i></p>

<ol>
<li>The <tt>begin&#47;end</tt> members were added to allow <tt>valarray</tt> to participate
in the new range-based for-loop by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">n2930</a>
and not to make them container-like.</li>
<li>It is currently underspecified when the iterator values returned from
<tt>begin&#47;end</tt> become invalidated. To fix this, these invalidation rules need at
least to reflect the invalidation rules of the references returned by the
<tt>operator[]</tt> overloads of <tt>valarray</tt> (26.6.2.4 [valarray.access]).
</li>
<li>A further problem is that the requirements expressed in 26.6.1 [valarray.syn] p.3-5
enforce an implementation to provide further overloads of <tt>begin&#47;end</tt>, if the
replacement type technique is used (which was clearly part of the design of <tt>valarray</tt>).
Providing such additional overloads would also lead to life-time problems in examples like 
<tt>begin(x + y)</tt> where <tt>x</tt> and <tt>y</tt> are expressions involving <tt>valarray</tt> 
objects. To fix this, the <tt>begin&#47;end</tt> overloads could be explicitly excluded from the 
general statements of 26.6.1 [valarray.syn] p.3-5. This would make it unspecified
whether the expression <tt>begin(x + y)</tt> would be well-formed, portable code would
need to write this as <tt>begin(std::valarray&lt;T&gt;(x + y))</tt>.</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2059"></a>2059. C++0x ambiguity problem with <tt>map::erase</tt></h3>
<p><b>Section:</b> 23.4.4 [map] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2011-05-21</p>
<p><b>View all other</b> <a href="lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>map::erase</tt> (and several related methods) took an iterator in C++03, but take a <tt>const_iterator</tt> 
in C++0x. This breaks code where the map's <tt>key_type</tt> has a constructor which accepts an iterator 
(for example a template constructor), as the compiler cannot choose between <tt>erase(const key_type&amp;)</tt> 
and <tt>erase(const_iterator)</tt>.</p>
<blockquote><pre>
#include &lt;map&gt;

struct X
{
  template&lt;typename T&gt;
  X(T&amp;) {}
};

bool operator&lt;(const X&amp;, const X&amp;) { return false; }

void erasor(std::map&lt;X,int&gt;&amp; s, X x)
{
  std::map&lt;X,int&gt;::iterator it = s.find(x);
  if (it != s.end())
    s.erase(it);
}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2060"></a>2060. <tt>unique_ptr&lt;T[]&gt;(nullptr_t)</tt> missing <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.7.1.3 [unique.ptr.runtime] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant, Paolo Carlini <b>Opened:</b> 2011-05-27 <b>Last modified:</b> 2011-05-28</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.runtime">issues</a> in [unique.ptr.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis in 20.7.1.2 [unique.ptr.single] specifies:
</p><blockquote><pre>
constexpr unique_ptr(nullptr_t) noexcept
</pre></blockquote><p>
which looks correct to me.  However the corresponding constructor in 20.7.1.3 [unique.ptr.runtime] is missing <tt>noexcept</tt>:
</p><blockquote><pre>
constexpr unique_ptr(nullptr_t) : unique_ptr() { }
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the synopsis in 20.7.1.3 [unique.ptr.runtime]:</p>
<blockquote><pre>
namespace std {
  template &lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
  public:
    typedef see below pointer;
    typedef T element_type;
    typedef D deleter_type;

    // 20.7.1.3.1, constructors
    constexpr unique_ptr() noexcept;
    [&hellip;]
    constexpr unique_ptr(nullptr_t) <ins>noexcept</ins> : unique_ptr() { }
	
    [&hellip;]
  };
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2061"></a>2061. <tt>make_move_iterator</tt> and arrays</h3>
<p><b>Section:</b> 24.3 [iterator.synopsis], 24.5.3 [move.iterators] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2011-05-28 <b>Last modified:</b> 2011-05-28</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library always passes template iterators by value and never by reference, 
which has the nice effect that an array decays to a pointer. There is one exception: 
<tt>make_move_iterator</tt>.
</p>
<blockquote><pre>
#include &lt;iterator&gt;
int main(){
  int a[]={1,2,3,4};
  std::make_move_iterator(a+4);
  std::make_move_iterator(a); // fails here
}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the header <tt>&lt;iterator&gt;</tt> synopsis in 24.3 [iterator.synopsis]:</p>
<blockquote><pre>
namespace std {
  [&hellip;]
  template &lt;class Iterator&gt;
  move_iterator&lt;Iterator&gt; make_move_iterator(<del>const Iterator&amp;</del><ins>Iterator</ins> i);

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>move_iterator</tt> synopsis in 24.5.3.1 [move.iterator]:</p>
<blockquote><pre>
namespace std {
  [&hellip;]
  template &lt;class Iterator&gt;
  move_iterator&lt;Iterator&gt; make_move_iterator(<del>const Iterator&amp;</del><ins>Iterator</ins> i);
}
</pre></blockquote>
</li>

<li><p>Modify 24.5.3.3.14 [move.iter.nonmember]:</p>
<blockquote><pre>
template &lt;class Iterator&gt;
move_iterator&lt;Iterator&gt; make_move_iterator(<del>const Iterator&amp;</del><ins>Iterator</ins> i);
</pre><blockquote><p>
-3- <i>Returns</i>: <tt>move_iterator&lt;Iterator&gt;(i)</tt>.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2062"></a>2062. Effect contradictions w&#47;o no-throw guarantee of <tt>std::function</tt> swaps</h3>
<p><b>Section:</b> 20.8.11.2 [func.wrap.func], 20.8.11.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-05-28 <b>Last modified:</b> 2011-06-07</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Howard Hinnant observed in reflector message c++std-lib-30841 that 20.8.11.2 [func.wrap.func] 
makes the member swap <tt>noexcept</tt>, even though the non-member swap is not <tt>noexcept</tt>. 
<p/>
The latter was an outcome of the discussions during the Batavia meeting and the Madrid meeting 
involving LWG <a href="lwg-defects.html#1349">1349</a>, which seems to indicate that the remaining <tt>noexcept</tt> 
specifier at the member swap is incorrect and should be removed.
<p/>
But if we allow for a potentially throwing member swap of <tt>std::function</tt>, this causes 
another conflict with the exception specification for the following member function:
</p>
<blockquote><pre>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f) <span style="color:#C80000;font-weight:bolder">noexcept</span>;
</pre><blockquote><p>
<i>Effects</i>: <tt>function(f).<span style="color:#C80000;font-weight:bolder">swap</span>(*this);</tt>
</p>
</blockquote></blockquote>
<p>
Note that in this example the sub-expression <tt>function(f)</tt> does not cause any problems,
because of the nothrow-guarantee given in 20.8.11.2.1 [func.wrap.func.con] p. 10. The problem
is located in the usage of the swap which could potentially throw given the general latitude. 
<p/>
So, either the Madrid meeting decision need to be revised (and both member and free swap of 
<tt>std::function</tt> should be noexcept), or this function needs to be adapted as well,
e.g. by taking the exception-specification away or by changing the semantics.
<p/>
One argument for "swap-may-throw" would be to allow for small-object optimization techniques
where the copy of the target may throw. But given the fact that the swap function has been guaranteed 
to be "Throws: Nothing" from TR1 on, it seems to me that that there would still be opportunities to 
perform small-object optimizations just restricted to the set of target copies that cannot throw. 
<p/>
In my opinion member swap of <tt>std::function</tt> has always been intended to be no-throw, because
otherwise there would be no good technical reason to specify the effects of several member 
functions in terms of the "construct-swap" idiom (There are three functions that are defined
this way), which provides the strong exception safety in this case. I suggest to enforce that both 
member swap and non-member swap of <tt>std::function</tt> are nothrow functions as it had been guaranteed 
since TR1 on.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the header <tt>&lt;functional&gt;</tt> synopsis in 20.8 [function.objects] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>function</tt> synopsis in 20.8.11.2 [func.wrap.func] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  <i>// [func.wrap.func.alg], specialized algorithms:</i>
  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.8.11.2.7 [func.wrap.func.alg] as indicated:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2) <ins>noexcept</ins>;
</pre><blockquote><p>
-1- <i>Effects</i>: <tt>f1.swap(f2);</tt>
</p></blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2063"></a>2063. Contradictory requirements for string move assignment</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-05-29 <b>Last modified:</b> 2011-05-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.4.1 [string.require]&#47;p4 says that <tt>basic_string</tt> is an "allocator-aware" 
container and behaves as described in 23.2.1 [container.requirements.general].
<p/>
23.2.1 [container.requirements.general] describes move assignment in p7 and Table 99.
<p/>
If <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt> 
is false, and if the allocators stored in the lhs and rhs sides are not equal, then move 
assigning a string has the same semantics as copy assigning a string as far as resources are 
concerned (resources can not be transferred). And in this event, the lhs may have to acquire 
resources to gain sufficient capacity to store a copy of the rhs.
<p/>
However 21.4.2 [string.cons]&#47;p22 says:
</p><blockquote><pre>
basic_string&lt;charT,traits,Allocator&gt;&amp;
operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</pre><blockquote><p>
<i>Effects</i>: If <tt>*this</tt> and <tt>str</tt> are not the same object, modifies <tt>*this</tt> 
as shown in Table 71. [<i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]
</p></blockquote></blockquote><p>
These two specifications for <tt>basic_string::operator=(basic_string&amp;&amp;)</tt> are in conflict with 
each other. It is not possible to implement a <tt>basic_string</tt> which satisfies both requirements.
<p/>
Additionally assign from an rvalue <tt>basic_string</tt> is defined as:
</p><blockquote><pre>
basic_string&amp; assign(basic_string&amp;&amp; str) noexcept;
</pre><blockquote><p>
<i>Effects</i>: The function replaces the string controlled by <tt>*this</tt> with a string of length 
<tt>str.size()</tt> whose elements are a copy of the string controlled by <tt>str</tt>. [ <i>Note</i>: A valid 
implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]
</p></blockquote></blockquote><p>
It seems contradictory that this member can be sensitive to <tt>propagate_on_container_swap</tt> instead 
of <tt>propagate_on_container_move_assignment</tt>.  Indeed, there is a very subtle chance for undefined 
behavior here:  If the implementation implements this in terms of <tt>swap</tt>, and if 
<tt>propagate_on_container_swap</tt> is false, and if the two allocators are unequal, the behavior 
is undefined, and will likely lead to memory corruption.  That's a lot to go wrong under a member 
named "assign".
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the class template <tt>basic_string</tt> synopsis in 21.4 [basic.string]:</p>
<blockquote><pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    basic_string&amp; operator=(basic_string&amp;&amp; str) <del>noexcept</del>;
    [&hellip;]
    basic_string&amp; assign(basic_string&amp;&amp; str) <del>noexcept</del>;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Remove the definition of the <tt>basic_string</tt> move assignment operator from 21.4.2 [string.cons] 
entirely, including Table 71 &mdash; <tt>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;&amp;)</tt>.
This is consistent with how we define move assignment for the containers in Clause 23:</p>
<blockquote><pre>
<del>basic_string&lt;charT,traits,Allocator&gt;&amp;
operator=(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;</del>
</pre><blockquote><p>
<del>-22- <i>Effects</i>: If <tt>*this</tt> and <tt>str</tt> are not the same object, modifies <tt>*this</tt> as shown 
in Table 71. [ <i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]</del>
<p/>
<del>-23- If <tt>*this</tt> and <tt>str</tt> are the same object, the member has no effect.</del>
<p/>
<del>-24- <i>Returns</i>: <tt>*this</tt></del>
</p></blockquote></blockquote>
<blockquote>
<table border="1">
<caption><del>Table 71 &mdash; <tt>operator=(const basic_string&lt;charT, traits, Allocator&gt;&amp;&amp;)</tt></del></caption>

<tr>
<th><del>Element</del></th>
<th><del>Value</del></th>
</tr>

<tr>
<td><del><tt>data()</tt></del></td>
<td><del>points at the array whose first element was pointed
at by <tt>str.data()</tt></del></td>
</tr>

<tr>
<td><del><tt>size()</tt></del></td>
<td><del>previous value of <tt>str.size()</tt></del></td>
</tr>

<tr>
<td><del><tt>capacity()</tt></del></td>
<td><del>a value at least as large as <tt>size()</tt></del></td>
</tr>

</table> 
</blockquote>
</li>

<li><p>Modify the paragraphs prior to 21.4.6.3 [string::assign] p.3 as indicated (The
first insertion recommends a separate paragraph number for the indicated paragraph):</p>
<blockquote><pre>
basic_string&amp; assign(basic_string&amp;&amp; str) <del>noexcept</del>;
</pre><blockquote><p>
<ins>-?-</ins> <i>Effects</i>: <ins>Equivalent to <tt>*this = std::move(str)</tt>.</ins>
<del>The function replaces the string controlled by <tt>*this</tt> with a string of length 
<tt>str.size()</tt> whose elements are a copy of the string controlled by <tt>str</tt>. 
[ <i>Note</i>: A valid implementation is <tt>swap(str)</tt>. &mdash; <i>end note</i> ]</del>
<p/>
-3- <i>Returns</i>: <tt>*this</tt>
</p></blockquote></blockquote>

</li>
</ol>





<hr>
<h3><a name="2064"></a>2064. More <tt>noexcept</tt> issues in <tt>basic_string</tt></h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2011-05-29 <b>Last modified:</b> 2011-06-08</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following inconsistencies regarding <tt>noexcept</tt> for <tt>basic_string</tt> are noted.
<p/>
Member swap is not marked <tt>noexcept</tt>:
</p><blockquote><pre>
void swap(basic_string&amp; str);
</pre></blockquote><p>
But the global swap is marked <tt>noexcept</tt>:
</p><blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
          basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <span style="color:#C80000;font-weight:bolder">noexcept</span>;
</pre></blockquote><p>
But only in the definition, not in the synopsis.
<p/>
All comparison operators are marked <tt>noexcept</tt> in their definitions, but not in the synopsis.
<p/>
The compare function that takes a pointer:
</p><blockquote><pre>
int compare(const charT *s) const;
</pre></blockquote><p>
is not marked <tt>noexcept</tt>. But some of the comparison functions which are marked <tt>noexcept</tt> 
(only in their definition) are specified to call the throwing compare operator:
</p><blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator==(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                const charT* rhs) <span style="color:#C80000;font-weight:bolder">noexcept</span>;
</pre><blockquote><p>
<i>Returns</i>: <tt>lhs.compare(rhs) == 0</tt>.
</p></blockquote></blockquote>
<p>
All functions with a narrow contract should not be declared as <tt>noexcept</tt> according to
the guidelines presented in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">n3279</a>.
Among these narrow contract functions are the <tt>swap</tt> functions (23.2.1 [container.requirements.general] p. 8) 
and functions with non-<tt>NULL</tt> <tt>const charT*</tt> parameters.
</p>
<p><i>[2011-06-08 Daniel provides wording]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS. Both move-assignment operator and the moving <tt>assign</tt>
function are not touched by this issue, because they are handled separately by issue <a href="lwg-active.html#2063">2063</a>.</p>
<ol>
<li><p>Modify the header <tt>&lt;string&gt;</tt> synopsis in 21.3 [string.classes] as 
indicated (Rationale: Adding <tt>noexcept</tt> to these specific overloads is in sync with
applying the same rule to specific overloads of the member functions <tt>find</tt>, <tt>compare</tt>, etc.
This approach deviates from that taken in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">n3279</a>,
but seems more consistent given similar application for comparable member functions):</p>

<blockquote><pre>
#include &lt;initializer_list&gt;

namespace std {

  [&hellip;]
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator==(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator!=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]

  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt;(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                   const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt;(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                   const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]

  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt;=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt;=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <ins>noexcept</ins>;
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>basic_string</tt> synopsis in 21.4 [basic.string] as 
indicated (Remark 1: The <tt>noexcept</tt> at the move-constructor is fine, because even for a
small-object optimization there is no problem here, because <tt>basic_string::value_type</tt>
is required to be a non-array POD as of 21.1 [strings.general] p1, Remark 2: This
proposal removes the <tt>noexcept</tt> at single character overloads of <tt>find</tt>, <tt>rfind</tt>,
etc. because they are defined in terms of potentially allocating functions. It seems like
an additional issue to me to change the semantics in terms of non-allocating functions and
adding <tt>noexcept</tt> instead):</p>

<blockquote><pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// [string.ops], string operations:</i>
    [&hellip;]
    size_type find (charT c, size_type pos = 0) const <del>noexcept</del>;
    [&hellip;]
    size_type rfind(charT c, size_type pos = npos) const <del>noexcept</del>;
    [&hellip;]
    size_type find_first_of(charT c, size_type pos = 0) const <del>noexcept</del>;
    [&hellip;]
    size_type find_last_of (charT c, size_type pos = npos) const <del>noexcept</del>;
    [&hellip;]
    size_type find_first_not_of(charT c, size_type pos = 0) const <del>noexcept</del>;
    [&hellip;]
    size_type find_last_not_of (charT c, size_type pos = npos) const <del>noexcept</del>;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Modify 21.4.7.2 [string::find] before p5 and before p7 as indicated:</p>

<blockquote><pre>
size_type find(const charT* s, size_type pos = 0) const <del>noexcept</del>;
[&hellip;]
size_type find(charT c, size_type pos = 0) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>find(basic_string&lt;charT,traits,Allocator&gt;(1,c), pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.7.3 [string::rfind] before p7 as indicated:</p>

<blockquote><pre>
size_type rfind(charT c, size_type pos = npos) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>rfind(basic_string&lt;charT,traits,Allocator&gt;(1,c),pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.7.4 [string::find.first.of] before p7 as indicated:</p>

<blockquote><pre>
size_type find_first_of(charT c, size_type pos = 0) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>find_first_of(basic_string&lt;charT,traits,Allocator&gt;(1,c), pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.7.5 [string::find.last.of] before p7 as indicated:</p>

<blockquote><pre>
size_type find_last_of(charT c, size_type pos = npos) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>find_last_of(basic_string&lt;charT,traits,Allocator&gt;(1,c),pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.7.6 [string::find.first.not.of] before p7 as indicated:</p>

<blockquote><pre>
size_type find_first_not_of(charT c, size_type pos = 0) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>find_first_not_of(basic_string(1, c), pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.7.7 [string::find.last.not.of] before p7 as indicated:</p>

<blockquote><pre>
size_type find_last_not_of(charT c, size_type pos = npos) const <del>noexcept</del>;
</pre><blockquote><p>
-7- <i>Returns</i>: <tt>find_last_not_of(basic_string(1, c), pos)</tt>.
</p></blockquote></blockquote>

</li>

<li><p>Modify 21.4.8.2 [string::operator==] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator==(const charT* lhs,
                const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator==(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.3 [string::op!=] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator!=(const charT* lhs,
                const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator!=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.4 [string::op&lt;] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator&lt;(const charT* lhs,
               const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator&lt;(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
               const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.5 [string::op&gt;] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator&gt;(const charT* lhs,
               const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator&gt;(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
               const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.6 [string::op&lt;=] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator&lt;=(const charT* lhs,
                const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator&lt;=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.7 [string::op&gt;=] before p2+p3 as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
bool operator&gt;=(const charT* lhs,
                const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;

[&hellip;]
				
template&lt;class charT, class traits, class Allocator&gt;
bool operator&gt;=(const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
                const charT* rhs) <del>noexcept</del>;
</pre></blockquote>

</li>

<li><p>Modify 21.4.8.8 [string.special] as indicated (Remark: The change of
the semantics guarantees as of 17.5.1.4 [structure.specifications] p4 that 
the "Throws: Nothing" element of member swap is implied):</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,
    basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) <del>noexcept</del>;
</pre><blockquote><p>
-1- Effects: <ins>Equivalent to</ins> <tt>lhs.swap(rhs);</tt>
</p></blockquote></blockquote>

</li>
</ol>





<hr>
<h3><a name="2065"></a>2065. Minimal allocator interface</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-06-06 <b>Last modified:</b> 2011-06-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 17.6.3.5 [allocator.requirements] says <tt>SimpleAllocator</tt> satisfies
the requirements of Table 28 &mdash; Allocator requirements, but it doesn't support comparison 
for equality&#47;inequality.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the example in 17.6.3.5 [allocator.requirements] p5 as indicated:</p>
<blockquote><p>
-5- [&hellip;]
<p/>
[ <i>Example</i>: the following is an allocator class template supporting the minimal interface 
that satisfies the requirements of Table 28:
</p><blockquote><pre>
template &lt;class Tp&gt;
struct SimpleAllocator {
  typedef Tp value_type;
  SimpleAllocator(<i>ctor args</i>);
  template &lt;class T&gt; SimpleAllocator(const SimpleAllocator&lt;T&gt;&amp; other);
  Tp *allocate(std::size_t n);
  void deallocate(Tp *p, std::size_t n);
};

<ins>template &lt;class T, class U&gt;
bool operator==(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);
template &lt;class T, class U&gt;
bool operator!=(const SimpleAllocator&lt;T&gt;&amp;, const SimpleAllocator&lt;U&gt;&amp;);</ins>
</pre></blockquote><p>
&mdash; <i>end example</i> ]
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2066"></a>2066. Missing specification of <tt>vector::resize(size_type)</tt></h3>
<p><b>Section:</b> 23.3.6.3 [vector.capacity] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2011-03-29 <b>Last modified:</b> 2011-06-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++1x (N3090) there are two version of <tt>vector::resize</tt> &mdash; 23.3.6.3 [vector.capacity]:
</p>
<blockquote><pre>
void resize(size_type sz);
void resize(size_type sz, const T&amp; c);
</pre></blockquote>
<p>
The text in 23.3.6.3 [vector.capacity]&#47;12 only mentions "no effects on throw" for the
two args version of resize:
</p><blockquote><p>
<i>Requires</i>: If an exception is thrown other than by the move constructor
of a non-<tt>CopyConstructible</tt> <tt>T</tt> there are no effects.
</p></blockquote><p>
This seems like unintentional oversight since <tt>resize(size)</tt> is
semantically the same as <tt>resize(size, T())</tt>.
Additionally, the C++03 standard only specify single version of resize
with default for the second argument - 23.2.4:
</p>
<blockquote><pre>
void resize(size_type sz, T c = T());
</pre></blockquote>
<p>
Therefore not requiring same guarantees for both version of resize is
in fact a regression.
</p>

<p><i>[2011-06-12: Daniel comments]</i></p>


<p>The proposed resolution for issue <a href="lwg-active.html#2033">2033</a> should solve this issue as well.</p>


<p><b>Proposed resolution:</b></p>
<p>Apply the proposed resolution of issue <a href="lwg-active.html#2033">2033</a></p>





<hr>
<h3><a name="2067"></a>2067. <tt>packaged_task</tt> should have deleted copy c'tor with const parameter</h3>
<p><b>Section:</b> 30.6.9 [futures.task] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-06-16 <b>Last modified:</b> 2011-06-21</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>packaged_task</tt> is a move-only type with the following form of the
deleted copy operations:
</p>
<blockquote><pre>
packaged_task(packaged_task&amp;) = delete;
packaged_task&amp; operator=(packaged_task&amp;) = delete;
</pre></blockquote>
<p>
Note that the argument types are non-const. This does not look like a typo to me,
this form seems to exist from the very first proposing paper on 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html">N2276</a>.
Using either of form of the copy-constructor did not make much difference before the 
introduction of defaulted special member functions, but it makes now an observable 
difference. This was brought to my attention by a question on a German C++ newsgroup 
where the question was raised why the following code does not compile on a recent
gcc:
</p>
<blockquote><pre>
#include &lt;utility&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

int main(){
  std::packaged_task&lt;void()&gt; someTask([]{ std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; });
  std::thread someThread(std::move(someTask)); // <span style="color:#C80000">Error here</span>
  // Remainder omitted
}
</pre></blockquote>
<p>
It turned out that the error was produced by the instantiation of some return type
of <tt>std::bind</tt> which used a defaulted copy-constructor, which leads to a
const declaration conflict with [class.copy] p8.
<p/>
Some aspects of this problem are possibly core-language related, but I consider it
more than a service to programmers, if the library would declare the usual form of
the copy operations (i.e. those with const first parameter type) as deleted for
<tt>packaged_task</tt> to prevent such problems.
<p/>
A similar problem exists for class template <tt>basic_ostream</tt> in 27.7.3.1 [ostream]:
</p>
<blockquote><pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ostream : virtual public basic_ios&lt;charT,traits&gt; {
    [&hellip;]

    // 27.7.3.3 Assign/swap
    basic_ostream&amp; operator=(basic_ostream&amp; rhs) = delete;
    basic_ostream&amp; operator=(const basic_ostream&amp;&amp; rhs);
    void swap(basic_ostream&amp; rhs);
};
</pre></blockquote>
<p>
albeit this could be considered as an editorial swap of copy and move
assignment operator, I suggest to fix this as part of this issue as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the class template <tt>basic_ostream</tt> synopsis in 27.7.3.1 [ostream]
as indicated (Note: The prototype signature of the move assignment operator in 27.7.3.3 [ostream.assign]
is fine):</p>

<blockquote><pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ostream : virtual public basic_ios&lt;charT,traits&gt; {
    [&hellip;]

    // 27.7.3.3 Assign/swap
    basic_ostream&amp; operator=(<ins>const</ins> basic_ostream&amp; rhs) = delete;
    basic_ostream&amp; operator=(<del>const</del> basic_ostream&amp;&amp; rhs);
    void swap(basic_ostream&amp; rhs);
};
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>packaged_task</tt> synopsis in 30.6.9 [futures.task] p2
as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class&gt; class packaged_task; <i>// undefined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    [&hellip;]
  
    <i>// no copy</i>
    packaged_task(<ins>const</ins> packaged_task&amp;) = delete;
    packaged_task&amp; operator=(<ins>const</ins> packaged_task&amp;) = delete;
    
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2068"></a>2068. <tt>std::pair</tt> not C++03-compatible with defaulted copy c'tor</h3>
<p><b>Section:</b> 20.3.2 [pairs.pair] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-06-18 <b>Last modified:</b> 2011-06-21</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of the copy semantics of the C++03 version of <tt>std::pair</tt>
is defined by the class synopsis in [lib.pairs]:
</p>
<blockquote><pre>
template &lt;class T1, class T2&gt;
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  pair();
  pair(const T1&amp; x, const T2&amp; y);
  template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt; &amp;p);
};
</pre></blockquote>
<p>
The effect of this specification is, that the copy constructor is compiler-declared
with the proper form depending on the contained member types. In particular, the
instantiation of <tt>pair</tt> is well-formed with an element type that has a
copy constructor with non-const first parameter type like specialzations of <tt>auto_ptr</tt>
or any user-defined type like the following one:
</p>
<blockquote><pre>
struct A {
  A(A&amp;){}
};
</pre></blockquote>
<p>
In contrast to container types which require <tt>CopyConstructible</tt> value types, the C++03 <tt>pair</tt> 
does support these, albeit unusual, element types.
<p/>
The FDIS version of the <tt>std::pair</tt> specification does specify the same semantics by 
defaulting the copy and move constructor in 20.3.2 [pairs.pair]:
</p>
<blockquote><pre>
template &lt;class T1, class T2&gt;
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  <span style="color:#C80000">pair(const pair&amp;) = default;</span>
  <span style="color:#C80000">pair(pair&amp;&amp;) = default;</span>
  pair();
  [&hellip;]
};
</pre></blockquote>
<p>
But according to the current core rules this makes the instantiation of e.g. <tt>std::pair&lt;A, int&gt;</tt>
ill-formed, because of the <tt>const</tt> mismatch of the compiler-declared form of the copy constructor
with that of the defaulted declaration.
<p/>
Unfortunately there seems to be no simple library solution for this problem. If the defaulted declarations
were removed, both copy c'tor and move c'tor would be <b>deleted</b>, because there exist user-declared
copy assignment and move assignment operators in the FDIS. But these operations need to be user-defined 
to realize the wanted semantics of these operations for element types that are reference types. If core
rules would not be changed to fix that, I see the following options:
</p>
<ol>
<li>Intentionally decide to break the support for element types with non-const copy c'tors in <tt>pair</tt>.</li>
<li>User-declare both copy and move ctor to at least support the instantiation of the <tt>pair</tt> specializations, 
but this would still not allow to copy them by the copy constructor.</li>
<li>User-declare both the const and non-const copy ctors, the move ctor, and additionally the non-const copy assignment
operator to support the instantiation of the <tt>pair</tt> specializations and of these members. This would 
support all element types as it did in C++03, but all copy&#47;move members would be non-trivial.</li>
<li>Intentionally decide to give up support for element types that are references for <tt>pair</tt>, but
still keep the allocator support with the effect of removing all declarations of the special
copy&#47;move members. User code that needs to use <tt>tuple</tt> instead. But this would be a rather
drastic step requiring further corrections of the draft, e.g. a change of the signature of the algorithm
<tt>minmax</tt> (not the overload with the <tt>initializer_list</tt>) with a different return type.</li>
</ol>
<p>
This problem does <b>not</b> extend as backward-compatibility problem to <tt>tuple</tt>, because the TR1 
specification did explicitly declare copy constructor and copy assignment operator via the &quot;normal&quot; 
form:
</p>
<blockquote><pre>
tuple(const tuple&amp;);
tuple&amp; operator=(const tuple&amp;);
</pre></blockquote>
<p>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2069"></a>2069. Inconsistent exception spec for <tt>basic_string</tt> move constructor</h3>
<p><b>Section:</b> 21.4.2 [string.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2011-07-01 <b>Last modified:</b> 2011-07-11</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 21.4.2 [string.cons] contains these constructors in paragraphs 2 and 3:
</p>
<blockquote><pre>
basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
basic_string(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</pre><blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Throws</i>: The second form throws nothing if the allocator's move constructor throws nothing.
</p></blockquote></blockquote>
<p>
How can it <i>ever</i> throw anything if it is marked <tt>noexcept</tt>?
</p>
<p><i>[2011-07-11: Daniel comments and suggest wording changes]</i></p>

<p>
Further, according to paragraph 18 of the same sub-clause:
</p>
<blockquote><pre>
basic_string(const basic_string&amp; str, const Allocator&amp; alloc);
basic_string(basic_string&amp;&amp; str, const Allocator&amp; alloc);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-18- <i>Throws</i>: The second form throws nothing if <tt>alloc == str.get_allocator()</tt> 
unless the copy constructor for <tt>Allocator</tt> throws.
</p>
</blockquote></blockquote>
<p>
The constraint &quot;unless the copy constructor for <tt>Allocator</tt> throws&quot;
is redundant, because according to Table 28 &mdash; Allocator requirements, the expressions
</p>
<blockquote><pre>
X a1(a);
X a(b);
</pre></blockquote>
<p>
impose the requirement: &quot;Shall not exit via an exception&quot;.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change 21.4.2 [string.cons] p3 as indicated (This move constructor has a wide
contract and is therefore safely marked as <tt>noexcept</tt>):</p>

<blockquote><pre>
basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
basic_string(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept;
</pre><blockquote>
<p>
-2- <i>Effects</i>: Constructs an object of class <tt>basic_string</tt> as indicated in Table 64. 
In the second form, <tt>str</tt> is left in a valid state with an unspecified value.
<p/>
<del>-3- <i>Throws</i>: The second form throws nothing if the allocator's move constructor throws nothing.</del>
</p>
</blockquote></blockquote>
</li>

<li><p>Change 21.4.2 [string.cons] p18 as indicated (This move-like constructor may throw,
if the allocators don't compare equal, but not because of a potentially throwing allocator
copy constructor, only because the allocation attempt may fail and throw an exception):</p>

<blockquote><pre>
basic_string(const basic_string&amp; str, const Allocator&amp; alloc);
basic_string(basic_string&amp;&amp; str, const Allocator&amp; alloc);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-18- <i>Throws</i>: The second form throws nothing if <tt>alloc == str.get_allocator()</tt> 
<del>unless the copy constructor for <tt>Allocator</tt> throws</del>.
</p>
</blockquote></blockquote>
</li>

</ol>






</body>
</html>
